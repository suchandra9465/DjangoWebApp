#!/usr/bin/python3

import builtins as __builtin__
import sys
import urllib3
import requests
from requests.packages.urllib3.util.ssl_ import create_urllib3_context
from requests.adapters import HTTPAdapter


def chunk(*msg):
    return "\r\n%X\r\n%s" % (len(*msg), *msg)


def print(*args, **kwargs):
    """My custom print() function."""
    # Adding new arguments to the print function signature
    if not options.web:
        __builtin__.print(*args, **kwargs)
    else:
        sys.stdout.write(chunk(str(*args).rstrip('\r') + "\r\n"))
    return


class bcolors:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'


class logging:
    NONE = -1
    EMERGENCY = 0
    ALERT = 1
    CRITICAL = 2
    ERROR = 3
    WARNING = 4
    NOTICE = 5
    INFORMATIONAL = 6
    INFO = 6
    DEBUG = 7


class Node:
    def __init__(self, identifier):
        self.__identifier = identifier
        self.__children = []

    @property
    def identifier(self):
        return self.__identifier

    @property
    def children(self):
        return self.__children

    def add_child(self, identifier):
        self.__children.append(identifier)


(_ROOT, _DEPTH, _BREADTH) = range(3)


class Tree:

    def get_paths(node, path=[]):
        from copy import deepcopy
        path = deepcopy(path)
        path.append(node.identifier)
        if not node.children:
            pathss.append(path)
        for child in node.children:
            self.__get_paths(child, path)

    def __init__(self):
        self.__nodes = {}

    @property
    def nodes(self):
        return self.__nodes

    def add_node(self, identifier, parent=None):
        node = Node(identifier)
        self[identifier] = node

        if parent is not None:
            self[parent].add_child(identifier)

        return node

    def display(self, identifier, depth=_ROOT):
        children = self[identifier].children
        if depth == _ROOT:
            print("{0}".format(identifier))
        else:
            print("\t" * depth, "{0}".format(identifier))

        depth += 1
        for child in children:
            self.display(child, depth)  # recursive call

    # def path(self, identifier, parents=[], depth=_ROOT):
    # children = self[identifier].children

    # if depth == _ROOT:
    # print("{0}".format(identifier))
    # else:
    # print("\t"*depth, "{0}".format(identifier))
    # #print("\t"*depth, "{0}".format(identifier))

    # #depth += 1
    # parents.append(identifier)
    # for child in children:
    # for parent in parents:
    # print (parent + ' --> ', end='')
    # self.path(child, parents, depth, )  # recursive call
    # parents.pop()

    def paths(self, obj, complete_list=None, path=None):

        def paths_to_list(path_string):

            tmp_list = []
            for item in path_string:
                tmp_list.append(item.split(chr(0)))
            return tmp_list;

        if path == None:
            path = ''
            complete_list = []
        children = self[obj].children
        if path == '':
            path = obj
        else:
            path = path + chr(0) + obj
        for child in children:
            # path = path + "/"
            self.paths(child, complete_list, path)
        complete_list.append(path)

        return paths_to_list(complete_list);

    def traverse(self, identifier, mode=_DEPTH):
        # Python generator. Loosly based on an algorithm from
        # 'Essential LISP' by John R. Anderson, Albert T. Corbett,
        # and Brian J. Reiser, page 239-241
        yield identifier
        queue = self[identifier].children
        while queue:
            yield queue[0]
            expansion = self[queue[0]].children
            if mode == _DEPTH:
                queue = expansion + queue[1:]  # depth-first
            elif mode == _BREADTH:
                queue = queue[1:] + expansion  # width-first

    def __getitem__(self, key):
        return self.__nodes[key]

    def __setitem__(self, key, item):
        self.__nodes[key] = item


def file_to_list(filename):
    import os

    filelist = []
    if os.path.isfile(filename):
        with open(filename, 'r') as infile:
            for line in infile:
                if line[0] != '#':
                    filelist.append(line)

    return filelist


def sc(instr):
    import re

    outstr = re.sub('%20', ' ', instr)
    outstr = re.sub('%2b', '_', outstr)
    outstr = re.sub(r'[]`\/,?!@#$%^&*()<>;:=+{}\\\[\"\\\']', '_', outstr)
    return outstr;


def ss(instr):
    import re

    outstr = re.sub('%20', ' ', instr)
    outstr = re.sub('%2b', '_', outstr)

    return outstr;


def cidr_to_netmask(prefix):
    ## Convert CIDR notation to netmask /## --> ###.###.###.###
    return '.'.join([str((0xffffffff << (32 - int(prefix)) >> i) & 0xff) for i in [24, 16, 8, 0]])


def netmask_to_cidr(netmask):
    ## Convert netmask to CIDR notation ###.###.###.### --> /##
    return sum([bin(int(x)).count("1") for x in netmask.split(".")])


def convert_exp_file(infile, outfile, encoded=None):
    ## This converts a sonicwall .exp file to a plain textfile

    import base64
    import re
    import os
    if os.path.isfile(infile) or encoded:
        if not encoded:
            encoded_file = open(infile, 'rb')
            encoded = encoded_file.read()
        decoded = base64.decodestring(encoded)
        decoded_with_newline = re.sub(r'&', '\n', decoded.decode('utf-8', errors='ignore'))
        decoded_space_removed = re.sub(r'%20$', '', decoded_with_newline)
        if outfile:
            decoded_file = open(outfile, 'wb')
            for line in decoded_space_removed.splitlines():
                decoded_space_removed = re.sub(r'%20$', '', line)
                decoded_file.write(decoded_space_removed.encode())
                decoded_file.write('\n'.encode())
            decoded_file.close()
        '''
        return_lines=''
        for line in decoded_space_removed.splitlines():
                return_space_removed = re.sub(r'%20$','',line)
                return_lines+=decoded_space_removed+'\n'
                #decoded_file.write('\n'.encode())
        '''
    else:
        return False
    # with open (configfilename) as working_file:
    #        config = working_file.read()
    return re.sub(r'&', '\n', decoded.decode('utf-8', errors='ignore'))


def log(*args, level=5, **kwargs):
    import builtins as __builtin__
    import sys

    if options.logging >= level:
        # __builtin__.print(*args, **kwargs)
        print(*args, **kwargs)
    return


def log_info(*args, level=6, **kwargs):
    import builtins as __builtin__
    import sys

    if options.logging >= level:
        # __builtin__.print(*args, **kwargs)
        print(*args, **kwargs)
    return


def debug(*args, **kwargs):
    # import builtins as __builtin__
    # import sys
    if options.logging >= 7:
        # __builtin__.print(*args, **kwargs)
        print('DEBUG:', *args, **kwargs)
    return


def generate_group_mappings(tmp_config, group_type):
    ## Used for Sonicwall configuration, this generates a dictionary of Groupname --> [ List of Group Members ]

    import re
    from collections import defaultdict

    group_mappings = defaultdict(list)
    search_string = r'^' + group_type + '_.*'

    # with open (infile) as working_file:
    #    tmp_config = working_file.read()

    tmp_mappings = re.findall(search_string, tmp_config, flags=re.MULTILINE)
    for index, object in enumerate(tmp_mappings[::2]):
        junk, member = object.split('=', 1)
        junk, group = tmp_mappings[(index * 2) + 1].split('=', 1)
        group_mappings[group].append(member)
    # working_file.close()

    return group_mappings;


def migrate_orig(objectname, config, property_list, skipdisabled=False):
    ## Used to read the various configuration elements of Sonicwall configurations.

    import re
    from collections import OrderedDict

    regexpattern = r'^interface.*_.*=.*|^' + objectname + '.*_.*=.*'
    regexpattern0 = r'^' + objectname + '.*_0=.*'
    config_dict = OrderedDict()

    # with open (infile) as working_file:
    #    config = working_file.read()
    matched = re.findall(regexpattern, config, flags=re.MULTILINE)

    for line in matched:

        object_beg, object_property = line.split('=', 1)
        object_key, object_num = object_beg.rsplit('_', 1)
        object_index = int(object_num)

        if object_key in property_list:
            if not object_index in config_dict:
                config_dict[object_index] = OrderedDict()

            config_dict[object_index][object_key] = object_property
            ## insert empty policyDstApps / natPolicyName values for Sonicwalls
            if object_key == 'policyDstSvc':
                config_dict[object_index]['policyDstApps'] = []
            if object_key == 'natPolicyOrigSrc':
                config_dict[object_index]['natPolicyName'] = ''

    ## REMOVED DISABLED RULES IF skip-disabled set
    if options.skip_disabled:
        skipped_dict = OrderedDict()
        for index in config_dict:
            if config_dict[index]['policyEnabled'] == '1':
                skipped_dict[index] = config_dict[index]
        return skipped_dict;

    return config_dict;


def migrate(objectname, config, property_list):
    ## Used to read the various configuration elements of Sonicwall configurations.
    ## New version that no longer uses numerical index (which later gets stripped with remove_index)

    import re
    from collections import OrderedDict

    regexpattern = r'^portShutdown.*_.*=.*|^interface.*_.*=.*|^' + objectname + '.*_.*=.*'
    config_dict = OrderedDict()

    # with open (infile) as working_file:
    #    config = working_file.read()
    matched = re.findall(regexpattern, config, flags=re.MULTILINE)

    for line in matched:

        object_beg, object_property = line.split('=', 1)
        object_key, object_num = object_beg.rsplit('_', 1)

        if object_key == property_list[0]:
            object_name = object_property.rstrip().lstrip()
        if object_key in property_list:
            if not object_name in config_dict:
                config_dict[object_name] = OrderedDict()
            config_dict[object_name][object_key] = object_property.rstrip().lstrip()
            prev_object_num = object_num

    return config_dict;


def find_dupes(config):
    ## First entry will be kept.  All subsequent duplicates should point to the original/first item

    from copy import deepcopy
    from collections import OrderedDict
    duplicates = OrderedDict()

    ## Find Dupe Addresses

    total = len(config['addresses'])
    count = 0
    tmpaddresses = deepcopy(config['addresses'])

    for address in tmpaddresses:
        del tmpaddresses[address]['addrObjId']
        del tmpaddresses[address]['addrObjIdDisp']

    duplicates['addresses'] = OrderedDict()

    for masterindex in tmpaddresses:
        masterobject = tmpaddresses[masterindex]
        ## If master object is already marked as a duplicate object, skip it
        if masterindex not in duplicates['addresses']:
            ## Only find dupes if address object is not a group (8)
            if masterobject['addrObjType'] != '8':  # and masterobject['addrObjProperties'] == '14':
                for candidate in tmpaddresses:
                    if masterindex != candidate:  # don't compare master with itself
                        candidateobject = tmpaddresses[candidate]
                        if masterobject == candidateobject and candidateobject[
                            'addrObjProperties'] == '14':  # only remove candidates that are a user-defined object
                            if candidate not in duplicates[
                                'addresses']:  ## Only add the candidate if its not already in the dupe list
                                duplicates['addresses'][candidate] = masterindex
                            # break;  # break removed, as it would stop searching for candidate in address1 after first match (not desired)
        count = count + 1

    ## Find duplicate address groups - very low priority.  duplicates of entire groups not likely and would be slow

    ## Find duplicate services

    total = len(config['services'])
    count = 0
    tmpservices = deepcopy(config['services'])

    for service in tmpservices:
        del tmpservices[service]['svcObjId']

    duplicates['services'] = OrderedDict()

    for masterindex in tmpservices:
        masterobject = tmpservices[masterindex]
        ## If master object is already marked as a duplicate object, skip it
        if masterindex not in duplicates['services']:
            ## Only find dupes if service object is not a group
            if masterobject[
                'svcObjType'] == '1':  ## master object can be any type, and masterobject['svcObjProperties'] == '14':
                for candidate in tmpservices:
                    if masterindex != candidate:  # don't compare master with itself
                        candidateobject = tmpservices[candidate]
                        if masterobject == candidateobject and candidateobject[
                            'svcObjProperties'] == '14':  # only remove candidates that are a user-defined object
                            if candidate not in duplicates[
                                'services']:  ## Only add the candidate if its not already in the dupe list
                                duplicates['services'][candidate] = masterindex
            ## svcPortSet FIX
        count = count + 1

    ## Find duplicate service groups - very low priority.  duplicates of entire groups not likely and would be slow
    return duplicates;


## Original script does de-dupe before find_unused, so at the moment, this script returns too many results

def find_unused2(config, context):
    ## multiple passes for checkpoint is useless as results need to be verified with whereused
    ## add support to check routing tables (sonicwall)
    ## add support to check NAT policies (DONE)
    ## only check "active" policies and "enabled" rules - this will require more parsing of the whereused command

    from collections import defaultdict
    import sys

    unused = defaultdict(dict)
    unused['addresses'] = set()
    unused['addressgroups'] = set()
    unused['services'] = set()
    unused['servicegroups'] = set()
    expanded_addrgroup = defaultdict(dict)
    expanded_svcgroup = defaultdict(dict)
    all_address_group_members = set()
    all_service_group_members = set()
    all_policy_address_members = set()
    all_policy_service_members = set()
    log('!-- Building set of address group members')
    for address in config['addresses']:
        if config['addresses'][address]['addrObjType'] == '8':
            expanded_addrgroup[address] = expand_address(config['addresses'], config['addresses'][address]['addrObjId'],
                                                         config['addressmappings'], True)
            for member in expanded_addrgroup[address]:
                all_address_group_members.add(member)
    log('!-- Building set of service group members')
    for service in config['services']:
        if config['services'][service]['svcObjType'] == '2':
            expanded_svcgroup[service] = expand_service(config['services'], config['services'][service]['svcObjId'],
                                                        config['servicemappings'], True)
            for member in expanded_svcgroup[service]:
                all_service_group_members.add(member)
    log('!-- Building sets for policy sources, destinations and services')
    for policy in config['policies']:
        for src in config['policies'][policy]['policySrcNet']:
            # debug(config['policies'][policy]['policyName'], config['policies'][policy]['policyUiNum'], 'SRC:',src)
            all_policy_address_members.add(src)
        for dst in config['policies'][policy]['policyDstNet']:
            # debug(config['policies'][policy]['policyName'], config['policies'][policy]['policyUiNum'], 'DST:',dst)
            all_policy_address_members.add(dst)
        for svc in config['policies'][policy]['policyDstSvc']:
            # debug(config['policies'][policy]['policyName'], config['policies'][policy]['policyUiNum'], 'DST:',dst)
            all_policy_service_members.add(svc)

    for policy in config['nat']:
        # 'natPolicyOrigSrc', 'natPolicyOrigDst', 'natPolicyOrigSvc', 'natPolicyTransSrc', 'natPolicyTransDst', 'natPolicyTransSvc'
        for src in config['nat'][policy]['natPolicyOrigSrc']:
            all_policy_address_members.add(src)
        for dst in config['nat'][policy]['natPolicyOrigDst']:
            all_policy_address_members.add(dst)
        for svc in config['nat'][policy]['natPolicyOrigSvc']:
            all_policy_service_members.add(svc)
        for src in config['nat'][policy]['natPolicyTransSrc']:
            all_policy_address_members.add(src)
        for dst in config['nat'][policy]['natPolicyTransDst']:
            all_policy_address_members.add(dst)
        for svc in config['nat'][policy]['natPolicyTransSvc']:
            all_policy_service_members.add(svc)

    unused_count = -1
    while len(unused['addresses']) + len(unused['addressgroups']) > unused_count:
        debug(len(unused['addresses']) + len(unused['addressgroups']), unused_count)
        debug('looping addresses')
        unused_count = len(unused['addresses']) + len(unused['addressgroups'])
        for address in config['addresses']:
            groupfound = None
            if config['addresses'][address]['addrObjType'] != '8':
                if not (address in all_address_group_members) and not (address in all_policy_address_members):
                    unused['addresses'].add(address)
            else:
                for group in expanded_addrgroup:
                    if address != group:
                        if address in expanded_addrgroup[group]:
                            groupfound = True
                            break
                if not groupfound:
                    if not (address in all_policy_address_members):
                        unused['addressgroups'].add(address)
                        if address in all_policy_address_members:
                            debug('removing {} from pol set'.format(address))
                            all_policy_address_members.remove(address)
                        if address in all_address_group_members:
                            debug('removing {} from address set'.format(address))
                            all_address_group_members.remove(address)
    debug(len(unused['addresses']) + len(unused['addressgroups']), unused_count)

    unused_count = -1
    while len(unused['services']) > unused_count:
        debug(len(unused['services']) + len(unused['servicegroups']), unused_count)
        debug('looping services')
        unused_count = len(unused['services']) + len(unused['servicegroups'])
        for service in config['services']:
            groupfound = None
            if config['services'][service]['svcObjType'] != '2':
                if not (service in all_service_group_members) and not (service in all_policy_service_members):
                    unused['services'].add(service)
            else:
                for group in expanded_svcgroup:
                    if service != group:
                        if service in expanded_svcgroup[group]:
                            groupfound = True
                            break
                if not groupfound:
                    if not (service in all_policy_service_members):
                        unused['servicegroups'].add(service)
                        if service in all_policy_service_members:
                            debug('removing {} from pol set'.format(service))
                            all_policy_service_members.remove(service)
                        if service in all_service_group_members:
                            debug('removing {} from service set'.format(service))
                            all_service_group_members.remove(service)
    debug(len(unused['services']) + len(unused['servicegroups']), unused_count)
    # print(expanded_svcgroup)

    '''for category in unused:
        print ('-' * 180)
        print(category, len(unused[category]))
        print ('-' * 180)
        for item in unused[category]:
            print('{},{}'.format(category,item))
    '''

    return unused


def find_unused(config, context):
    ### WARNING :  This routine only checks for unused objects in areas that are loaded from the config for migration.
    ### For example an address object could be used for a NAT rule, but since NAT rules are not currently migrated, NAT
    ### rules are not searched.  This find_unused function should only be used for migration script purposes, and updated
    ### if/when new migration functionality is added.  A second function should be created to count the number of
    ### occurrances an object name exists in the entire configuration file, if broader support for unused object detection
    ### is needed.

    ## Fix logic of this routine, as it is fairly slow.
    ## Loop over every address object
    ## Check if object is an address or group (Does this really matter?)
    ## Check to see if it is used in an address group object, a policy source/dest or routing object

    from collections import defaultdict
    import sys

    unused = defaultdict(dict)
    expanded_addrgroup = defaultdict(dict)

    total = len(config['addresses'])
    count = 0
    loopcount = 0

    unused['addressgroups'] = []
    unused['addresses'] = []

    ## FIND UNUSED ADDRESS GROUPS

    addr_list = list(config['addresses'].keys())  # create list of all address objects

    ## build expanded address list for all address groups  # improves speed by about 6x

    for address in config['addresses']:
        if config['addresses'][address]['addrObjType'] == '8':
            expanded_addrgroup[address] = expand_address(config['addresses'], config['addresses'][address]['addrObjId'],
                                                         config['addressmappings'], True)

    for index1, address1 in enumerate(addr_list):
        ## Check maps first
        found_in_policy = False
        ## CHECK IF ADDRESS IS USED IN POLICY
        for policy in config['policies']:
            ## CHECK EACH SOURCE ADDRESS OBJECT IN POLICY
            for source in config['policies'][policy]['policySrcNet']:
                ## DOES THE ADDRESS MATCH THE SOURCE EXACTLY?
                if config['addresses'][address1]['addrObjId'] == source:
                    found_in_policy = True
                    break;
                if config['addresses'][address1]['addrObjId'] in expanded_addrgroup[
                    source]:  # expand_address(config['addresses'], source, config['addressmappings'], True):
                    found_in_policy = True
                    break;
            ## CHECK EACH DESTINATION ADDRESS OBJECT IN POLICY
            for dest in config['policies'][policy]['policyDstNet']:
                if config['addresses'][address1]['addrObjId'] == dest:
                    found_in_policy = True
                    break;
                if config['addresses'][address1]['addrObjId'] in expanded_addrgroup[
                    source]:  # expand_address(config['addresses'], dest, config['addressmappings'], True):
                    #                    if config['addresses'][address1]['addrObjId'] in expand_address(config['addresses'], dest, config['addressmappings'], True):
                    found_in_policy = True
                    break;
        ## CHECK IF THE ADDRESS IS PART OF AN ADDRESS GROUP
        if found_in_policy == False:  # check to see if address is used in a group, somewhere
            found_in_group = False

            for address2 in addr_list:
                if address1 != address2:
                    ## Check to see if address is part of an adress group mapping
                    if config['addresses'][address1]['addrObjId'] in expanded_addrgroup[config['addresses'][address2][
                        'addrObjId']]:  # expand_address(config['addresses'], config['addresses'][address2]['addrObjId'], config['addressmappings'], True):
                        found_in_group = True
                        break;

            if found_in_group == False:
                found_in_route = False
                for route in config['routing']:
                    if address1 == config['routing'][route]['pbrObjSrc'] or address1 == config['routing'][route][
                        'pbrObjDst'] or address1 == config['routing'][route]['pbrObjGw']:
                        found_in_route = True
                        break;
                    if address1 in expanded_addrgroup[config['routing'][route]['pbrObjSrc']] or address1 in \
                            expanded_addrgroup[config['routing'][route]['pbrObjDst']] or address1 in expanded_addrgroup[
                        config['routing'][route]['pbrObjGw']]:
                        found_in_route = True
                        break;
                if found_in_route == False:
                    if config['addresses'][address1]['addrObjType'] == '8':
                        unused['addressgroups'].append(address1)
                    else:
                        unused['addresses'].append(address1)
        count = count + 1
        if not options.web: log('[' + str(count) + '/' + str(total) + ']   ', end='\r')

    ### FIND UNUSED SERVICE OBJECTS

    total = len(config['services'])
    count = 0

    unused['servicegroups'] = []
    ## FIND UNUSED SERVICE GROUPS

    for service1 in config['services']:
        if config['services'][service1]['svcObjType'] == '2':
            found_in_policy = False
            ## CHECK IF SERVICE IS USED IN POLICY
            for policy in config['policies']:
                ## CHECK EACH DEST SERVICE OBJECT IN POLICY
                for service in config['policies'][policy]['policyDstSvc']:
                    if config['services'][service1]['svcObjId'] in expand_service(config['services'], service,
                                                                                  config['servicemappings'], True):
                        found_in_policy = True
                        break;
                    ## DOES THE SERVICE MATCH THE SOURCE EXACTLY?
                    if config['services'][service1]['svcObjId'] == service:
                        found_in_policy = True
                        break;

            ## CHECK IF THE SERVICE IS PART OF A SERVICE GROUP
            ## (DONE) CHANGEME - expand_service needs to be updated to include service groups  (inc_group=True param now passed to function)

            if found_in_policy == False:  # check to see if service is used in a group, somewhere
                found_in_group = False
                for service2 in config['services']:
                    loopcount = loopcount + 1
                    if service1 != service2:
                        ## Check to see if service is in an expanded service object (should not need to perform this check for service groups) WHY NOT?
                        if config['services'][service1]['svcObjId'] in expand_service(config['services'],
                                                                                      config['services'][service2][
                                                                                          'svcObjId'],
                                                                                      config['servicemappings'], True):
                            found_in_group = True
                            break;
                if found_in_group == False:
                    found_in_route = False
                    for route in config['routing']:
                        if service1 == config['routing'][route]['pbrObjSvc']:
                            found_in_route = True
                    if found_in_route == False:
                        unused['servicegroups'].append(service1)
        count = count + 1
        if not options.web: log('[' + str(count) + '/' + str(total) + ']   ', end='\r')

    total = len(config['services'])
    count = 0

    ## FIND UNUSED SERVICES
    unused['services'] = []
    for service1 in config['services']:
        if config['services'][service1]['svcObjType'] != '2':
            found_in_policy = False
            for policy in config['policies']:
                for service in config['policies'][policy]['policyDstSvc']:
                    if 'servicemappings' in config:
                        if service in config['servicemappings']:
                            if config['services'][service1]['svcObjId'] in expand_service(config['services'], service,
                                                                                          context, True):
                                found_in_policy = True
                                break;
                    if config['services'][service1]['svcObjId'] == service:
                        found_in_policy = True
                        break;
            if found_in_policy == False:  # check to see if service is used in a group, somewhere
                found_in_group = False
                for service2 in config['services']:
                    if service1 != service2 and config['services'][service2]['svcObjType'] == "2":
                        if config['services'][service1]['svcObjId'] in expand_service(config['services'],
                                                                                      config['services'][service2][
                                                                                          'svcObjId'],
                                                                                      config['servicemappings'], True):
                            found_in_group = True
                            break;
                if found_in_group == False:
                    unused['services'].append(service1)
        count = count + 1
        if not options.web: log('[' + str(count) + '/' + str(total) + ']    ', end='\r')
    return unused;


def create_logging():
    log(
        '''      <shared>
        <log-settings>
          <syslog>''')
    for log_profile in customops.logsettings:

        log('''            <entry name=\"''' + log_profile + '''\">''')
        log('''              <server>''')

        for log_server in customops.logsettings[log_profile]:
            log('''                <entry name=\"''' + log_server + '''\">
                  <transport>''' + customops.logsettings[log_profile][log_server]['transport'] + '''</transport>
                  <port>''' + customops.logsettings[log_profile][log_server]['port'] + '''</port>
                  <format>''' + customops.logsettings[log_profile][log_server]['format'] + '''</format>
                  <server>''' + customops.logsettings[log_profile][log_server]['server'] + '''</server>
                  <facility>''' + customops.logsettings[log_profile][log_server]['facility'] + '''</facility>
                </entry>''')

        log('''              </server>
            </entry>''')

    log('''          </syslog>
          <config>
            <any>
              <send-syslog>
                <using-syslog-setting>''' + customops.logging + '''</using-syslog-setting>
              </send-syslog>
              <send-to-panorama>yes</send-to-panorama>
              <send-snmptrap>
                <using-snmptrap-setting>''' + customops.snmp_traps + '''</using-snmptrap-setting>
              </send-snmptrap>
            </any>
          </config>
          
          <snmptrap>''')
    for snmp_profile in customops.trapprofiles:

        log('''            <entry name="''' + customops.snmp_traps + '''">
              <version>
                <v2c>
                  <server>''')
        for snmp_destination in customops.trapprofiles[snmp_profile]:
            log('''                    <entry name="''' + snmp_destination + '''">
                      <manager>''' + customops.trapprofiles[snmp_profile][snmp_destination]['ip'] + '''</manager>
                      <community>''' + customops.trapprofiles[snmp_profile][snmp_destination]['community'] + '''</community>
                    </entry>''')
        log('''                  </server>
                </v2c>
              </version>
            </entry>''')

    log('''          </snmptrap>
          <system>
            <informational>
              <send-syslog>
                <using-syslog-setting>''' + customops.logging + '''</using-syslog-setting>
              </send-syslog>
              <send-to-panorama>yes</send-to-panorama>
              <send-snmptrap>
                <using-snmptrap-setting>''' + customops.snmp_traps + '''</using-snmptrap-setting>
              </send-snmptrap>
            </informational>
            <critical>
              <send-syslog>
                <using-syslog-setting>''' + customops.logging + '''</using-syslog-setting>
              </send-syslog>
              <send-to-panorama>yes</send-to-panorama>
              <send-snmptrap>
                <using-snmptrap-setting>''' + customops.snmp_traps + '''</using-snmptrap-setting>
              </send-snmptrap>
            </critical>
            <high>
              <send-syslog>
                <using-syslog-setting>''' + customops.logging + '''</using-syslog-setting>
              </send-syslog>
              <send-to-panorama>yes</send-to-panorama>
              <send-snmptrap>
                <using-snmptrap-setting>''' + customops.snmp_traps + '''</using-snmptrap-setting>
              </send-snmptrap>
            </high>
            <medium>
              <send-syslog>
                <using-syslog-setting>''' + customops.logging + '''</using-syslog-setting>
              </send-syslog>
              <send-to-panorama>yes</send-to-panorama>
              <send-snmptrap>
                <using-snmptrap-setting>''' + customops.snmp_traps + '''</using-snmptrap-setting>
              </send-snmptrap>
            </medium>
            <low>
              <send-syslog>
                <using-syslog-setting>''' + customops.logging + '''</using-syslog-setting>
              </send-syslog>
              <send-to-panorama>yes</send-to-panorama>
              <send-snmptrap>
                <using-snmptrap-setting>''' + customops.snmp_traps + '''</using-snmptrap-setting>
              </send-snmptrap>
            </low>
          </system>
          <correlation>
            <critical>
              <send-syslog>
                <using-syslog-setting>''' + customops.logging + '''</using-syslog-setting>
              </send-syslog>
            </critical>
            <high>
              <send-syslog>
                <using-syslog-setting>''' + customops.logging + '''</using-syslog-setting>
              </send-syslog>
            </high>
            <medium>
              <send-syslog>
                <using-syslog-setting>''' + customops.logging + '''</using-syslog-setting>
              </send-syslog>
            </medium>
            <low>
              <send-syslog>
                <using-syslog-setting>''' + customops.logging + '''</using-syslog-setting>
              </send-syslog>
            </low>
          </correlation>
        </log-settings>
      </shared>
      <pan7>
        <log-settings>
          <profiles>
            <entry name=\"''' + customops.log_forward_profile_name + '''\">
              <traffic>
                <any>
                  <send-to-panorama>yes</send-to-panorama>
                  <send-syslog>
                    <using-syslog-setting>''' + customops.logging + '''</using-syslog-setting>
                  </send-syslog>
                </any>
              </traffic>
              <alarm>
                <informational>
                  <send-to-panorama>yes</send-to-panorama>
                  <send-syslog>
                    <using-syslog-setting>''' + customops.logging + '''</using-syslog-setting>
                  </send-syslog>
                </informational>
                <low>
                  <send-to-panorama>yes</send-to-panorama>
                  <send-syslog>
                    <using-syslog-setting>''' + customops.logging + '''</using-syslog-setting>
                  </send-syslog>
                </low>
                <medium>
                  <send-to-panorama>yes</send-to-panorama>
                  <send-syslog>
                    <using-syslog-setting>''' + customops.logging + '''</using-syslog-setting>
                  </send-syslog>
                </medium>
                <high>
                  <send-to-panorama>yes</send-to-panorama>
                  <send-syslog>
                    <using-syslog-setting>''' + customops.logging + '''</using-syslog-setting>
                  </send-syslog>
                </high>
                <critical>
                  <send-to-panorama>yes</send-to-panorama>
                  <send-syslog>
                    <using-syslog-setting>''' + customops.logging + '''</using-syslog-setting>
                  </send-syslog>
                </critical>
              </alarm>
              <wildfire>
                <benign>
                  <send-to-panorama>yes</send-to-panorama>
                  <send-syslog>
                    <using-syslog-setting>''' + customops.logging + '''</using-syslog-setting>
                  </send-syslog>
                </benign>
                <grayware>
                  <send-to-panorama>yes</send-to-panorama>
                  <send-syslog>
                    <using-syslog-setting>''' + customops.logging + '''</using-syslog-setting>
                  </send-syslog>
                </grayware>
                <malicious>
                  <send-to-panorama>yes</send-to-panorama>
                  <send-syslog>
                    <using-syslog-setting>''' + customops.logging + '''</using-syslog-setting>
                  </send-syslog>
                </malicious>
              </wildfire>
            </entry>
          </profiles>
        </log-settings>
      </pan7>
      <pan8>
        <log-settings>
          <profiles>
            <entry name=\"''' + customops.log_forward_profile_name + '''\">
              <match-list>
                <entry name=\"Matchlist\">
                  <send-syslog>
                    <member>AMER-Dell-Standard-Logging</member>
                  </send-syslog>
                  <log-type>traffic</log-type>
                  <filter>All Logs</filter>
                  <send-to-panorama>no</send-to-panorama>
                </entry>
              </match-list>
            </entry>
          </profiles>
        </log-settings>
      </pan8>''')
    return


def create_addresses(addresses, addressesfqdn, address_map, builtin_map):
    ## Generate address and address-group portions of Palo Alto .xml configuration

    log('          <address>')
    for index in addresses:
        # if addresses[index]['addrObjProperties'] != '14':
        #      debug(addresses[index]['addrObjId'])
        # nat_index=1
        # if addresses[index]['addrObjProperties'] == '14' and addresses[index]['addrObjType'] != '8':
        if addresses[index][
            'addrObjType'] != '8':  # and ( addresses[index]['addrObjProperties'] == '14' or addresses[index]['addrObjId'] in builtin_map):
            # if addresses[index]['addrObjProperties'] != '14': # check to see if address object is used in a NAT rule -- If so, create new NAT address object
            #    pass
            '''
            #tmp_address=None
            for policy in nat_policies:
                if nat_policies[policy]['natPolicyProperties'] not in ['1023', '17407']:
                    tmp_address=None
                    #nat_props = [ 'natPolicyOrigSrc', 'natPolicyOrigDst', 'natPolicyOrigSvc', 'natPolicyTransSrc', 'natPolicyTransDst', 'natPolicyTransSvc', 'natPolicySrcIface', 'natPolicyDstIface', 'natPolicyEnabled', 'natPolicyComment', 'natPolicyProperties', 'natPolicyName' ]
                    if addresses[index]['addrObjId'] in nat_policies[policy]['natPolicyOrigSrc']:
                        tmp_address='NAT_OrigSrc_{}'.format(int(policy)+1)
                    elif addresses[index]['addrObjId'] in nat_policies[policy]['natPolicyOrigDst']:
                        tmp_address='NAT_OrigDst_{}'.format(int(policy)+1)
                    elif addresses[index]['addrObjId'] in nat_policies[policy]['natPolicyTransSrc']:
                        tmp_address='NAT_TransSrc_{}'.format(int(policy)+1)
                    elif addresses[index]['addrObjId'] in nat_policies[policy]['natPolicyTransDst']:
                        tmp_address='NAT_TransDst_{}'.format(int(policy)+1)
                    if tmp_address:
                        log('            <entry name="' + sc(tmp_address) + '">')
                        if addresses[index]['addrObjType'] == '1':
                            log('              <ip-netmask>' + addresses[index]['addrObjIp1'] + '/32</ip-netmask>')
                        elif addresses[index]['addrObjType'] == '2':
                            log('              <ip-range>' + addresses[index]['addrObjIp1'] + '-' + addresses[index]['addrObjIp2'] + '</ip-range>')
                        elif addresses[index]['addrObjType'] == '4':
                            bitmask = sum([bin(int(x)).count("1") for x in addresses[index]['addrObjIp2'].split(".")])
                            log('              <ip-netmask>' + addresses[index]['addrObjIp1'] + '/' + str(bitmask) + '</ip-netmask>')
                        log('              <description>' + ss(addresses[index]['addrObjIdDisp']) + '</description>')
                        log('            </entry>')
        '''
            # else:
            if addresses[index]['addrObjProperties'] == '14':
                tmp_addr = sc(addresses[index]['addrObjId'])
            else:
                tmp_addr = "BUILTIN_" + sc(
                    addresses[index]['addrObjId'])  # placeholder name, eventually use the builtin map name
            log('            <entry name="' + tmp_addr + '">')
            if addresses[index]['addrObjType'] == '1':
                log('              <ip-netmask>' + addresses[index]['addrObjIp1'] + '/32</ip-netmask>')
            elif addresses[index]['addrObjType'] == '2':
                log('              <ip-range>' + addresses[index]['addrObjIp1'] + '-' + addresses[index][
                    'addrObjIp2'] + '</ip-range>')
            elif addresses[index]['addrObjType'] == '4':
                bitmask = sum([bin(int(x)).count("1") for x in addresses[index]['addrObjIp2'].split(".")])
                log('              <ip-netmask>' + addresses[index]['addrObjIp1'] + '/' + str(
                    bitmask) + '</ip-netmask>')
            log('              <description>' + ss(addresses[index]['addrObjIdDisp']) + '</description>')
            log('            </entry>')
            # addressfqdn_props = ['addrObjFqdnId', 'addrObjFqdnType', 'addrObjFqdnZone', 'addrObjFqdnProperties', 'addrObjFqdn']

    for index in addressesfqdn:
        log('            <entry name="' + sc(addressesfqdn[index]['addrObjFqdnId']) + '">')
        log('              <fqdn>{}</fqdn>'.format(addressesfqdn[index]['addrObjFqdn']))
        log('              <disable-override>no</disable-override>')
        log('              <description>{}</description>'.format(addressesfqdn[index]['addrObjFqdnId']))
        log('            </entry>')

    # log('            <entry name="' + 'Address_Object_Placeholder' + '">')
    # log('              <ip-netmask>' + '255.255.255.255/32</ip-netmask>')
    # log('            </entry>')

    log('          </address>')
    log('          <address-group>')
    for index in addresses:
        if addresses[index][
            'addrObjType'] == '8':  # and ( addresses[index]['addrObjProperties'] == '14' or addresses[index]['addrObjId'] in builtin_map):
            if addresses[index]['addrObjProperties'] == '14':
                tmp_addr = sc(addresses[index]['addrObjId'])
            else:
                tmp_addr = "BUILTIN_" + sc(addresses[index]['addrObjId'])
            log('            <entry name="' + tmp_addr + '">')

            if index in address_map:
                if len(address_map[index]) > 0:
                    log('              <static>')
                    for member in address_map[index]:
                        if member in addresses:
                            if addresses[member]['addrObjProperties'] != '14':  # in builtin_map:
                                log('                <member>' + "BUILTIN_" + sc(member) + '</member>')
                            else:

                                log('                <member>' + sc(member) + '</member>')
                        else:  # member is likely addressfqdn
                            log('                <member>' + sc(member) + '</member>')
                    log('              </static>')
            # else:
            #    log('<member>Address_Object_Placeholder</member>')

            log('            <description>"' + ss(addresses[index]['addrObjId']) + '"</description>')
            log('            </entry>')
    log('          </address-group>')
    return


def create_services(services, service_map):
    ## Generate service and service-group portions of Palo Alto .xml configuration
    log("          <service>")
    for index in services:
        if services[index]['svcObjIpType'] in ['6', '17']:
            log('            <entry name="' + sc(services[index]['svcObjId']) + '">')
            log('              <description>"' + ss(services[index]['svcObjId']) + '"</description>')
            log('              <protocol>')
            if services[index]['svcObjIpType'] == '6':
                log('                <tcp>')
            elif services[index]['svcObjIpType'] == '17':
                log('                <udp>')
            log('                  <port>' + services[index]['svcObjPort1'], end='')
            if services[index]['svcObjPort1'] != services[index]['svcObjPort2']:
                log('-' + services[index]['svcObjPort2'], end='')
            log('</port>')
            if services[index]['svcObjIpType'] == '6':
                log('                </tcp>')
            elif services[index]['svcObjIpType'] == '17':
                log('                </udp>')
            log('              </protocol>')
            log('            </entry>')

    log('            <entry name="' + 'Service_Object_Placeholder' + '">')
    log('              <description>"' + 'Service Object Placeholder for empty groups' + '"</description>')
    log('              <protocol>')
    log('                <tcp>')
    log('                  <port>0</port>')
    log('                </tcp>')
    log('              </protocol>')
    log('            </entry>')

    log('          </service>')

    log('          <service-group>')
    for index in services:
        if services[index]['svcObjIpType'] == '0':
            log('            <entry name="' + sc(services[index]['svcObjId']) + '">')
            log('              <members>')
            memberfound = False
            if index in service_map:
                if len(service_map[index]) > 0:
                    for member in service_map[index]:
                        if services[member]['svcObjIpType'] in ['6', '17', '0']:
                            log('                <member>' + sc(member) + '</member>')
                            memberfound = True
            if memberfound == False:
                log('<member>Service_Object_Placeholder</member>')
            log('              </members>')
            log('            </entry>')
    log('          </service-group>')

    return;


def create_network(interfaces, interface_map, zones, routes, context, zone_map):
    from urllib.parse import quote, unquote

    ## Create Network, Interface and Zone portions of Palo Alto .xml configuration

    log('      <vsys>')
    log('        <entry name=\'vsys1\'>')
    log('          <zone>')
    for zone_index in zones:
        memberfound = False
        if zones[zone_index]['zoneObjId'].lower() in zone_map:
            out_zone = zone_map[zones[zone_index]['zoneObjId'].lower()]
            # else:
            # out_zone=zones[zone_index]['zoneObjId']
            log('            <entry name="' + out_zone + '">')
            log('              <network>')
            for interface_index in interfaces:
                if interfaces[interface_index]['interface_Zone'].lower() == zones[zone_index]['zoneObjId'].lower() and \
                        zones[zone_index]['zoneObjId'] != 'MGMT' and interface_index in interface_map:
                    if memberfound == False:
                        log('                <layer3>')
                        memberfound = 1
                    log('                  <member>' + interface_map[
                        unquote(interfaces[interface_index]['iface_name'])] + '</member>')
            if memberfound == False:
                log('                <layer3/>')
            else:
                log('                </layer3>')
            log('              </network>')
            if zones[zone_index]['zoneObjId'].lower() == 'lan' and options.userid:
                log('              <enable-user-identification>yes</enable-user-identification>')
            log('            </entry>')
    log('          </zone>')
    if options.userid:
        log('          <user-id-agent>')
        log('            <entry name="Admin-UserID">')
        log('              <host>10.58.90.53</host>')
        log('              <port>5007</port>')
        log('              <ldap-proxy>yes</ldap-proxy>')
        log('              <collectorname>Admin-UserID</collectorname>')
        log('              <secret>-AQ==bsiEbjhCKN6u/kaJRdoALKqdudY=CvD+ExaF9qHBrdQejLQD7g==</secret>')
        log('            </entry>')
        log('          </user-id-agent>')
    log('          <import>')
    log('            <network>')
    log('              <interface>')
    # for zone_index in zones:
    log(interface_map)
    log(interfaces)
    for interface_index in interfaces:
        # if interfaces[interface_index]['interface_Zone'].lower() in zone_map and interface_map[interfaces[interface_index]['iface_name']] != 'MGMT' and interface_index in interface_map:
        if interfaces[interface_index]['interface_Zone'].lower() in zone_map and unquote(
                interface_index) in interface_map:
            if interface_map[unquote(interfaces[interface_index]['iface_name'])] != 'MGMT':
                log('                <member>' + interface_map[
                    unquote(interfaces[interface_index]['iface_name'])] + '</member>')
    log('              </interface>')
    log('              <virtual-router>')
    log('                <member>' + options.vrouter + '</member>')
    log('              </virtual-router>')
    log('            </network>')
    log('          </import>')
    log('        </entry>')
    log('</vsys>')

    ### Missing config elements

    log("      <network>")

    # create interface-management-profile
    # TODO Some of the networks below should be removed as they now belong to NTT

    log("        <profiles>")
    log("          <interface-management-profile>")
    log("            <entry name=\"" + customops.int_mgmt_profile + "\">")
    log("              <https>yes</https>")
    log("              <ssh>yes</ssh>")
    log("              <ping>yes</ping>")
    log("              <permitted-ip>")
    log("                <entry name=\"10.0.0.0/8\"/>")
    log("                <entry name=\"143.166.0.0/16\"/>")
    log("                <entry name=\"163.244.0.0/16\"/>")
    log("                <entry name=\"155.16.0.0/15\"/>")
    log("                <entry name=\"160.110.0.0/16\"/>")
    log("                <entry name=\"165.136.0.0/16\"/>")
    log("                <entry name=\"148.9.32.0/20\"/>")
    log("              </permitted-ip>")
    log("              <snmp>yes</snmp>")
    log("              <userid-service>yes</userid-service>")
    log("              <userid-syslog-listener-ssl>yes</userid-syslog-listener-ssl>")
    log("              <userid-syslog-listener-udp>yes</userid-syslog-listener-udp>")
    log("            </entry>")
    log("          </interface-management-profile>")
    log("        </profiles>")

    # create interfaces

    log("        <interface>")
    log("          <ethernet>")
    #  need to get interface mappings

    for interface_index in interfaces:
        if interfaces[interface_index]['iface_type'] in ['1', '6', '7'] and interfaces[interface_index][
            'interface_Zone'].lower() in zone_map and interface_index in interface_map:
            log("          <entry name=\"" + interface_map[unquote(interfaces[interface_index]['iface_name'])] + "\">")
            log("            <layer3>")
            log("              <ipv6>")
            log("                <neighbor-discovery>")
            log("                  <router-advertisement>")
            log("                    <enable>no</enable>")
            log("                  </router-advertisement>")
            log("                </neighbor-discovery>")
            log("              </ipv6>")
            ### Add lines here for VLAN subinterfaces
            subint_found = False
            import re
            for sub_interface in interfaces:
                if re.findall(interface_map[unquote(interfaces[interface_index]['iface_name'])] + "\.",
                              interface_map[unquote(interfaces[sub_interface]['iface_name'])]) and interface_map[
                    unquote(interfaces[interface_index]['iface_name'])] != interface_map[
                    unquote(interfaces[sub_interface]['iface_name'])] and sub_interface in interface_map:
                    if not subint_found:
                        log("              <untagged-sub-interface>no</untagged-sub-interface>")
                        log("              <units>")
                        subint_found = True
                    log('                <entry name="' + interface_map[
                        unquote(interfaces[sub_interface]['iface_name'])] + '">')
                    log('                  <ipv6>')
                    log('                    <neighbor-discovery>')
                    log('                      <enable-dad>no</enable-dad>')
                    log('                      <dad-attempts>1</dad-attempts>')
                    log('                      <ns-interval>1</ns-interval>')
                    log('                      <reachable-time>30</reachable-time>')
                    log('                    </neighbor-discovery>')
                    log('                    <enabled>no</enabled>')
                    log('                    <interface-id>EUI-64</interface-id>')
                    log('                  </ipv6>')
                    log('                  <ip>')
                    ip = interfaces[sub_interface]['iface_lan_ip']
                    mask = str(
                        sum([bin(int(x)).count("1") for x in interfaces[sub_interface]['iface_lan_mask'].split(".")]))

                    log('                    <entry name="' + ip + '/' + mask + '"/>')
                    log('                  </ip>')
                    log('                  <adjust-tcp-mss>')
                    log('                    <enable>no</enable>')
                    log('                    <ipv4-mss-adjustment>40</ipv4-mss-adjustment>')
                    log('                    <ipv6-mss-adjustment>60</ipv6-mss-adjustment>')
                    log('                  </adjust-tcp-mss>')
                    log('                  <tag>' + interfaces[sub_interface]['iface_vlan_tag'] + '</tag>')
                    ## CHANGEME - use customops.int_mgmt_profile if interface zone is LAN
                    if interfaces[sub_interface]['interface_Zone'] == "LAN":
                        log('                  <interface-management-profile>' + customops.int_mgmt_profile + '</interface-management-profile>')
                    else:
                        log('                  <interface-management-profile>Allow ping</interface-management-profile>')
                    log('                </entry>')
            if subint_found:
                log("              </units>")
            log("              <ndp-proxy>")
            log("                <enabled>no</enabled>")
            log("              </ndp-proxy>")
            log("              <lldp>")
            log("                <enable>no</enable>")
            log("              </lldp>")
            log("              <ip>")

            if interfaces[interface_index]['iface_type'] == '1' and interfaces[interface_index][
                'interface_Zone'].lower() in zone_map and interface_index in interface_map:
                ip = interfaces[interface_index]['iface_static_ip']
                mask = str(
                    sum([bin(int(x)).count("1") for x in interfaces[interface_index]['iface_static_mask'].split(".")]))
                log("                <entry name=\"" + ip + "/" + mask + "\"/>")
                log("              </ip>")
                if interfaces[interface_index]['interface_Zone'].lower() == "lan":
                    log("              <interface-management-profile>" + customops.int_mgmt_profile + "</interface-management-profile>")
                log("            </layer3>")
                log("          </entry>")

            if interfaces[interface_index]['iface_type'] in ['6', '7'] and interfaces[interface_index][
                'interface_Zone'].lower() in zone_map and interface_index in interface_map:
                ip = interfaces[interface_index]['iface_lan_ip']
                mask = str(
                    sum([bin(int(x)).count("1") for x in interfaces[interface_index]['iface_lan_mask'].split(".")]))
                log("                <entry name=\"" + ip + "/" + mask + "\"/>")
                log("             </ip>")
                if interfaces[interface_index]['interface_Zone'].lower() == "lan":
                    log("             <interface-management-profile>" + customops.int_mgmt_profile + "</interface-management-profile>")
                log("           </layer3>")
                log("          </entry>")
    log("          </ethernet>")
    log("        </interface>")

    ## Add virtual router

    log("        <virtual-router>")
    log("          <entry name=\"" + options.vrouter + "\">")
    log("            <routing-table>")
    log("              <ip>")
    log("                <static-route>")
    routecounter = 1

    defroute = False

    for route_index in routes:
        if routes[route_index]['pbrObjGw'] != '':
            nexthop, mask = get_address_of(config[context]['addresses'], routes[route_index]['pbrObjGw'])
            ## CHANGEME -- Use expand_address instead of address_mappings for dest, as dest can be any address type, not just a group
            if routes[route_index]['pbrObjSrc'] == '':  ## only add routes without a source specified
                if routes[route_index]['pbrObjSrc'] == '' and routes[route_index]['pbrObjDst'] == '' and \
                        routes[route_index]['pbrObjSvc'] == '':  # default route
                    log("                <entry name=\"Default Route\">")
                    log("                  <nexthop>")
                    log("                    <ip-address>" + nexthop + "</ip-address>")
                    log("                  </nexthop>")
                    log("                  <destination>0.0.0.0/0</destination>")
                    log("                </entry>")
                    defroute = True
                for dest in expand_address(config[context]['addresses'], routes[route_index]['pbrObjDst'],
                                           config[context]['addressmappings']):
                    if config[context]['addresses'][dest]['addrObjType'] in ['1', '4']:
                        address, mask = get_address_of(config[context]['addresses'], dest)
                        log("                  <entry name=\"Route " + str(routecounter) + "\">")
                        log("                    <nexthop>")
                        log("                      <ip-address>" + nexthop + "</ip-address>")
                        log("                    </nexthop>")
                        log("                    <destination>" + address + "/" + mask + "</destination>")
                        log("                  </entry>")
                        routecounter = routecounter + 1

    ## Add Default Route
    ## Is this a valid assumption?? CHANGEME
    if not defroute:
        defgateway = False
        for defgateway_index in interfaces:
            if interfaces[defgateway_index]['iface_static_gateway'] != '0.0.0.0' and interfaces[defgateway_index][
                'iface_static_gateway'] != '0.0.0.1':
                defgateway = interfaces[defgateway_index]['iface_static_gateway']

        if defgateway:
            log("                <entry name=\"Default Route\">")
            log("                  <nexthop>")
            log("                    <ip-address>" + defgateway + "</ip-address>")
            log("                  </nexthop>")
            log("                  <destination>0.0.0.0/0</destination>")
            log("                </entry>")

    log("              </static-route>")
    log("            </ip>")
    log("          </routing-table>")

    ## Add Network Interfaces to VRouter

    log("          <interface>")
    for interface_index in interfaces:
        if interfaces[interface_index]['iface_type'] in ['1', '6', '7'] and interfaces[interface_index][
            'interface_Zone'].lower() in zone_map and interface_index in interface_map:
            log("            <member>" + interface_map[
                unquote(interfaces[interface_index]['iface_name'])] + "</member>")
    log("            </interface>")
    log("          </entry>")
    log("        </virtual-router>")
    log("      </network>")

    log("      <deviceconfig>")
    log("        <system>")
    log(
        '''          <domain>''' + customops.domain + '''</domain>
          <dns-setting>
            <servers>
              <primary>''' + customops.dnsservers[0] + '''</primary>
              <secondary>''' + customops.dnsservers[1] + '''</secondary>
            </servers>
          </dns-setting>
          <secure-proxy-server>''' + customops.secureproxy['host'] + '''</secure-proxy-server>
          <secure-proxy-port>''' + customops.secureproxy['port'] + '''</secure-proxy-port>
          <timezone>''' + customops.timezone + '''</timezone>
          <ntp-servers>
            <primary-ntp-server>
              <ntp-server-address>''' + customops.ntpservers[0] + '''</ntp-server-address>
              <authentication-type>
                <none/>
              </authentication-type>
            </primary-ntp-server>
            <secondary-ntp-server>
              <ntp-server-address>''' + customops.ntpservers[1] + '''</ntp-server-address>
              <authentication-type>
                <none/>
              </authentication-type>
            </secondary-ntp-server>
          </ntp-servers>
          <update-server>''' + customops.updateserver + '''</update-server>
          <snmp-setting>
            <access-setting>
              <version>
                <v2c>
                  <snmp-community-string>''' + customops.snmpsettings['community'] + '''</snmp-community-string>
                </v2c>
              </version>
            </access-setting>
            <snmp-system>
              <contact>''' + customops.snmpsettings['contact'] + '''</contact>
              <location>''' + customops.snmpsettings['location'] + '''</location>
            </snmp-system>
          </snmp-setting>
          <login-banner>''' + customops.loginbanner + '''</login-banner>
''')
    ## Add mgmt interface ip

    for interface_index in interfaces:
        ## this needs to go somewhere else....
        if interfaces[interface_index]['iface_type'] == '12':
            ip = interfaces[interface_index]['iface_mgmt_ip']
            mask = sum([bin(int(x)).count("1") for x in interfaces[interface_index]['iface_mgmt_netmask'].split(".")])
            log("          <ip-address>" + ip + "</ip-address>")
            log("          <netmask>" + interfaces[interface_index]['iface_mgmt_netmask'] + "</netmask>")
            log("         <default-gateway>" + interfaces[interface_index][
                'iface_mgmt_default_gw'] + "</default-gateway>")

    log("        </system>")
    log("      </deviceconfig>")
    return;


def create_policies(policy_object, context, zone_map):
    ## Create Policy portion of Palo Alto .xml configuration

    count = 1;

    log('            <security>')
    log('              <rules>')
    # log(zone_map)
    for policy_index in policy_object:

        tmp_srcnet = policy_object[policy_index]['policySrcNet']
        tmp_dstnet = policy_object[policy_index]['policyDstNet']
        tmp_dstsvc = policy_object[policy_index]['policyDstSvc']
        if tmp_srcnet == [''] or tmp_srcnet == []:
            tmp_srcnet = ['any']
        if tmp_dstnet == [''] or tmp_dstnet == []:
            tmp_dstnet = ['any']
        if tmp_dstsvc == [''] or tmp_dstsvc == []:
            tmp_dstsvc = ['any']

        if policy_object[policy_index]['policyProps'] == '0' and 'MULTICAST' not in policy_object[policy_index][
            'policySrcZone'] and 'MULTICAST' not in policy_object[policy_index]['policyDstZone']:

            # if dstzone.lower() in zone_map and srczone.lower() in zone_map:
            if (list(set([x.lower() for x in policy_object[policy_index]['policySrcZone']]) & set(
                    [y.lower() for y in zone_map])) != []) and (
                    list(set([xx.lower() for xx in policy_object[policy_index]['policyDstZone']]) & set(
                            [yy.lower() for yy in zone_map])) != []):  ##m3 line
                # if list(set([x.lower() for x in policy_object[policy_index]['policySrcZone']]) & set([y.lower() for y in zone_map])) != [] and list(set([xx.lower() for xx in policy_object[policy_index]['policyDstZone']])  & set([yy.lower() for yy in zone_map])) != []:
                log('                <entry name="' + customops.base_rule_name + '%04d' % count + '_' + sc(
                    tmp_dstsvc[0]) + '">')
                log('                  <target>')
                log('                    <negate>no</negate>')
                log('                  </target>')
                log('                  <to>')
                for dstzone in policy_object[policy_index]['policyDstZone']:
                    if dstzone.lower() in zone_map:
                        out_zone = zone_map[dstzone.lower()]
                    else:
                        out_zone = dstzone

                    log('                    <member>' + out_zone + '</member>')
                log('                  </to>')
                log('                  <from>')
                for srczone in policy_object[policy_index]['policySrcZone']:
                    if srczone.lower() in zone_map:
                        out_zone = zone_map[srczone.lower()]
                    else:
                        out_zone = srczone
                    log('                    <member>' + out_zone + '</member>')
                log('                  </from>')
                log('                  <source>')
                for srcnet in tmp_srcnet:
                    if srcnet.lower() == 'any':
                        tmp_src = srcnet
                    elif srcnet in config[context]['addresses']:
                        if config[context]['addresses'][srcnet]['addrObjProperties'] == '14':
                            tmp_src = srcnet
                        else:
                            tmp_src = "BUILTIN_" + sc(srcnet)
                    elif srcnet in config[context]['addressesfqdn']:
                        tmp_src = srcnet
                    log('                    <member>' + sc(tmp_src) + '</member>')
                log('                  </source>')
                log('                  <destination>')
                for dstnet in tmp_dstnet:
                    if dstnet.lower() == 'any':
                        tmp_dst = dstnet
                    elif dstnet in config[context]['addresses']:
                        if config[context]['addresses'][dstnet]['addrObjProperties'] == '14':
                            tmp_dst = dstnet
                        else:
                            tmp_dst = "BUILTIN_" + sc(dstnet)
                    elif dstnet in config[context]['addressesfqdn']:
                        tmp_dst = dstnet
                    log('                    <member>' + sc(tmp_dst) + '</member>')
                log('                  </destination>')
                log('                            <source-user>')
                log('                    <member>any</member>')
                log('                  </source-user>')
                log('                  <category>')
                log('                    <member>any</member>')
                log('                  </category>')
                log('                  <application>')
                log('                    <member>any</member>')
                log('                  </application>')
                log('                 <service>')
                for dstsvc in tmp_dstsvc:
                    log('                    <member>' + sc(dstsvc) + '</member>')
                log('                  </service>')
                log('                  <hip-profiles>')
                log('                    <member>any</member>')
                log('                  </hip-profiles>')
                log('                  <description>' + ss(policy_object[policy_index]['policyComment']))
                log('')
                if policy_object[policy_index]['policySrcZone'][0].lower() in zone_map:
                    out_srczone = zone_map[policy_object[policy_index]['policySrcZone'][0].lower()]
                else:
                    out_srczone = policy_object[policy_index]['policySrcZone'][0]
                if policy_object[policy_index]['policyDstZone'][0].lower() in zone_map:
                    out_dstzone = zone_map[policy_object[policy_index]['policyDstZone'][0].lower()]
                else:
                    out_dstzone = policy_object[policy_index]['policyDstZone'][0]
                log(out_srczone + '__' + out_dstzone + '__' + sc(tmp_srcnet[0]) + '__' + sc(tmp_dstnet[0]) + '__' + sc(
                    tmp_dstsvc[0]))
                log('                  </description>')
                if policy_object[policy_index]['policyAction'] == '0':
                    log('                  <action>deny</action>')
                if policy_object[policy_index]['policyAction'] == '1':
                    log('                  <action>drop</action>')
                if policy_object[policy_index]['policyAction'] == '2':
                    log('                  <action>allow</action>')
                if policy_object[policy_index]['policyEnabled'] != '1':
                    log('<disabled>yes</disabled>')
                log('                  <log-setting>' + customops.log_forward_profile_name + '</log-setting>')
                log('                  <profile-setting>')
                log('                    <group>')
                log('                      <member>' + customops.rule_profile_setting + '</member>')
                log('                    </group>')
                log('                  </profile-setting>')
                log('                </entry>')

        # Get a list of ICMP services used in this rule
        icmp_ports = []
        for dstsvc in tmp_dstsvc:
            for svc in expand_service(config[context]['services'], dstsvc, config[context]['servicemappings'],
                                      inc_group=False):
                if str.lower(get_prot_of(config[context]['services'], svc)) == 'icmp':
                    icmp_ports.append(get_port_of(config[context]['services'], svc))

        # If ICMP is defined in this rule, add a new icmp rule using application

        if icmp_ports != []:
            if policy_object[policy_index]['policyProps'] == '0' and 'MULTICAST' not in policy_object[policy_index][
                'policySrcZone'] and 'MULTICAST' not in policy_object[policy_index]['policyDstZone']:
                if list(set([x.lower() for x in policy_object[policy_index]['policySrcZone']]) & set(
                        [y.lower() for y in zone_map])) != [] and list(
                        set([xx.lower() for xx in policy_object[policy_index]['policyDstZone']]) & set(
                                [yy.lower() for yy in zone_map])) != []:
                    log('                <entry name="' + customops.base_rule_name + '%04d-icmp">' % count)
                    log('                  <target>')
                    log('                    <negate>no</negate>')
                    log('                  </target>')
                    log('                  <to>')
                    for dstzone in policy_object[policy_index]['policyDstZone']:
                        if dstzone.lower() in zone_map:
                            out_zone = zone_map[dstzone.lower()]
                        else:
                            out_zone = dstzone
                        log('                    <member>' + out_zone + '</member>')
                    log('                  </to>')
                    log('                  <from>')
                    for srczone in policy_object[policy_index]['policySrcZone']:
                        if srczone.lower() in zone_map:
                            out_zone = zone_map[srczone.lower()]
                        else:
                            out_zone = srczone
                        log('                    <member>' + out_zone + '</member>')
                    log('                  </from>')
                    log('                  <source>')
                    for srcnet in tmp_srcnet:
                        log('                    <member>' + sc(srcnet) + '</member>')
                    log('                  </source>')
                    log('                  <destination>')
                    for dstnet in tmp_dstnet:
                        log('                    <member>' + sc(dstnet) + '</member>')
                    log('                  </destination>')
                    log('                            <source-user>')
                    log('                    <member>any</member>')
                    log('                  </source-user>')
                    log('                  <category>')
                    log('                    <member>any</member>')
                    log('                  </category>')

                    log('                  <application>')
                    '''if sorted(icmp_ports) == ['0','8']:
                        icmp_svc = 'ping'
                    else:
                        icmp_svc = 'icmp'
                    log('                    <member>' + icmp_svc + '</member>')
                    '''
                    log('                    <member>' + 'ping' + '</member>')
                    log('                    <member>' + 'icmp' + '</member>')
                    log('                    <member>' + 'traceroute' + '</member>')

                    log('                  </application>')
                    log('                 <service>')
                    log('                    <member>application-default</member>')
                    log('                  </service>')
                    log('                  <hip-profiles>')
                    log('                    <member>any</member>')
                    log('                  </hip-profiles>')
                    log('                  <description>' + ss(policy_object[policy_index]['policyComment']))
                    log('')
                    if policy_object[policy_index]['policySrcZone'][0].lower() in zone_map:
                        out_srczone = zone_map[policy_object[policy_index]['policySrcZone'][0].lower()]
                    else:
                        out_srczone = policy_object[policy_index]['policySrcZone'][0]
                    if policy_object[policy_index]['policyDstZone'][0].lower() in zone_map:
                        out_dstzone = zone_map[policy_object[policy_index]['policyDstZone'][0].lower()]
                    else:
                        out_dstzone = policy_object[policy_index]['policyDstZone'][0]
                    log(out_srczone + '__' + out_dstzone + '__' + sc(tmp_srcnet[0]) + '__' + sc(
                        tmp_dstnet[0]) + '__' + sc(tmp_dstsvc[0]))
                    log('                  </description>')
                    if policy_object[policy_index]['policyAction'] == '0':
                        log('                  <action>deny</action>')
                    if policy_object[policy_index]['policyAction'] == '1':
                        log('                  <action>drop</action>')
                    if policy_object[policy_index]['policyAction'] == '2':
                        log('                  <action>allow</action>')
                    if policy_object[policy_index]['policyEnabled'] != '1':
                        log('<disabled>yes</disabled>')
                    log('                  <log-setting>' + customops.log_forward_profile_name + '</log-setting>')
                    log('                  <profile-setting>')
                    log('                    <group>')
                    log('                      <member>' + customops.rule_profile_setting + '</member>')
                    log('                    </group>')
                    log('                  </profile-setting>')
                    log('                </entry>')

        if 'MULTICAST' not in policy_object[policy_index]['policySrcZone'] and 'MULTICAST' not in \
                policy_object[policy_index]['policyDstZone']:
            count = count + 1
    log('              </rules>')
    log('            </security>')

    return


def create_nat(nat_policies, context, zone_map, interface_map, interfaces, builtin_map):
    import json
    import urllib
    from urllib.parse import unquote, quote

    ## currently only handles source NAT (and bidirectionals)
    ## Interface objects do not appear to be in the output xml file, some built in types may not be converted
    ## Object names in groups not expanded as expected
    ##

    # nat_props = [ 'natPolicyOrigSrc', 'natPolicyOrigDst', 'natPolicyOrigSvc', 'natPolicyTransSrc', 'natPolicyTransDst', 'natPolicyTransSvc', 'natPolicySrcIface', 'natPolicyDstIface', 'natPolicyEnabled', 'natPolicyComment', 'natPolicyProperties', 'natPolicyName' ]

    ## if source if a "default"/built-in address GROUP, the code below does not handle this properly.
    ## change orig/trans src/dest to lists

    policynum = 1
    intnums = {}
    added_policies = []
    for interface in interfaces:
        intnums[interfaces[interface]['iface_ifnum']] = interface
    log('            <nat>')
    log('              <rules>')

    for policy in nat_policies:
        if nat_policies[policy]['natPolicyProperties'] not in ['1023', '17407']:  # skip default NAT rules

            src_zones = ['any']
            dst_zones = ['any']
            trans_source = ''

            if nat_policies[policy]['natPolicySrcIface'] == '-1':
                src_zones = ['any']
                src_int = 'any'
            else:
                if interfaces[nat_policies[policy]['natPolicySrcIface']]['interface_Zone'] in zone_map:
                    src_zones = [zone_map[interfaces[nat_policies[policy]['natPolicySrcIface']]['interface_Zone']]]
                else:
                    src_zones = [interfaces[nat_policies[policy]['natPolicySrcIface']]['interface_Zone']]

            if nat_policies[policy]['natPolicyDstIface'] == '-1':
                dst_zones = ['any']
                dst_int = 'any'
            else:
                if interfaces[nat_policies[policy]['natPolicyDstIface']]['interface_Zone'] in zone_map:
                    dst_zones = [zone_map[interfaces[nat_policies[policy]['natPolicyDstIface']]['interface_Zone']]]
                else:
                    dst_zones = [interfaces[nat_policies[policy]['natPolicyDstIface']]['interface_Zone']]
                if interfaces[nat_policies[policy]['natPolicyDstIface']]['iface_name'] in interface_map:
                    dst_int = interface_map[
                        unquote(interfaces[nat_policies[policy]['natPolicyDstIface']]['iface_name'])]
                else:
                    dst_int = 'Error'
                    debug(nat_policies[policy]['natPolicyDstIface'])
                    debug(interface_map)

            if nat_policies[policy]['natPolicyOrigSrc'][0] == '':
                orig_source = ['any']
            else:
                if config[context]['addresses'][nat_policies[policy]['natPolicyOrigSrc'][0]][
                    'addrObjProperties'] != '14':
                    orig_source = ["BUILTIN_" + sc(nat_policies[policy]['natPolicyOrigSrc'][0])]  ## placeholder
                else:
                    orig_source = [nat_policies[policy]['natPolicyOrigSrc'][0]]

            if nat_policies[policy]['natPolicyTransSrc'][0] != '':
                if config[context]['addresses'][nat_policies[policy]['natPolicyTransSrc'][0]][
                    'addrObjProperties'] != '14':
                    '''
                    trans_source=config[context]['addresses'][nat_policies[policy]['natPolicyTransSrc'][0]]['addrObjIp1']+'/'+ str(netmask_to_cidr(config[context]['addresses'][nat_policies[policy]['natPolicyTransSrc'][0]]['addrObjIp2']))
                    trans_source='NAT_TransSrc_{}'.format(int(policy+1))
                    '''
                    trans_source = "BUILTIN_" + sc(nat_policies[policy]['natPolicyTransSrc'][0])  ## placeholder
                else:
                    trans_source = nat_policies[policy]['natPolicyTransSrc'][0]

            if nat_policies[policy]['natPolicyOrigDst'][0] == '':
                orig_dest = ['any']
            else:
                if config[context]['addresses'][nat_policies[policy]['natPolicyOrigDst'][0]][
                    'addrObjProperties'] != '14':
                    '''orig_dest=[config[context]['addresses'][nat_policies[policy]['natPolicyOrigDst'][0]]['addrObjIp1']+'/'+ str(netmask_to_cidr(config[context]['addresses'][nat_policies[policy]['natPolicyOrigDst'][0]]['addrObjIp2']))]
                    orig_dest=['NAT_OrigDst_{}'.format(int(policy+1))]
                    '''
                    orig_dest = ["BUILTIN_" + sc(nat_policies[policy]['natPolicyOrigDst'][0])]  ## placeholder
                else:
                    orig_dest = [nat_policies[policy]['natPolicyOrigDst'][0]]
            # log(orig_dest)
            # log(zone_map)
            # log(context)
            # log(config[context]['addresses'][orig_dest[0]]['addrObjType'])
            # log(config[context]['addresses'][orig_dest[0]])
            # log(config[context]['addresses'][orig_dest[0]]['IPSet'])
            if dst_zones == ['any']:
                # dst_zones=zone_map[get_zones(context, str(config[context]['addresses'][orig_dest[0]]['IPSet'].iter_cidrs()[0][0])).lower()]
                tmp_dst_zones = get_zones(context, orig_dest[0])
                dst_zones = []
                for zone in tmp_dst_zones:
                    if zone in zone_map:
                        dst_zones.append(zone_map[zone])
                    else:
                        dst_zones.append(zone)

            # if src_zones==['any']:
            #    #src_zones=zone_map[get_zones(context, str(config[context]['addresses'][orig_source[0]]['IPSet'].iter_cidrs()[0][0])).lower()]
            #    src_zones=get_zones(context, orig_source[0])
            # log('DSTZONE: ', dst_zones)
            if nat_policies[policy]['natPolicyTransDst'][0] != '':
                if config[context]['addresses'][nat_policies[policy]['natPolicyTransDst'][0]][
                    'addrObjProperties'] != '14':
                    '''trans_dest=config[context]['addresses'][nat_policies[policy]['natPolicyTransDst'][0]]['addrObjIp1']+'/'+ str(netmask_to_cidr(config[context]['addresses'][nat_policies[policy]['natPolicyTransDst'][0]]['addrObjIp2']))
                    trans_dest='NAT_TransDst_{}'.format(int(policy+1))
                    '''
                    trans_dest = "BUILTIN_" + sc(nat_policies[policy]['natPolicyTransDst'][0])  ## placeholder
                else:
                    trans_dest = nat_policies[policy]['natPolicyTransDst'][0]

            # log('"{}" "{}" "{}"'.format('translated', nat_policies[policy]['natPolicyTransSrc'][0], trans_source))
            if nat_policies[policy]['natPolicyOrigSvc'][0] == '':
                orig_svc = 'any'
            else:
                orig_svc = nat_policies[policy]['natPolicyOrigSvc'][0]
            bidirectional = 'no'
            for tmp_policy in nat_policies:
                if tmp_policy != policy:
                    if (nat_policies[policy]['natPolicyOrigSrc'], nat_policies[policy]['natPolicyTransSrc'],
                        nat_policies[policy]['natPolicyOrigDst'], nat_policies[policy]['natPolicyTransDst'],
                        nat_policies[policy]['natPolicyOrigSvc'], nat_policies[policy]['natPolicyTransSvc']) == (
                    nat_policies[tmp_policy]['natPolicyTransDst'], nat_policies[tmp_policy]['natPolicyOrigDst'],
                    nat_policies[tmp_policy]['natPolicyOrigSrc'], nat_policies[tmp_policy]['natPolicyTransSrc'],
                    nat_policies[tmp_policy]['natPolicyOrigSvc'], nat_policies[tmp_policy]['natPolicyTransSvc']):
                        # (nat_policies[tmp_policy]['natPolicyTransDst'], nat_policies[tmp_policy]['natPolicyOrigDst'], nat_policies[tmp_policy]['natPolicyTransSrc'], nat_policies[tmp_policy]['natPolicyOrigSrc'], nat_policies[tmp_policy]['natPolicyOrigSvc'], nat_policies[tmp_policy]['natPolicyTransSvc']):
                        bidirectional = 'yes'
                    elif (nat_policies[policy]['natPolicyTransDst'], nat_policies[policy]['natPolicyOrigDst'],
                          nat_policies[policy]['natPolicyOrigSrc'], nat_policies[policy]['natPolicyTransSrc'],
                          nat_policies[policy]['natPolicyOrigSvc'],
                          nat_policies[policy]['natPolicyTransSvc']) in added_policies:
                        bidirectional = 'done'
            # debug(policynum, bidirectional)
            if bidirectional != 'done':
                # debug('Using translated source: {}'.format(trans_source))
                for dst_zone in dst_zones:
                    for src_zone in src_zones:
                        log('                  <entry name="Imported NAT Policy {}-{}">'.format(policynum, dst_zone))

                        if nat_policies[policy]['natPolicyTransSrc'][0] != '':
                            log('                    <source-translation>')
                            log('                      <static-ip>')
                            log('                       <translated-address>{}</translated-address>'.format(
                                sc(trans_source)))
                            log('                      <bi-directional>{}</bi-directional>'.format(bidirectional))
                            log('                     </static-ip>')
                            log('                   </source-translation>')
                        if nat_policies[policy]['natPolicyTransDst'][0] != '':
                            log('                    <destination-translation>')
                            log('                       <translated-address>{}</translated-address>'.format(
                                sc(trans_dest)))
                            log('                   </destination-translation>')
                        log('                    <target>')
                        log('                      <negate>no</negate>')
                        log('                    </target>')
                        log('                    <to>')
                        log('                      <member>{}</member>'.format(urllib.parse.unquote(dst_zone)))
                        log('                    </to>')
                        log('                    <from>')
                        log('                      <member>{}</member>'.format(urllib.parse.unquote(src_zone)))
                        log('                    </from>')
                        log('                    <source>')
                        for source in orig_source:
                            log('                      <member>{}</member>'.format(sc(source)))
                        log('                    </source>')
                        log('                    <destination>')
                        for dest in orig_dest:
                            log('                      <member>{}</member>'.format(sc(dest)))
                        log('                    </destination>')
                        log('                    <service>{}</service>'.format(urllib.parse.unquote(orig_svc)))
                        log('                    <nat-type>ipv4</nat-type>')
                        if nat_policies[policy]['natPolicyEnabled'] == '0':
                            log('                    <disabled>yes</disabled>')
                        # log(policynum, nat_policies[policy]['natPolicyProperties'], nat_policies[policy]['natPolicyEnabled'])
                        log('                    <description>{}</description>'.format(
                            urllib.parse.unquote(nat_policies[policy]['natPolicyComment'])))
                        log('                    <to-interface>{}</to-interface>'.format(dst_int))

                        log('                  </entry>')
                added_policies.append((nat_policies[policy]['natPolicyOrigSrc'],
                                       nat_policies[policy]['natPolicyTransSrc'],
                                       nat_policies[policy]['natPolicyOrigDst'],
                                       nat_policies[policy]['natPolicyTransDst'],
                                       nat_policies[policy]['natPolicyOrigSvc'],
                                       nat_policies[policy]['natPolicyTransSvc']))
        policynum += 1

        # log('                </entry>')
    log('              </rules>')
    log('            </nat>')

    return


def expand_address(address_dict, address_object, address_map, inc_group=False):
    ## Takes an address group object (by name) and expands it into a list of all of its individual address objects

    expanded_addresses = []
    if address_object in address_dict:
        if 'addrObjType' in address_dict[address_object]:
            if address_dict[address_object]['addrObjType'] != '8':
                expanded_addresses.append(address_object)
            else:
                if inc_group:
                    expanded_addresses.append(address_object)
                if address_object in address_map:
                    # for group_members in address_map[address_dict[address_object]['addrObjId']]:
                    for group_members in address_map[address_object]:
                        for group_member in expand_address(address_dict, group_members, address_map, inc_group):
                            expanded_addresses.append(group_member)
    elif 'addresses' in config['shared']:
        if address_object in config['shared']['addresses']:
            if 'addrObjType' in config['shared']['addresses'][address_object]:
                if config['shared']['addresses'][address_object]['addrObjType'] != '8':
                    expanded_addresses.append(address_object)
                else:
                    if inc_group:
                        expanded_addresses.append(address_object)
                    if address_object in address_map:
                        for group_members in config['shared']['addressesmappings'][
                            config['shared']['addresses'][address_object]['addrObjId']]:
                            for group_member in expand_address(config['shared']['addresses'], group_members,
                                                               config['shared']['addressesmappings'], inc_group):
                                expanded_addresses.append(group_member)

    return expanded_addresses;


def expand_service(service_dict, service_object, service_map, inc_group=False):
    ## Takes a service group object (by name) and expands it into a list of all of its individual service objects

    expanded_services = []
    if service_object.lower() in [name.lower() for name in service_dict]:  # do case insensitive match
        if service_object in service_dict:
            if service_dict[service_object]['svcObjIpType'] != '0':
                expanded_services.append(service_object)
            else:
                if inc_group:
                    expanded_services.append(service_object)
                if service_object in service_map:
                    for member in service_map[service_dict[service_object]['svcObjId']]:
                        for members in expand_service(service_dict, member, service_map, inc_group):
                            expanded_services.append(members)
        elif service_object in config['shared']['services']:
            if config['shared']['services'][service_object]['svcObjIpType'] != '0':
                expanded_services.append(service_object)
            else:
                if inc_group:
                    expanded_services.append(service_object)
                if service_object in config['shared']['servicemappings']:
                    for member in config['shared']['servicemappings'][
                        config['shared']['services'][service_object]['svcObjId']]:
                        for members in expand_service(config['shared']['services'], member,
                                                      config['shared']['servicemappings'], inc_group):
                            expanded_services.append(members)
    return expanded_services;


def build_tree(mappings, children, parent=None, tree=Tree()):
    ## Given an address or service object name, this will build a tree from this object to the groups it is a member of.
    ## The root of the tree is a member object, not the parent object, so it builds the tree opposite of what might be expected.

    for child in [children]:
        tree.add_node(child, parent)

    # Get list of children (
    for child in [children]:
        for group in mappings:
            if child in mappings[group]:
                tree = build_tree(mappings, group, child, tree)
    return tree;


def get_zones(context, address_obj, config):
    zones = []

    for address in expand_address(config[context]['addresses'], address_obj, config[context][
        'addressmappings']):  # expand_address(config[context]['addresses'], route_dest, config[context]['addressmappings']):
        for network in config[context]['addresses'][address]['IPv4Networks']:
            # log(network)
            # log(network[0])
            debug(context)
            tmp_zone = get_zone(context, '{}'.format(network[0]), config)
            if tmp_zone not in zones:
                zones.append(tmp_zone)
    return zones


def get_zones2(context, address_obj, tmpconfig=None):
    zones = []
    if tmpconfig:
        config = tmpconfig
    for address in expand_address(config[context]['addresses'], address_obj, config[context][
        'addressmappings']):  # expand_address(config[context]['addresses'], route_dest, config[context]['addressmappings']):
        for network in config[context]['addresses'][address]['IPv4Networks']:
            # log(network)
            # log('NETWORK',network)
            tmp_zones = get_zone2(context, '{}'.format(network), config)
            # log(tmp_zones)
            for tmp_zone in tmp_zones:
                if tmp_zone not in zones:
                    zones.append(tmp_zone)
    return zones


def get_zone_old(context, ip):
    import netaddr
    import urllib

    #    dest_ip='132.5.6.9'
    #    dest_ips=['10.25.116.3', '10.7.200.1']
    #    for dest_ip in dest_ips:
    #        print('-' *100)

    #        for context in contexts:
    debug('Searching {} for address : {}'.format(context, ip))
    debug('-' * 100)
    #        for item in config[context]:
    #            print(item)
    if 'routing' in config[context]:
        matchlen = -1
        for interface in config[context]['interfaces']:
            if config[context]['interfaces'][interface]['iface_lan_ip'] != '0.0.0.0':
                if ip in netaddr.IPNetwork('{}/{}'.format(config[context]['interfaces'][interface]['iface_lan_ip'],
                                                          netmask_to_cidr(config[context]['interfaces'][interface][
                                                                              'iface_lan_mask']))):
                    debug('matches lan', config[context]['interfaces'][interface]['interface_Zone'])
                    return config[context]['interfaces'][interface]['interface_Zone']
            if config[context]['interfaces'][interface]['iface_static_ip'] != '0.0.0.0':
                if ip in netaddr.IPNetwork('{}/{}'.format(config[context]['interfaces'][interface]['iface_static_ip'],
                                                          netmask_to_cidr(config[context]['interfaces'][interface][
                                                                              'iface_static_mask']))):
                    debug('matches static', config[context]['interfaces'][interface]['interface_Zone'])
                    return config[context]['interfaces'][interface]['interface_Zone']
            if config[context]['interfaces'][interface]['iface_mgmt_ip'] != '0.0.0.0':
                if ip in netaddr.IPNetwork('{}/{}'.format(config[context]['interfaces'][interface]['iface_mgmt_ip'],
                                                          netmask_to_cidr(config[context]['interfaces'][interface][
                                                                              'iface_mgmt_netmask']))):
                    debug('matches mgmt', config[context]['interfaces'][interface]['interface_Zone'])
                    return config[context]['interfaces'][interface]['interface_Zone']
        for route in config[context]['routing']:
            route_dest = config[context]['routing'][route]['pbrObjDst']
            if route_dest == '':
                route_dest = '0.0.0.0'
            debug(route_dest)
            if route_dest in config[context]['addresses']:
                # print(config[context]['addresses'][route_dest])
                debug(config[context]['addresses'][route_dest]['addrObjType'])
                if config[context]['addresses'][route_dest]['addrObjType'] == '8':
                    debug(config[context]['addresses'][route_dest])
                    debug('Route Destination is a group, checking each member object')
                    for route_dest_addr in expand_address(config[context]['addresses'], route_dest,
                                                          config[context]['addressmappings']):
                        if route_dest_addr in config[context]['addresses']:
                            debug(route_dest_addr)
                            # print(ip)
                            if netaddr.IPAddress(ip) in netaddr.IPNetwork(
                                    '{}/{}'.format(config[context]['addresses'][route_dest_addr]['addrObjIp1'],
                                                   config[context]['addresses'][route_dest_addr]['addrObjIp2'])):
                                # if netaddr.IPAddress(ip) in netaddr.IPNetwork('{}/{}'.format(config[config[context]['addresses']['addrObjIp1'], netmask_to_cidr(config[context]['interfaces'][interface]['iface_lan_mask']))):
                                # config[context]['addresses'][route_dest_addr]['IPSet']:
                                debug('Searched address found in destination group: "{}"'.format(
                                    urllib.parse.unquote(route_dest)))
                                if netmask_to_cidr(
                                        config[context]['addresses'][route_dest_addr]['addrObjIp2']) > matchlen:
                                    matchlen = netmask_to_cidr(
                                        config[context]['addresses'][route_dest_addr]['addrObjIp2'])
                                    next_hop = config[context]['routing'][route]['pbrObjGw']
                                    next_hop_int = config[context]['routing'][route]['pbrObjIface']
                                    if next_hop in config[context]['addresses']:
                                        next_hop_ip = config[context]['addresses'][next_hop]['addrObjIp1']
                                    else:
                                        next_hop_ip = next_hop
                                else:
                                    debug('Skipping - not longest match')
                        else:
                            debug('Address group not found in context')
                else:
                    # if 'IPSet' in config[context]['addresses'][route_dest]:
                    if netaddr.IPAddress(ip) in netaddr.IPNetwork(
                            '{}/{}'.format(config[context]['addresses'][route_dest]['addrObjIp1'],
                                           config[context]['addresses'][route_dest]['addrObjIp2'])):
                        # if ip in config[context]['addresses'][route_dest]['IPSet']:
                        debug('Searched address found in destination address')
                        if netmask_to_cidr(config[context]['addresses'][route_dest]['addrObjIp2']) > matchlen:
                            matchlen = netmask_to_cidr(config[context]['addresses'][route_dest]['addrObjIp2'])
                            next_hop = config[context]['routing'][route]['pbrObjGw']
                            next_hop_int = config[context]['routing'][route]['pbrObjIface']
                            if next_hop in config[context]['addresses']:
                                next_hop_ip = config[context]['addresses'][next_hop]['addrObjIp1']
                            else:
                                next_hop_ip = next_hop
                        else:
                            debug('Skipping - not longest match')
                    # else:
                    #    log('WARNING - Route destinations with Range objects not yet supported - need to add IPSet property to Range address objects - {}-{}'.format(config[context]['addresses'][route_dest]['addrObjIp1'], config[context]['addresses'][route_dest]['addrObjIp2']))
                    # print(next_hop)
                    # print(next_hop_ip)
            elif len(route_dest.split('/')) == 2:
                debug('Route destination is not in address objects')
                try:
                    if netaddr.IPAddress(ip) in netaddr.IPNetwork(route_dest):
                        network, mask = route_dest.split('/')
                        if int(mask) >= matchlen:
                            debug('MATCH1', network, mask, config[context]['routing'][route]['pbrObjGw'])
                            matchlen = int(mask)
                            next_hop = config[context]['routing'][route]['pbrObjGw']
                            next_hop_int = config[context]['routing'][route]['pbrObjIface']
                        if next_hop in config[context]['addresses']:
                            next_hop_ip = config[context]['addresses'][next_hop]['addrObjIp1']
                        else:
                            next_hop_ip = next_hop
                except Exception as e:
                    log(e)
                    log('Route destination not in network/mask format')
            elif route_dest == '0.0.0.0':  # route is a default route
                matchlen = 0
                next_hop = config[context]['routing'][route]['pbrObjGw']
                if next_hop in config[context]['addresses']:
                    next_hop_ip = config[context]['addresses'][next_hop]['addrObjIp1']
                else:
                    next_hop_ip = next_hop
                debug('Default Route!')

            # print(config[context]['interfaces'])
        debug('Matchlen', matchlen)
        if matchlen != -1:
            debug('NEXTHOP', next_hop_ip)
            for interface in config[context]['interfaces']:
                if config[context]['interfaces'][interface]['iface_name'] == next_hop_int and \
                        config[context]['interfaces'][interface]['interface_Zone'] != "":
                    return config[context]['interfaces'][interface]['interface_Zone']
                if config[context]['interfaces'][interface]['iface_lan_ip'] != '0.0.0.0':
                    if netaddr.IPAddress(next_hop_ip) in netaddr.IPNetwork(
                            '{}/{}'.format(config[context]['interfaces'][interface]['iface_lan_ip'], netmask_to_cidr(
                                    config[context]['interfaces'][interface]['iface_lan_mask']))):
                        # print('{} - {}/{}'.format(config[context]['interfaces'][interface]['iface_name'],config[context]['interfaces'][interface]['iface_lan_ip'],config[context]['interfaces'][interface]['iface_lan_mask']))
                        # print('ROUTE MATCH - Searched address {} is in Zone : {} Interface Name: {} Interface Address {}/{}'.format(ip, config[context]['interfaces'][interface]['interface_Zone'], config[context]['interfaces'][interface]['iface_name'], config[context]['interfaces'][interface]['iface_lan_ip'],netmask_to_cidr(config[context]['interfaces'][interface]['iface_lan_mask'])))
                        return config[context]['interfaces'][interface]['interface_Zone']
                elif config[context]['interfaces'][interface]['iface_static_ip'] != '0.0.0.0':
                    if netaddr.IPAddress(next_hop_ip) in netaddr.IPNetwork(
                            '{}/{}'.format(config[context]['interfaces'][interface]['iface_static_ip'], netmask_to_cidr(
                                config[context]['interfaces'][interface]['iface_static_mask']))):
                        ##print('{} - {}/{}'.format(config[context]['interfaces'][interface]['iface_name'],config[context]['interfaces'][interface]['iface_static_ip'],config[context]['interfaces'][interface]['iface_static_mask']))
                        # print('ROUTE MATCH - Searched address {} is in Zone : {} Interface Name: {} Interface Address {}/{}'.format(ip, config[context]['interfaces'][interface]['interface_Zone'], config[context]['interfaces'][interface]['iface_name'], config[context]['interfaces'][interface]['iface_static_ip'],netmask_to_cidr(config[context]['interfaces'][interface]['iface_static_mask'])))
                        return config[context]['interfaces'][interface]['interface_Zone']
                elif config[context]['interfaces'][interface]['iface_mgmt_ip'] != '0.0.0.0':
                    if netaddr.IPAddress(next_hop_ip) in netaddr.IPNetwork(
                            '{}/{}'.format(config[context]['interfaces'][interface]['iface_mgmt_ip'], netmask_to_cidr(
                                    config[context]['interfaces'][interface]['iface_mgmt_netmask']))):
                        # print('{} - {}/{}'.format(config[context]['interfaces'][interface]['iface_name'],config[context]['interfaces'][interface]['iface_mgmt_ip'],config[context]['interfaces'][interface]['iface_mgmt_netmask']))
                        # print('ROUTE MATCH - Searched address {} is in Zone : {} Interface Name: {} Interface Address {}/{}'.format(ip, config[context]['interfaces'][interface]['interface_Zone'], config[context]['interfaces'][interface]['iface_name'], config[context]['interfaces'][interface]['iface_mgmt_ip'],netmask_to_cidr(config[context]['interfaces'][interface]['iface_mgmt_netmask'])))
                        return config[context]['interfaces'][interface]['interface_Zone']
                else:  # as a last resort, try getting static gateway from interface config -- these are auto added rules and not part of the pbr config
                    log('Trying to see if ip is on same net as interface')
                    for interface in config[context]['interfaces']:
                        if config[context]['interfaces'][interface]['iface_lan_ip'] != '0.0.0.0':
                            if ip in netaddr.IPNetwork(
                                    '{}/{}'.format(config[context]['interfaces'][interface]['iface_lan_ip'],
                                                   netmask_to_cidr(config[context]['interfaces'][interface][
                                                                       'iface_lan_mask']))):
                                return config[context]['interfaces'][interface]['interface_Zone']

                    return None
        else:  # check if ip address is on same subnet as interfaces - lan_ip should likely be done before checking pbr, static_ip should likely be done after
            # log('Trying to see if ip is on same net as interface')
            for interface in config[context]['interfaces']:
                if config[context]['interfaces'][interface]['iface_lan_ip'] != '0.0.0.0':
                    if ip in netaddr.IPNetwork('{}/{}'.format(config[context]['interfaces'][interface]['iface_lan_ip'],
                                                              netmask_to_cidr(config[context]['interfaces'][interface][
                                                                                  'iface_lan_mask']))):
                        return config[context]['interfaces'][interface]['interface_Zone']
            for interface in config[context]['interfaces']:
                if config[context]['interfaces'][interface]['iface_static_ip'] != '0.0.0.0':
                    # if ip in netaddr.IPNetwork('{}/{}'.format(config[context]['interfaces'][interface]['iface_static_ip'],netmask_to_cidr(config[context]['interfaces'][interface]['iface_static_mask']))):
                    return config[context]['interfaces'][interface]['interface_Zone']
    else:
        log('Routing not in config')
    return None


def get_zone(context, ip, config):
    import netaddr
    import urllib

    try:
        ip = ip.split('/')[0]
        log_info('Searching {} for address : {}'.format(context, ip))
        log_info('-' * 100)
        #        for item in config[context]:
        #            print(item)
        if 'routing' in config[context]:
            log_info('routing found in config')
            matchlen = -1

            for interface in config[context]['interfaces']:
                log_info('interface', interface)
                if config[context]['interfaces'][interface]['iface_lan_ip'] != '0.0.0.0':
                    if ip in netaddr.IPNetwork('{}/{}'.format(config[context]['interfaces'][interface]['iface_lan_ip'],
                                                              netmask_to_cidr(config[context]['interfaces'][interface][
                                                                                  'iface_lan_mask']))):
                        debug('matches lan', config[context]['interfaces'][interface]['interface_Zone'])
                        return config[context]['interfaces'][interface]['interface_Zone']
                if config[context]['interfaces'][interface]['iface_static_ip'] != '0.0.0.0':
                    # log(config[context]['interfaces'][interface]['iface_static_ip'])
                    debug(ip)
                    if ip in netaddr.IPNetwork(
                            '{}/{}'.format(config[context]['interfaces'][interface]['iface_static_ip'], netmask_to_cidr(
                                    config[context]['interfaces'][interface]['iface_static_mask']))):
                        debug('matches static', config[context]['interfaces'][interface]['interface_Zone'])
                        return config[context]['interfaces'][interface]['interface_Zone']
                if config[context]['interfaces'][interface]['iface_mgmt_ip'] != '0.0.0.0':
                    # log(config[context]['interfaces'][interface]['iface_mgmt_ip'])
                    if ip in netaddr.IPNetwork('{}/{}'.format(config[context]['interfaces'][interface]['iface_mgmt_ip'],
                                                              netmask_to_cidr(config[context]['interfaces'][interface][
                                                                                  'iface_mgmt_netmask']))):
                        debug('matches mgmt', config[context]['interfaces'][interface]['interface_Zone'])
                        return config[context]['interfaces'][interface]['interface_Zone']
            next_hop = None
            next_hop_ip = None
            next_hop_iface = None
            next_hop_ifacenum = None
            next_hop_ifacename = None
            for route in config[context]['routing']:
                log_info('route', route)
                route_dest = config[context]['routing'][route]['pbrObjDst']
                if route_dest == '':
                    route_dest = '0.0.0.0'
                log_info('Route Destination :', route_dest)
                if config[context]['routing'][route]['pbrObjSrc'] == "":
                    if route_dest in config[context]['addresses']:
                        # print(config[context]['addresses'][route_dest])
                        # log_info(config[context]['addresses'][route_dest]['addrObjType'])
                        if config[context]['addresses'][route_dest]['addrObjType'] == '8':
                            # log_info(config[context]['addresses'][route_dest])
                            log_info('Route Destination is a group, checking each member object')
                            for route_dest_addr in expand_address(config[context]['addresses'], route_dest,
                                                                  config[context]['addressmappings']):
                                if route_dest_addr in config[context]['addresses']:
                                    log_info(route_dest_addr)
                                    # print(ip)
                                    if config[context]['addresses'][route_dest_addr]['addrObjType'] == '2':
                                        route_destination = netaddr.IPRange(
                                            config[context]['addresses'][route_dest_addr]['addrObjIp1'],
                                            config[context]['addresses'][route_dest_addr]['addrObjIp2'])
                                    else:
                                        route_destination = netaddr.IPNetwork(
                                            '{}/{}'.format(config[context]['addresses'][route_dest_addr]['addrObjIp1'],
                                                           config[context]['addresses'][route_dest_addr]['addrObjIp2']))
                                    if netaddr.IPAddress(ip) in route_destination:
                                        # if netaddr.IPAddress(ip) in netaddr.IPNetwork('{}/{}'.format(config[config[context]['addresses']['addrObjIp1'], netmask_to_cidr(config[context]['interfaces'][interface]['iface_lan_mask']))):
                                        # config[context]['addresses'][route_dest_addr]['IPSet']:
                                        debug('Matched to {}/{}'.format(
                                            config[context]['addresses'][route_dest_addr]['addrObjIp1'],
                                            config[context]['addresses'][route_dest_addr]['addrObjIp2']))
                                        if netmask_to_cidr(
                                                config[context]['addresses'][route_dest_addr]['addrObjIp2']) > matchlen:
                                            # log(config[context]['routing'][route])
                                            matchlen = netmask_to_cidr(
                                                config[context]['addresses'][route_dest_addr]['addrObjIp2'])
                                            next_hop = config[context]['routing'][route]['pbrObjGw']
                                            next_hop_ifacenum = config[context]['routing'][route]['pbrObjIface']
                                            debug('Nexthop : ', next_hop)
                                            debug(config[context]['routing'][route])
                                            if next_hop in config[context]['addresses']:
                                                debug('Next hop object found in addresses')
                                                next_hop_ip = config[context]['addresses'][next_hop]['addrObjIp1']
                                            else:
                                                next_hop_ip = next_hop
                                            if next_hop_ip == '':
                                                if config[context]['routing'][route]['pbrObjIface'] in [
                                                    config[context]['interfaces'][x]['iface_name'] for x in
                                                    config[context]['interfaces']]:
                                                    for x in config[context]['interfaces']:
                                                        if config[context]['routing'][route]['pbrObjIface'] == \
                                                                config[context]['interfaces'][x]['iface_name']:
                                                            if config[context]['interfaces'][x][
                                                                'iface_lan_ip'] != '0.0.0.0':
                                                                next_hop_ip = config[context]['interfaces'][x][
                                                                    'iface_lan_default_gw']
                                                            else:
                                                                next_hop_ip = config[context]['interfaces'][x][
                                                                    'iface_static_gateway']
                                            log_info(
                                                'Searched address found in destination group: "{}" - MatchLength {} Nexthop {} {}'.format(
                                                    urllib.parse.unquote(route_dest), matchlen, next_hop, next_hop_ip))
                                            ## THIS IS THE CORRECT GET_ZONE

                                        else:
                                            log_info('Skipping - not longest match')
                                else:
                                    log_info('Address group not found in context')
                        elif config[context]['addresses'][route_dest]['addrObjType'] == '2':
                            if netaddr.IPAddress(ip) in netaddr.IPRange(
                                    config[context]['addresses'][route_dest]['addrObjIp1'],
                                    config[context]['addresses'][route_dest]['addrObjIp2']):
                                # if ip in config[context]['addresses'][route_dest]['IPSet']:
                                log_info('Searched address found in destination range address object')
                                if netmask_to_cidr(config[context]['addresses'][route_dest]['addrObjIp2']) > matchlen:
                                    matchlen = 32
                                    next_hop = config[context]['routing'][route]['pbrObjGw']
                                    next_hop_ifacenum = config[context]['routing'][route]['pbrObjIface']
                                    if next_hop in config[context]['addresses']:
                                        next_hop_ip = config[context]['addresses'][next_hop]['addrObjIp1']
                                    else:
                                        next_hop_ip = next_hop
                                else:
                                    log_info('Skipping - not longest match')
                        else:
                            # if 'IPSet' in config[context]['addresses'][route_dest]:
                            if netaddr.IPAddress(ip) in netaddr.IPNetwork(
                                    '{}/{}'.format(config[context]['addresses'][route_dest]['addrObjIp1'],
                                                   config[context]['addresses'][route_dest]['addrObjIp2'])):
                                # if ip in config[context]['addresses'][route_dest]['IPSet']:
                                log_info('Searched address found in destination address')
                                if netmask_to_cidr(config[context]['addresses'][route_dest]['addrObjIp2']) > matchlen:
                                    matchlen = netmask_to_cidr(config[context]['addresses'][route_dest]['addrObjIp2'])
                                    next_hop = config[context]['routing'][route]['pbrObjGw']
                                    next_hop_ifacenum = config[context]['routing'][route]['pbrObjIface']
                                    if next_hop in config[context]['addresses']:
                                        next_hop_ip = config[context]['addresses'][next_hop]['addrObjIp1']
                                    else:
                                        next_hop_ip = next_hop
                                else:
                                    log_info('Skipping - not longest match')
                            # else:
                            #    log('WARNING - Route destinations with Range objects not yet supported - need to add IPSet property to Range address objects - {}-{}'.format(config[context]['addresses'][route_dest]['addrObjIp1'], config[context]['addresses'][route_dest]['addrObjIp2']))
                            # print(next_hop)
                            # print(next_hop_ip)
                    elif len(route_dest.split('/')) == 2:
                        log_info('Route destination is not in address objects')
                        try:
                            if netaddr.IPAddress(ip) in netaddr.IPNetwork(route_dest):
                                network, mask = route_dest.split('/')
                                if int(mask) >= matchlen:
                                    matchlen = int(mask)
                                    next_hop = config[context]['routing'][route]['pbrObjGw']
                                    next_hop_ifacenum = str(config[context]['routing'][route]['pbrObjIface'])
                                    next_hop_ifacename = config[context]['routing'][route]['pbrObjIfaceName']
                                    log_info('MATCH1 "{}" "{}" "{}" "{}"'.format(network, mask,
                                                                                 config[context]['routing'][route][
                                                                                     'pbrObjGw'],
                                                                                 config[context]['routing'][route][
                                                                                     'pbrObjIface'], ))
                                if next_hop in config[context]['addresses']:
                                    next_hop_ip = config[context]['addresses'][next_hop]['addrObjIp1']
                                else:
                                    next_hop_ip = next_hop
                        except Exception as e:
                            log(e)
                            log('Route destination not in network/mask format')
                    elif route_dest == '0.0.0.0' and matchlen < 0:  # route is a default route
                        matchlen = 0
                        next_hop = config[context]['routing'][route]['pbrObjGw']
                        next_hop_ifacenum = config[context]['routing'][route]['pbrObjIface']
                        next_hop_ifacename = config[context]['routing'][route]['pbrObjIfaceName']
                        if next_hop in config[context]['addresses']:
                            next_hop_ip = config[context]['addresses'][next_hop]['addrObjIp1']
                        else:
                            next_hop_ip = next_hop
                        log_info('Default Route!')

                    # print(config[context]['interfaces'])
            log_info('Matchlen', matchlen)

            if next_hop_ifacenum != None:
                for interface in config[context]['interfaces']:
                    # log('"{}" "{}" "{}" "{}"'.format(config[context]['interfaces'][interface]['iface_ifnum'], next_hop_ifacenum, config[context]['interfaces'][interface]['iface_name'], next_hop_ifacename))
                    if config[context]['interfaces'][interface][
                        'iface_name'] == next_hop_ifacename:  # or config[context]['interfaces'][interface]['iface_name'] == next_hop_ifacen:
                        # log("-" *180)
                        # log('!!!!{}!!!!!!'.format(config[context]['interfaces'][interface]['iface_name']))
                        # log("-" *180)
                        # log(config[context]['interfaces'][interface]['interface_Zone'])
                        return config[context]['interfaces'][interface]['interface_Zone']

            if matchlen != -1:
                if next_hop_ip == '':
                    next_hop_ip = '0.0.0.0'
                log_info('NEXTHOP', next_hop, next_hop_ip, next_hop_ifacenum)

                for interface in config[context]['interfaces']:
                    if config[context]['interfaces'][interface]['iface_lan_ip'] != '0.0.0.0':
                        if netaddr.IPAddress(next_hop_ip) in netaddr.IPNetwork(
                                '{}/{}'.format(config[context]['interfaces'][interface]['iface_lan_ip'],
                                               netmask_to_cidr(
                                                       config[context]['interfaces'][interface]['iface_lan_mask']))):
                            # print('{} - {}/{}'.format(config[context]['interfaces'][interface]['iface_name'],config[context]['interfaces'][interface]['iface_lan_ip'],config[context]['interfaces'][interface]['iface_lan_mask']))
                            # print('ROUTE MATCH - Searched address {} is in Zone : {} Interface Name: {} Interface Address {}/{}'.format(ip, config[context]['interfaces'][interface]['interface_Zone'], config[context]['interfaces'][interface]['iface_name'], config[context]['interfaces'][interface]['iface_lan_ip'],netmask_to_cidr(config[context]['interfaces'][interface]['iface_lan_mask'])))
                            return config[context]['interfaces'][interface]['interface_Zone']
                    elif config[context]['interfaces'][interface]['iface_static_ip'] != '0.0.0.0':
                        # log(netaddr.IPAddress(next_hop_ip))
                        # log(config[context]['interfaces'][interface]['iface_static_ip'], config[context]['interfaces'][interface]['iface_static_mask'])
                        if netaddr.IPAddress(next_hop_ip) in netaddr.IPNetwork(
                                '{}/{}'.format(config[context]['interfaces'][interface]['iface_static_ip'],
                                               netmask_to_cidr(
                                                       config[context]['interfaces'][interface]['iface_static_mask']))):
                            ##print('{} - {}/{}'.format(config[context]['interfaces'][interface]['iface_name'],config[context]['interfaces'][interface]['iface_static_ip'],config[context]['interfaces'][interface]['iface_static_mask']))
                            # print('ROUTE MATCH - Searched address {} is in Zone : {} Interface Name: {} Interface Address {}/{}'.format(ip, config[context]['interfaces'][interface]['interface_Zone'], config[context]['interfaces'][interface]['iface_name'], config[context]['interfaces'][interface]['iface_static_ip'],netmask_to_cidr(config[context]['interfaces'][interface]['iface_static_mask'])))
                            return config[context]['interfaces'][interface]['interface_Zone']
                    elif config[context]['interfaces'][interface]['iface_mgmt_ip'] != '0.0.0.0':
                        if netaddr.IPAddress(next_hop_ip) in netaddr.IPNetwork(
                                '{}/{}'.format(config[context]['interfaces'][interface]['iface_mgmt_ip'],
                                               netmask_to_cidr(config[context]['interfaces'][interface][
                                                                   'iface_mgmt_netmask']))):
                            # print('{} - {}/{}'.format(config[context]['interfaces'][interface]['iface_name'],config[context]['interfaces'][interface]['iface_mgmt_ip'],config[context]['interfaces'][interface]['iface_mgmt_netmask']))
                            # print('ROUTE MATCH - Searched address {} is in Zone : {} Interface Name: {} Interface Address {}/{}'.format(ip, config[context]['interfaces'][interface]['interface_Zone'], config[context]['interfaces'][interface]['iface_name'], config[context]['interfaces'][interface]['iface_mgmt_ip'],netmask_to_cidr(config[context]['interfaces'][interface]['iface_mgmt_netmask'])))
                            return config[context]['interfaces'][interface]['interface_Zone']
                else:  # as a last resort, try getting static gateway from interface config -- these are auto added rules and not part of the pbr config
                    if next_hop_ip == '0.0.0.0':
                        return 'WAN'
                    log_info('Trying to see if ip is on same net as interface')
                    for interface in config[context]['interfaces']:
                        if config[context]['interfaces'][interface]['iface_lan_ip'] != '0.0.0.0':
                            if ip in netaddr.IPNetwork(
                                    '{}/{}'.format(config[context]['interfaces'][interface]['iface_lan_ip'],
                                                   netmask_to_cidr(config[context]['interfaces'][interface][
                                                                       'iface_lan_mask']))):
                                return config[context]['interfaces'][interface]['interface_Zone']

                    # return None

            else:  # check if ip address is on same subnet as interfaces - lan_ip should likely be done before checking pbr, static_ip should likely be done after
                # log_info('Trying to see if ip is on same net as interface')
                for interface in config[context]['interfaces']:
                    if config[context]['interfaces'][interface]['iface_lan_ip'] != '0.0.0.0':
                        if ip in netaddr.IPNetwork(
                                '{}/{}'.format(config[context]['interfaces'][interface]['iface_lan_ip'],
                                               netmask_to_cidr(
                                                   config[context]['interfaces'][interface]['iface_lan_mask']))):
                            return config[context]['interfaces'][interface]['interface_Zone']
                for interface in config[context]['interfaces']:
                    if config[context]['interfaces'][interface]['iface_static_ip'] != '0.0.0.0':
                        # if ip in netaddr.IPNetwork('{}/{}'.format(config[context]['interfaces'][interface]['iface_static_ip'],netmask_to_cidr(config[context]['interfaces'][interface]['iface_static_mask']))):
                        return config[context]['interfaces'][interface]['interface_Zone']

        else:
            log_info('Routing not in config')
    except Exception as e:
        debug(e, e.__traceback__.tb_lineno)
        return None
    return None


def get_zone2(context, ip, config):
    import netaddr
    import urllib

    try:
        ip, mask = ip.split('/')
    except:
        ip, mask = (ip, '32')
    try:
        ipNetwork = netaddr.IPNetwork('{}/{}'.format(ip, mask))

        log_info('Searching {} for address : {}'.format(context, ip))
        log_info('-' * 100)
        #        for item in config[context]:
        #            print(item)
        return_zones = []
        if 'routing' in config[context]:
            log_info('routing found in config')
            matchlen = -1

            for interface in config[context]['interfaces']:  ## this
                log_info('interface', interface)
                if config[context]['interfaces'][interface]['iface_lan_ip'] != '0.0.0.0':
                    if ip in netaddr.IPNetwork('{}/{}'.format(config[context]['interfaces'][interface]['iface_lan_ip'],
                                                              netmask_to_cidr(config[context]['interfaces'][interface][
                                                                                  'iface_lan_mask']))) or netaddr.IPNetwork(
                            '{}/{}'.format(config[context]['interfaces'][interface]['iface_lan_ip'], netmask_to_cidr(
                                    config[context]['interfaces'][interface]['iface_lan_mask']))) in ipNetwork:
                        debug('matches lan', config[context]['interfaces'][interface]['interface_Zone'])
                        return_zones.append(config[context]['interfaces'][interface]['interface_Zone'])
                if config[context]['interfaces'][interface]['iface_static_ip'] != '0.0.0.0':
                    # log(config[context]['interfaces'][interface]['iface_static_ip'])
                    debug(ip)
                    if ip in netaddr.IPNetwork(
                            '{}/{}'.format(config[context]['interfaces'][interface]['iface_static_ip'], netmask_to_cidr(
                                    config[context]['interfaces'][interface][
                                        'iface_static_mask']))) or netaddr.IPNetwork(
                            '{}/{}'.format(config[context]['interfaces'][interface]['iface_static_ip'], netmask_to_cidr(
                                    config[context]['interfaces'][interface]['iface_static_mask']))) in ipNetwork:
                        debug('matches static', config[context]['interfaces'][interface]['interface_Zone'])
                        return_zones.append(config[context]['interfaces'][interface]['interface_Zone'])
                if config[context]['interfaces'][interface]['iface_mgmt_ip'] != '0.0.0.0':
                    # log(config[context]['interfaces'][interface]['iface_mgmt_ip'])
                    if ip in netaddr.IPNetwork('{}/{}'.format(config[context]['interfaces'][interface]['iface_mgmt_ip'],
                                                              netmask_to_cidr(config[context]['interfaces'][interface][
                                                                                  'iface_mgmt_netmask']))) or netaddr.IPNetwork(
                            '{}/{}'.format(config[context]['interfaces'][interface]['iface_mgmt_ip'], netmask_to_cidr(
                                    config[context]['interfaces'][interface]['iface_mgmt_netmask']))) in ipNetwork:
                        debug('matches mgmt', config[context]['interfaces'][interface]['interface_Zone'])
                        return_zones.append(config[context]['interfaces'][interface]['interface_Zone'])
            # log('return_zones after checking intrfaces', return_zones)
            next_hop = None
            next_hop_ip = None
            next_hop_iface = None
            next_hop_ifacenum = None

            ## this was added becasue of zone calc here and in expedition was wrong is an address object is a "supernet" -- the result is that it is likely part of multiple zones, rather than just 1
            ## its likely that this should only be performed if matchlen=0 (default route)
            '''
            for route in config[context]['routing']:  
                route_dest=config[context]['routing'][route]['pbrObjDst']
                if len(route_dest.split('/'))==2 and config[context]['routing'][route]['pbrObjDst'] not in config[context]['addresses']:
                    #log_info('Route destination is not in address objects')
                    try:
                        #log('{},{}'.format(netaddr.IPNetwork(route_dest), ipNetwork))
                        if netaddr.IPNetwork(route_dest) in ipNetwork:
                            return_zones.append(config[context]['interfaces'][config[context]['routing'][route]['pbrObjIface']]['interface_Zone'])
                    except Exception as e: 
                        log('EXCEPTION!!!! {}'.format(e))
            '''

            for route in config[context]['routing']:
                log_info('route', route)
                route_dest = config[context]['routing'][route]['pbrObjDst']
                if route_dest == '':
                    pass
                    # route_dest='0.0.0.0'
                log_info('Route Destination :', route_dest)
                if config[context]['routing'][route]['pbrObjSrc'] == "":
                    if route_dest in config[context]['addresses']:
                        # log('JEFF!!!', route_dest)
                        # print(config[context]['addresses'][route_dest])
                        # log_info(config[context]['addresses'][route_dest]['addrObjType'])
                        if config[context]['addresses'][route_dest]['addrObjType'] == '8':
                            # log_info(config[context]['addresses'][route_dest])
                            log_info('Route Destination is a group, checking each member object')
                            for route_dest_addr in expand_address(config[context]['addresses'], route_dest,
                                                                  config[context]['addressmappings']):
                                if route_dest_addr in config[context]['addresses']:
                                    log_info(route_dest_addr)
                                    # print(ip)
                                    if config[context]['addresses'][route_dest_addr]['addrObjType'] == '2':
                                        route_destination = netaddr.IPRange(
                                            config[context]['addresses'][route_dest_addr]['addrObjIp1'],
                                            config[context]['addresses'][route_dest_addr]['addrObjIp2'])
                                    else:
                                        route_destination = netaddr.IPNetwork(
                                            '{}/{}'.format(config[context]['addresses'][route_dest_addr]['addrObjIp1'],
                                                           config[context]['addresses'][route_dest_addr]['addrObjIp2']))
                                    if netaddr.IPAddress(ip) in route_destination:
                                        # if netaddr.IPAddress(ip) in netaddr.IPNetwork('{}/{}'.format(config[config[context]['addresses']['addrObjIp1'], netmask_to_cidr(config[context]['interfaces'][interface]['iface_lan_mask']))):
                                        # config[context]['addresses'][route_dest_addr]['IPSet']:
                                        debug('Matched to {}/{}'.format(
                                            config[context]['addresses'][route_dest_addr]['addrObjIp1'],
                                            config[context]['addresses'][route_dest_addr]['addrObjIp2']))
                                        if netmask_to_cidr(
                                                config[context]['addresses'][route_dest_addr]['addrObjIp2']) > matchlen:
                                            # log(config[context]['routing'][route])
                                            matchlen = netmask_to_cidr(
                                                config[context]['addresses'][route_dest_addr]['addrObjIp2'])
                                            next_hop = config[context]['routing'][route]['pbrObjGw']
                                            next_hop_ifacenum = config[context]['routing'][route]['pbrObjIface']
                                            debug('Nexthop : ', next_hop)
                                            debug(config[context]['routing'][route])
                                            if next_hop in config[context]['addresses']:
                                                debug('Next hop object found in addresses')
                                                next_hop_ip = config[context]['addresses'][next_hop]['addrObjIp1']
                                            else:
                                                next_hop_ip = next_hop
                                            if next_hop_ip == '':
                                                if config[context]['routing'][route]['pbrObjIface'] in [
                                                    config[context]['interfaces'][x]['iface_name'] for x in
                                                    config[context]['interfaces']]:
                                                    for x in config[context]['interfaces']:
                                                        if config[context]['routing'][route]['pbrObjIface'] == \
                                                                config[context]['interfaces'][x]['iface_name']:
                                                            if config[context]['interfaces'][x][
                                                                'iface_lan_ip'] != '0.0.0.0':
                                                                next_hop_ip = config[context]['interfaces'][x][
                                                                    'iface_lan_default_gw']
                                                            else:
                                                                next_hop_ip = config[context]['interfaces'][x][
                                                                    'iface_static_gateway']
                                            log_info(
                                                'Searched address found in destination group: "{}" - MatchLength {} Nexthop {} {}'.format(
                                                    urllib.parse.unquote(route_dest), matchlen, next_hop, next_hop_ip))
                                            ## THIS IS THE CORRECT GET_ZONE

                                        else:
                                            log_info('Skipping - not longest match')
                                else:
                                    log_info('Address group not found in context')
                        elif config[context]['addresses'][route_dest]['addrObjType'] == '2':
                            if netaddr.IPAddress(ip) in netaddr.IPRange(
                                    config[context]['addresses'][route_dest]['addrObjIp1'],
                                    config[context]['addresses'][route_dest]['addrObjIp2']):
                                # if ip in config[context]['addresses'][route_dest]['IPSet']:
                                log_info('Searched address found in destination range address object')
                                if netmask_to_cidr(config[context]['addresses'][route_dest]['addrObjIp2']) > matchlen:
                                    matchlen = 32
                                    next_hop = config[context]['routing'][route]['pbrObjGw']
                                    next_hop_ifacenum = config[context]['routing'][route]['pbrObjIface']
                                    if next_hop in config[context]['addresses']:
                                        next_hop_ip = config[context]['addresses'][next_hop]['addrObjIp1']
                                    else:
                                        next_hop_ip = next_hop
                                else:
                                    log_info('Skipping - not longest match')
                        else:
                            # if 'IPSet' in config[context]['addresses'][route_dest]:
                            if netaddr.IPAddress(ip) in netaddr.IPNetwork(
                                    '{}/{}'.format(config[context]['addresses'][route_dest]['addrObjIp1'],
                                                   config[context]['addresses'][route_dest]['addrObjIp2'])):
                                # if ip in config[context]['addresses'][route_dest]['IPSet']:
                                log_info('Searched address found in destination address')
                                if netmask_to_cidr(config[context]['addresses'][route_dest]['addrObjIp2']) > matchlen:
                                    matchlen = netmask_to_cidr(config[context]['addresses'][route_dest]['addrObjIp2'])
                                    next_hop = config[context]['routing'][route]['pbrObjGw']
                                    next_hop_ifacenum = config[context]['routing'][route]['pbrObjIface']
                                    if next_hop in config[context]['addresses']:
                                        next_hop_ip = config[context]['addresses'][next_hop]['addrObjIp1']
                                    else:
                                        next_hop_ip = next_hop
                                else:
                                    log_info('Skipping - not longest match')
                            # else:
                            #    log('WARNING - Route destinations with Range objects not yet supported - need to add IPSet property to Range address objects - {}-{}'.format(config[context]['addresses'][route_dest]['addrObjIp1'], config[context]['addresses'][route_dest]['addrObjIp2']))
                            # print(next_hop)
                            # print(next_hop_ip)
                    elif len(route_dest.split('/')) == 2:
                        log_info('Route destination is not in address objects')
                        try:
                            if netaddr.IPAddress(ip) in netaddr.IPNetwork(route_dest):
                                network, mask = route_dest.split('/')
                                if int(mask) >= matchlen:
                                    log_info('MATCH1', network, mask, config[context]['routing'][route]['pbrObjGw'])
                                    matchlen = int(mask)
                                    next_hop = config[context]['routing'][route]['pbrObjGw']
                                    next_hop_ifacenum = config[context]['routing'][route]['pbrObjIface']
                                if next_hop in config[context]['addresses']:
                                    next_hop_ip = config[context]['addresses'][next_hop]['addrObjIp1']
                                else:
                                    next_hop_ip = next_hop
                        except Exception as e:
                            log(e)
                            log('Route destination not in network/mask format')
                    elif route_dest == '0.0.0.0' and matchlen < 0:  # route is a default route
                        matchlen = 0
                        next_hop = config[context]['routing'][route]['pbrObjGw']
                        next_hop_ifacenum = config[context]['routing'][route]['pbrObjIface']
                        if next_hop in config[context]['addresses']:
                            next_hop_ip = config[context]['addresses'][next_hop]['addrObjIp1']
                        else:
                            next_hop_ip = next_hop
                        # log(config[context]['routing'][route])
                        log_info('Default Route! "{}" "{}"'.format(next_hop, next_hop_ifacenum))

                    # print(config[context]['interfaces'])
            log_info('Matchlen', matchlen)
            # log('return_zones before next_hop_ifacenum != 1', return_zones)
            if next_hop_ifacenum != None:
                for interface in config[context]['interfaces']:
                    if config[context]['interfaces'][interface]['iface_ifnum'] == next_hop_ifacenum or \
                            config[context]['interfaces'][interface]['iface_name'] == next_hop_ifacenum:
                        return_zones.append(config[context]['interfaces'][interface]['interface_Zone'])
            # log('return_zones before matchlength != 1', return_zones)
            if matchlen != -1:
                if next_hop_ip == '':
                    next_hop_ip = '0.0.0.0'
                log_info('NEXTHOP', next_hop, next_hop_ip, next_hop_ifacenum)

                for interface in config[context]['interfaces']:
                    if config[context]['interfaces'][interface]['iface_lan_ip'] != '0.0.0.0':
                        if netaddr.IPAddress(next_hop_ip) in netaddr.IPNetwork(
                                '{}/{}'.format(config[context]['interfaces'][interface]['iface_lan_ip'],
                                               netmask_to_cidr(
                                                       config[context]['interfaces'][interface]['iface_lan_mask']))):
                            # print('{} - {}/{}'.format(config[context]['interfaces'][interface]['iface_name'],config[context]['interfaces'][interface]['iface_lan_ip'],config[context]['interfaces'][interface]['iface_lan_mask']))
                            # print('ROUTE MATCH - Searched address {} is in Zone : {} Interface Name: {} Interface Address {}/{}'.format(ip, config[context]['interfaces'][interface]['interface_Zone'], config[context]['interfaces'][interface]['iface_name'], config[context]['interfaces'][interface]['iface_lan_ip'],netmask_to_cidr(config[context]['interfaces'][interface]['iface_lan_mask'])))
                            return_zones.append(config[context]['interfaces'][interface]['interface_Zone'])
                    elif config[context]['interfaces'][interface]['iface_static_ip'] != '0.0.0.0':
                        # log(netaddr.IPAddress(next_hop_ip))
                        # log(config[context]['interfaces'][interface]['iface_static_ip'], config[context]['interfaces'][interface]['iface_static_mask'])
                        if netaddr.IPAddress(next_hop_ip) in netaddr.IPNetwork(
                                '{}/{}'.format(config[context]['interfaces'][interface]['iface_static_ip'],
                                               netmask_to_cidr(
                                                       config[context]['interfaces'][interface]['iface_static_mask']))):
                            ##print('{} - {}/{}'.format(config[context]['interfaces'][interface]['iface_name'],config[context]['interfaces'][interface]['iface_static_ip'],config[context]['interfaces'][interface]['iface_static_mask']))
                            # print('ROUTE MATCH - Searched address {} is in Zone : {} Interface Name: {} Interface Address {}/{}'.format(ip, config[context]['interfaces'][interface]['interface_Zone'], config[context]['interfaces'][interface]['iface_name'], config[context]['interfaces'][interface]['iface_static_ip'],netmask_to_cidr(config[context]['interfaces'][interface]['iface_static_mask'])))
                            return_zones.append(config[context]['interfaces'][interface]['interface_Zone'])
                    elif config[context]['interfaces'][interface]['iface_mgmt_ip'] != '0.0.0.0':
                        if netaddr.IPAddress(next_hop_ip) in netaddr.IPNetwork(
                                '{}/{}'.format(config[context]['interfaces'][interface]['iface_mgmt_ip'],
                                               netmask_to_cidr(config[context]['interfaces'][interface][
                                                                   'iface_mgmt_netmask']))):
                            # print('{} - {}/{}'.format(config[context]['interfaces'][interface]['iface_name'],config[context]['interfaces'][interface]['iface_mgmt_ip'],config[context]['interfaces'][interface]['iface_mgmt_netmask']))
                            # print('ROUTE MATCH - Searched address {} is in Zone : {} Interface Name: {} Interface Address {}/{}'.format(ip, config[context]['interfaces'][interface]['interface_Zone'], config[context]['interfaces'][interface]['iface_name'], config[context]['interfaces'][interface]['iface_mgmt_ip'],netmask_to_cidr(config[context]['interfaces'][interface]['iface_mgmt_netmask'])))
                            return_zones.append(config[context]['interfaces'][interface]['interface_Zone'])
                else:  # as a last resort, try getting static gateway from interface config -- these are auto added rules and not part of the pbr config
                    if next_hop_ip == '0.0.0.0':
                        return_zones.append('WAN')
                    log_info('Trying to see if ip is on same net as interface')
                    for interface in config[context]['interfaces']:
                        if config[context]['interfaces'][interface]['iface_lan_ip'] != '0.0.0.0':
                            if ip in netaddr.IPNetwork(
                                    '{}/{}'.format(config[context]['interfaces'][interface]['iface_lan_ip'],
                                                   netmask_to_cidr(config[context]['interfaces'][interface][
                                                                       'iface_lan_mask']))):
                                return_zones.append(config[context]['interfaces'][interface]['interface_Zone'])

                    # return None

            else:  # check if ip address is on same subnet as interfaces - lan_ip should likely be done before checking pbr, static_ip should likely be done after
                # log_info('Trying to see if ip is on same net as interface')
                for interface in config[context]['interfaces']:
                    # log('interface', config[context]['interfaces'][interface])
                    if config[context]['interfaces'][interface]['iface_lan_ip'] != '0.0.0.0':
                        if ip in netaddr.IPNetwork(
                                '{}/{}'.format(config[context]['interfaces'][interface]['iface_lan_ip'],
                                               netmask_to_cidr(
                                                       config[context]['interfaces'][interface]['iface_lan_mask']))):
                            return_zones.append(config[context]['interfaces'][interface]['interface_Zone'])
                if return_zones == []:
                    for interface in config[context]['interfaces']:
                        if config[context]['interfaces'][interface]['iface_static_ip'] != '0.0.0.0':
                            if ip in netaddr.IPNetwork(
                                    '{}/{}'.format(config[context]['interfaces'][interface]['iface_static_ip'],
                                                   netmask_to_cidr(config[context]['interfaces'][interface][
                                                                       'iface_static_mask']))):
                                return_zones.append(config[context]['interfaces'][interface]['interface_Zone'])
                if return_zones == []:
                    return_zones.append('WAN')
                '''
                for interface in config[context]['interfaces']:
                    if config[context]['interfaces'][interface]['iface_static_ip']!='0.0.0.0' and config[context]['interfaces'][interface]['interface_Zone']=='WAN':
                        #if ip in netaddr.IPNetwork('{}/{}'.format(config[context]['interfaces'][interface]['iface_static_ip'],netmask_to_cidr(config[context]['interfaces'][interface]['iface_static_mask']))):
                        #log(config[context]['interfaces'][interface]['interface_Zone'])
                        return_zones.append(config[context]['interfaces'][interface]['interface_Zone'])
                '''

                # log('return_zones after failing matchlen check', return_zones)
            return list(set(return_zones))
        else:
            log_info('Routing not in config')
    except:
        return None
    return None


def get_zone_new(context,
                 ip):  # these were improved routines that may have been unneeded because I was testing against the lab box which had default route set as MGMT
    import netaddr
    import urllib
    import json

    #    dest_ip='132.5.6.9'
    #    dest_ips=['10.25.116.3', '10.7.200.1']
    #    for dest_ip in dest_ips:
    #        print('-' *100)

    #        for context in contexts:
    debug('Searching {} for address : {}'.format(context, ip))
    debug('-' * 100)
    #        for item in config[context]:
    #            print(item)
    debug(json.dumps(config[context]['routing'], indent=4))
    if 'routing' in config[context]:
        matchlen = -1
        for interface in config[context]['interfaces']:
            if config[context]['interfaces'][interface]['iface_lan_ip'] != '0.0.0.0':
                if ip in netaddr.IPNetwork('{}/{}'.format(config[context]['interfaces'][interface]['iface_lan_ip'],
                                                          netmask_to_cidr(config[context]['interfaces'][interface][
                                                                              'iface_lan_mask']))):
                    debug('matches lan', config[context]['interfaces'][interface]['interface_Zone'])
                    return config[context]['interfaces'][interface]['interface_Zone']
            if config[context]['interfaces'][interface]['iface_static_ip'] != '0.0.0.0':
                if ip in netaddr.IPNetwork('{}/{}'.format(config[context]['interfaces'][interface]['iface_static_ip'],
                                                          netmask_to_cidr(config[context]['interfaces'][interface][
                                                                              'iface_static_mask']))):
                    debug('matches static', config[context]['interfaces'][interface]['interface_Zone'])
                    return config[context]['interfaces'][interface]['interface_Zone']
            if config[context]['interfaces'][interface]['iface_mgmt_ip'] != '0.0.0.0':
                if ip in netaddr.IPNetwork('{}/{}'.format(config[context]['interfaces'][interface]['iface_mgmt_ip'],
                                                          netmask_to_cidr(config[context]['interfaces'][interface][
                                                                              'iface_mgmt_netmask']))):
                    debug('matches mgmt', config[context]['interfaces'][interface]['interface_Zone'])
                    return config[context]['interfaces'][interface]['interface_Zone']
        for route in config[context]['routing']:
            route_dest = config[context]['routing'][route]['pbrObjDst']
            if route_dest == '':
                route_dest = '0.0.0.0'
            debug(route_dest)
            if config[context]['routing'][route]['pbrObjSrc'] == "":
                if route_dest in config[context]['addresses']:
                    # print(config[context]['addresses'][route_dest])
                    debug('route dest obj type :', config[context]['addresses'][route_dest]['addrObjType'])
                    if config[context]['addresses'][route_dest]['addrObjType'] == '8':
                        debug(config[context]['addresses'][route_dest])
                        debug('Route Destination is a group, checking each member object')
                        for route_dest_addr in expand_address(config[context]['addresses'], route_dest,
                                                              config[context]['addressmappings']):
                            if route_dest_addr in config[context]['addresses']:
                                debug(route_dest_addr)
                                # print(ip)
                                if netaddr.IPAddress(ip) in netaddr.IPNetwork(
                                        '{}/{}'.format(config[context]['addresses'][route_dest_addr]['addrObjIp1'],
                                                       config[context]['addresses'][route_dest_addr]['addrObjIp2'])):
                                    # if netaddr.IPAddress(ip) in netaddr.IPNetwork('{}/{}'.format(config[config[context]['addresses']['addrObjIp1'], netmask_to_cidr(config[context]['interfaces'][interface]['iface_lan_mask']))):
                                    # config[context]['addresses'][route_dest_addr]['IPSet']:

                                    if netmask_to_cidr(
                                            config[context]['addresses'][route_dest_addr]['addrObjIp2']) > matchlen:
                                        matchlen = netmask_to_cidr(
                                            config[context]['addresses'][route_dest_addr]['addrObjIp2'])
                                        next_hop = config[context]['routing'][route]['pbrObjGw']
                                        if next_hop in config[context]['addresses']:
                                            next_hop_ip = config[context]['addresses'][next_hop]['addrObjIp1']
                                        else:
                                            next_hop_ip = next_hop
                                        debug(
                                            'Searched address found in destination group: "{}" - MatchLength {} Nexthop {} {}'.format(
                                                urllib.parse.unquote(route_dest), matchlen, next_hop, next_hop_ip))
                                    else:
                                        debug('Skipping - not longest match')

                            else:
                                debug('Address group not found in context')
                    else:
                        # if 'IPSet' in config[context]['addresses'][route_dest]:
                        if netaddr.IPAddress(ip) in netaddr.IPNetwork(
                                '{}/{}'.format(config[context]['addresses'][route_dest]['addrObjIp1'],
                                               config[context]['addresses'][route_dest]['addrObjIp2'])):
                            # if ip in config[context]['addresses'][route_dest]['IPSet']:
                            debug('Searched address found in destination address')
                            if netmask_to_cidr(config[context]['addresses'][route_dest]['addrObjIp2']) > matchlen:
                                matchlen = netmask_to_cidr(config[context]['addresses'][route_dest]['addrObjIp2'])
                                next_hop = config[context]['routing'][route]['pbrObjGw']
                                if next_hop in config[context]['addresses']:
                                    next_hop_ip = config[context]['addresses'][next_hop]['addrObjIp1']
                                else:
                                    next_hop_ip = next_hop
                            else:
                                debug('Skipping - not longest match')
                        # else:
                        #    log('WARNING - Route destinations with Range objects not yet supported - need to add IPSet property to Range address objects - {}-{}'.format(config[context]['addresses'][route_dest]['addrObjIp1'], config[context]['addresses'][route_dest]['addrObjIp2']))
                        # print(next_hop)
                        # print(next_hop_ip)
                elif len(route_dest.split('/')) == 2:
                    debug('Route destination is not in address objects')
                    try:
                        if netaddr.IPAddress(ip) in netaddr.IPNetwork(route_dest):
                            network, mask = route_dest.split('/')
                            if int(mask) > matchlen:
                                debug('MATCH1', network, mask, config[context]['routing'][route]['pbrObjGw'])
                                matchlen = int(mask)
                                next_hop = config[context]['routing'][route]['pbrObjGw']
                            if next_hop in config[context]['addresses']:
                                next_hop_ip = config[context]['addresses'][next_hop]['addrObjIp1']
                            else:
                                next_hop_ip = next_hop
                    except Exception as e:
                        log(e)
                        log('Route destination not in network/mask format')
                elif route_dest == '0.0.0.0':  # route is a default route
                    matchlen = 0
                    next_hop = config[context]['routing'][route]['pbrObjGw']
                    if next_hop in config[context]['addresses']:
                        next_hop_ip = config[context]['addresses'][next_hop]['addrObjIp1']
                    else:
                        next_hop_ip = next_hop
                    debug('Default Route!')

                # print(config[context]['interfaces'])
        debug('Matchlen', matchlen)
        if matchlen != -1:
            debug('NEXTHOP', next_hop, next_hop_ip)
            for interface in config[context]['interfaces']:
                if config[context]['interfaces'][interface]['iface_lan_ip'] != '0.0.0.0':
                    if netaddr.IPAddress(next_hop_ip) in netaddr.IPNetwork(
                            '{}/{}'.format(config[context]['interfaces'][interface]['iface_lan_ip'], netmask_to_cidr(
                                    config[context]['interfaces'][interface]['iface_lan_mask']))):
                        # print('{} - {}/{}'.format(config[context]['interfaces'][interface]['iface_name'],config[context]['interfaces'][interface]['iface_lan_ip'],config[context]['interfaces'][interface]['iface_lan_mask']))
                        # print('ROUTE MATCH - Searched address {} is in Zone : {} Interface Name: {} Interface Address {}/{}'.format(ip, config[context]['interfaces'][interface]['interface_Zone'], config[context]['interfaces'][interface]['iface_name'], config[context]['interfaces'][interface]['iface_lan_ip'],netmask_to_cidr(config[context]['interfaces'][interface]['iface_lan_mask'])))
                        return config[context]['interfaces'][interface]['interface_Zone']
                elif config[context]['interfaces'][interface]['iface_static_ip'] != '0.0.0.0':
                    if netaddr.IPAddress(next_hop_ip) in netaddr.IPNetwork(
                            '{}/{}'.format(config[context]['interfaces'][interface]['iface_static_ip'], netmask_to_cidr(
                                    config[context]['interfaces'][interface]['iface_static_mask']))):
                        ##print('{} - {}/{}'.format(config[context]['interfaces'][interface]['iface_name'],config[context]['interfaces'][interface]['iface_static_ip'],config[context]['interfaces'][interface]['iface_static_mask']))
                        # print('ROUTE MATCH - Searched address {} is in Zone : {} Interface Name: {} Interface Address {}/{}'.format(ip, config[context]['interfaces'][interface]['interface_Zone'], config[context]['interfaces'][interface]['iface_name'], config[context]['interfaces'][interface]['iface_static_ip'],netmask_to_cidr(config[context]['interfaces'][interface]['iface_static_mask'])))
                        return config[context]['interfaces'][interface]['interface_Zone']
                elif config[context]['interfaces'][interface]['iface_mgmt_ip'] != '0.0.0.0':
                    if netaddr.IPAddress(next_hop_ip) in netaddr.IPNetwork(
                            '{}/{}'.format(config[context]['interfaces'][interface]['iface_mgmt_ip'], netmask_to_cidr(
                                    config[context]['interfaces'][interface]['iface_mgmt_netmask']))):
                        # print('{} - {}/{}'.format(config[context]['interfaces'][interface]['iface_name'],config[context]['interfaces'][interface]['iface_mgmt_ip'],config[context]['interfaces'][interface]['iface_mgmt_netmask']))
                        # print('ROUTE MATCH - Searched address {} is in Zone : {} Interface Name: {} Interface Address {}/{}'.format(ip, config[context]['interfaces'][interface]['interface_Zone'], config[context]['interfaces'][interface]['iface_name'], config[context]['interfaces'][interface]['iface_mgmt_ip'],netmask_to_cidr(config[context]['interfaces'][interface]['iface_mgmt_netmask'])))
                        return config[context]['interfaces'][interface]['interface_Zone']
            else:  # as a last resort, try getting static gateway from interface config -- these are auto added rules and not part of the pbr config
                log('Trying to see if ip is on same net as interface')
                for interface in config[context]['interfaces']:
                    if config[context]['interfaces'][interface]['iface_lan_ip'] != '0.0.0.0':
                        if ip in netaddr.IPNetwork(
                                '{}/{}'.format(config[context]['interfaces'][interface]['iface_lan_ip'],
                                               netmask_to_cidr(
                                                   config[context]['interfaces'][interface]['iface_lan_mask']))):
                            return config[context]['interfaces'][interface]['interface_Zone']

                    return None
        else:  # check if ip address is on same subnet as interfaces - lan_ip should likely be done before checking pbr, static_ip should likely be done after
            # log('Trying to see if ip is on same net as interface')
            for interface in config[context]['interfaces']:
                if config[context]['interfaces'][interface]['iface_lan_ip'] != '0.0.0.0':
                    if ip in netaddr.IPNetwork('{}/{}'.format(config[context]['interfaces'][interface]['iface_lan_ip'],
                                                              netmask_to_cidr(config[context]['interfaces'][interface][
                                                                                  'iface_lan_mask']))):
                        debug('Using interface {} as next hop'.format(interface))
                        return config[context]['interfaces'][interface]['interface_Zone']
            for interface in config[context]['interfaces']:
                if config[context]['interfaces'][interface]['iface_static_ip'] != '0.0.0.0':
                    if ip in netaddr.IPNetwork(
                            '{}/{}'.format(config[context]['interfaces'][interface]['iface_static_ip'], netmask_to_cidr(
                                    config[context]['interfaces'][interface]['iface_static_mask']))):
                        debug('Using interface {} as next hop'.format(interface))
                        return config[context]['interfaces'][interface]['interface_Zone']
            if config[context]['config']['fw_type'] in ['sw65', 'sonicwall']:
                debug('Address object likely using default route on WAN'.format(interface))
                return 'WAN'

    else:
        log('Routing not in config')
    return None


def get_address_of(addresses, address_object):
    ## Given an address object name, it will return the IP address object of it.
    ## (DONE) Should be modified to also return netmask

    if address_object not in addresses:  # this should be handled better
        addresses = config['shared']['addresses']
    if address_object == '0.0.0.0' or address_object == '':
        return '0.0.0.0', '0'
    elif addresses[address_object]['addrObjType'] in ['1', '99', '91']:
        return addresses[address_object]['addrObjIp1'], '32'
    elif addresses[address_object]['addrObjType'] == '89':  # Palo FQDN object
        return addresses[address_object]['fqdn'], 'fqdn'
    elif addresses[address_object]['addrObjType'] == '2':
        return addresses[address_object]['addrObjIp1'], addresses[address_object]['addrObjIp2']
    elif addresses[address_object]['addrObjType'] == '98':  # group with exception
        return None, None
        # return addresses[address_object]['addrObjIp1'], addresses[address_object]['addrObjIp2']
        # return addresses[address_object]['addrObjIp1'], addresses[address_object]['addrObjIp2']
    else:
        return addresses[address_object]['addrObjIp1'], str(
            sum([bin(int(x)).count("1") for x in addresses[address_object]['addrObjIp2'].split(".")]));
    return;


def get_prot_of(services, service_object):
    ## Given a service object name, will return the IP protocol number of it.

    if service_object not in services:
        services = config['shared']['services']
    if service_object == '0':
        return 'any'
    if services[service_object]['svcObjIpType'] == '6':
        return 'tcp';
    elif services[service_object]['svcObjIpType'] == '17':
        return 'udp';
    elif services[service_object]['svcObjIpType'] == '1':
        return 'icmp';
    else:
        return services[service_object]['svcObjIpType']
    return;


def get_port_of(services, service_object):
    ## Given a service object name, will return the L4 protocol number of it.

    if service_object not in services:
        services = config['shared']['services']
    if service_object == '0':
        return 'any', 'any'
    else:
        return services[service_object]['svcObjPort1'], services[service_object]['svcObjPort2']
    return


def get_ports_of(services, service_object):
    ## Given a service object name, will return the L4 protocol number of it.

    import re
    portlist = []
    if service_object == '0':
        return ['any']  # list(range(1))
    if service_object not in services:
        services = config['shared']['services']
    if service_object in services:
        if services[service_object]['svcObjType'] == '1':
            if services[service_object]['svcObjPort1'] == '':
                # debug(services[service_object])
                services[service_object]['svcObjPort1'] = '0'
            if services[service_object]['svcObjPort2'] == '':
                services[service_object]['svcObjPort2'] = services[service_object]['svcObjPort1']
            # log(services[service_object]['svcObjPort1'])
            # log(services[service_object]['svcObjPort2'])
            if services[service_object]['svcObjPort1'] == 'echo-request':
                services[service_object]['svcObjPort1'] = '8'
            elif services[service_object]['svcObjPort1'] == 'echo-reply':
                services[service_object]['svcObjPort1'] = '0'
            elif services[service_object]['svcObjPort1'] == 'alternative-host':
                services[service_object]['svcObjPort1'] = '6'
            elif services[service_object]['svcObjPort1'] == 'mobile-registration-reply':
                services[service_object]['svcObjPort1'] = '36'
            elif services[service_object]['svcObjPort1'] in ['mobile-registration-request', 'mobile-host-redirect',
                                                             'datagram-error', 'traceroute', 'address-mask-reply',
                                                             'address-mask-request', 'info-reply', 'info-request',
                                                             'timestamp-reply', 'timestamp', 'parameter-problem']:
                services[service_object]['svcObjPort1'] = '99'
                services[service_object]['svcObjPort2'] = '99'

            if services[service_object][
                'svcObjPort2'] == 'echo-request':  ## needed to fix Port2 value for icmp objects read in via sonicwall API
                services[service_object]['svcObjPort2'] = '8'
            elif services[service_object]['svcObjPort2'] == 'echo-reply':
                services[service_object]['svcObjPort2'] = '0'
            elif services[service_object]['svcObjPort2'] == 'alternative-host':
                services[service_object]['svcObjPort2'] = '6'
            elif services[service_object]['svcObjPort2'] == 'mobile-registration-reply':
                services[service_object]['svcObjPort2'] = '36'
            elif services[service_object]['svcObjPort2'] in ['mobile-registration-request', 'mobile-host-redirect',
                                                             'datagram-error', 'traceroute']:
                services[service_object]['svcObjPort2'] = '99'
            try:
                tmp = int(services[service_object]['svcObjPort1'])
            except:
                services[service_object]['svcObjPort1'] = '99'
                services[service_object]['svcObjPort2'] = '99'

            return list(
                range(int(services[service_object]['svcObjPort1']), int(services[service_object]['svcObjPort2']) + 1))
        elif services[service_object]['svcObjType'] == '4':
            for ports in services[service_object]['svcObjPortSet']:
                if re.findall('-', ports) != []:
                    first, last = ports.split('-')
                    portlist.extend(list(range(int(first), int(last) + 1)))
                else:
                    portlist.extend([int(ports)])
        elif services[service_object]['svcObjType'] == '4':  ## add support to get port list for service group
            pass
        return portlist

    return []


def get_src_ports_of(services, service_object):
    ## Given a service object name, will return the L4 protocol number of it.

    import re
    portlist = []
    if service_object == '0':
        return ['any']  # list(range(1))
    if service_object not in services:
        services = config['shared']['services']
    if service_object in services:
        if services[service_object]['svcObjType'] == '1':
            if services[service_object]['svcObjPort1'] == '':
                # debug(services[service_object])
                services[service_object]['svcObjPort1'] = '0'
            if services[service_object]['svcObjPort2'] == '':
                services[service_object]['svcObjPort2'] = services[service_object]['svcObjPort1']
            # log(services[service_object]['svcObjPort1'])
            # log(services[service_object]['svcObjPort2'])
            return list(
                range(int(services[service_object]['svcObjPort1']), int(services[service_object]['svcObjPort2']) + 1))
        elif services[service_object]['svcObjType'] == '4':
            for ports in services[service_object]['svcObjPortSet']:
                if re.findall('-', ports) != []:
                    first, last = ports.split('-')
                    portlist.extend(list(range(int(first), int(last) + 1)))
                else:
                    portlist.extend([int(ports)])
        elif services[service_object]['svcObjType'] == '4':  ## add support to get port list for service group
            pass
        return portlist

    return []


def create_tuples(config, outfile, tuplezone, contexts, policyname=''):
    ## Will create a list of all possible tuples for a policy.  This can be used for testing purposes with another script
    ## For network address objects, it will only output the network address, not every possible combination of addresses in
    ## that network.  If it were to expand the entire network, the resulting list of addresses would likely exceed billions
    ## of possibilities.
    ## It also currently only includes traffic from the WAN zone.
    ## Exclude Multicast?

    import json
    import sys
    srctuplezone, dsttuplezone = tuplezone.split(',')
    from netaddr import IPSet, IPNetwork

    out = open(outfile, 'w')
    stdout = sys.stdout
    sys.stdout = out
    for context in contexts:
        # log(context)
        if context in config:
            # if zones are empty for first policy, assume this is a checkpoint policy and compute src/dst zones for each rule.
            # log('policylen', len(config[context]['policies']))
            if len(config[context]['policies']) > 0:
                # log('policylen', len(config[context]['policies']))
                if config[context]['policies'][1]['policySrcZone'] == []:
                    debug('Build zone information for each rule')
                    for policy_index in config[context]['policies']:
                        if config[context]['policies'][policy_index]['policyName'] in policyname or policyname == ['']:
                            for src_addr in config[context]['policies'][policy_index]['policySrcNet']:
                                if src_addr in config[context]['addresses']:
                                    tmp_zone = None
                                    ## def expand_address(address_dict, address_object, address_map, inc_group=False):
                                    if src_addr.lower() == 'any':
                                        addr_list = []
                                        log('Any source addr')
                                    elif config[context]['addresses'][src_addr]['addrObjType'] == '8':
                                        addr_list = expand_address(config[context]['addresses'], src_addr,
                                                                   config[context]['addressmappings'])
                                    else:
                                        debug(src_addr, config[context]['addresses'][src_addr]['addrObjZone'])
                                        addr_list = [src_addr]
                                    debug(addr_list)
                                    for addr in addr_list:
                                        if config[context]['addresses'][addr]['addrObjZone'] == '':
                                            if config[context]['addresses'][addr]['addrObjType'] == '98':
                                                debug('Group with exception', config[context]['addresses'][addr])
                                                if config[context]['addresses'][addr]['include'].lower() == 'any':
                                                    ip1 = '0.0.0.0'
                                                    debug('Group with exception - any', ip1)
                                                else:
                                                    ip1 = '{}'.format(config[context]['addresses'][
                                                                          config[context]['addresses'][addr][
                                                                              'include']]['IPSet'].iter_cidrs()[0][1])
                                                    debug('Group with exception - not any', ip1)
                                            else:
                                                ip1, ip2 = get_address_of(config[context]['addresses'], addr)
                                            debug('{}-{}-{}'.format('addr', addr, ip1))
                                            if ip1 not in ['', None]:
                                                tmp_zone = get_zone_old(context, '{}'.format(ip1))
                                                config[context]['addresses'][addr]['addrObjZone'] = tmp_zone
                                                debug('Assigning zone {} to object {}'.format(tmp_zone, addr))
                                            else:
                                                debug('Unknown IP1 {} for object {}'.format(ip1, addr))
                                        else:
                                            tmp_zone = config[context]['addresses'][addr]['addrObjZone']
                                        if tmp_zone not in config[context]['policies'][policy_index][
                                            'policySrcZone'] and tmp_zone:
                                            debug('Adding zone {} to policy index {}'.format(tmp_zone, policy_index))
                                            config[context]['policies'][policy_index]['policySrcZone'].append(tmp_zone)
                            debug('sourcezones:', config[context]['policies'][policy_index]['policySrcZone'])
                            for dst_addr in config[context]['policies'][policy_index]['policyDstNet']:
                                if dst_addr in config[context]['addresses']:
                                    tmp_zone = None
                                    ## def expand_address(address_dict, address_object, address_map, inc_group=False):
                                    if dst_addr.lower() == 'any':
                                        addr_list = []
                                    elif config[context]['addresses'][dst_addr]['addrObjType'] == '8':
                                        addr_list = expand_address(config[context]['addresses'], dst_addr,
                                                                   config[context]['addressmappings'])
                                    else:
                                        addr_list = [dst_addr]
                                    for addr in addr_list:
                                        if config[context]['addresses'][addr]['addrObjZone'] == '':
                                            if config[context]['addresses'][addr]['addrObjType'] == '98':
                                                debug('Group with exception', config[context]['addresses'][addr])
                                                if config[context]['addresses'][addr]['include'].lower() == 'any':
                                                    ip1 = '0.0.0.0'
                                                    debug('Group with exception - any', ip1)
                                                else:
                                                    ip1 = '{}'.format(config[context]['addresses'][
                                                                          config[context]['addresses'][addr][
                                                                              'include']]['IPSet'].iter_cidrs()[0][1])
                                                    debug('Group with exception - not any', ip1)
                                            else:
                                                ip1, ip2 = get_address_of(config[context]['addresses'], addr)
                                            # debug('{}-{}-{}'.format('addr', addr, ip1))
                                            if ip1 not in ['', None]:
                                                tmp_zone = get_zone_old(context, '{}'.format(ip1))
                                                config[context]['addresses'][addr]['addrObjZone'] = tmp_zone
                                        else:
                                            tmp_zone = config[context]['addresses'][addr]['addrObjZone']
                                        if tmp_zone not in config[context]['policies'][policy_index][
                                            'policyDstZone'] and tmp_zone:
                                            debug('Adding zone {} to policy index {}'.format(tmp_zone, policy_index))
                                            config[context]['policies'][policy_index]['policyDstZone'].append(tmp_zone)
                        # debug(config[context]['policies'][policy_index]['policySrcZone'])
                        debug('destzones:', config[context]['policies'][policy_index]['policyDstZone'])
                        if config[context]['policies'][policy_index]['policySrcZone'] == [] and \
                                config[context]['policies'][policy_index]['policyDstZone'] == []:
                            debug('Unable to determine source and dest zones for rule index : {}'.format(policy_index))
                            debug(config[context]['policies'][policy_index])
                        elif config[context]['policies'][policy_index]['policySrcZone'] == []:
                            config[context]['policies'][policy_index]['policySrcZone'] = [
                                config[context]['zones']['default']]
                        elif config[context]['policies'][policy_index]['policyDstZone'] == []:
                            config[context]['policies'][policy_index]['policyDstZone'] = [
                                config[context]['zones']['default']]
                else:
                    pass
                    # log(config[context]['policies'][1]['policySrcZone'])

            for policy_index in config[context]['policies']:  # range(0, len(config[context]['policies'])):
                negate_source = config[context]['policies'][policy_index]['policySrcNegate']
                negate_dest = config[context]['policies'][policy_index]['policyDstNegate']

                if config[context]['policies'][policy_index]['policyName'] in policyname or policyname == ['']:
                    if (srctuplezone in config[context]['policies'][policy_index][
                        'policySrcZone'] or srctuplezone.lower() == 'all') and (
                            dsttuplezone in config[context]['policies'][policy_index][
                        'policyDstZone'] or dsttuplezone.lower() == 'all') and \
                            config[context]['policies'][policy_index]['policyProps'] == '0' and \
                            config[context]['policies'][policy_index]['policyEnabled'] == '1':
                        if negate_source:  ## this will break tuple creation for palo and sonicwall until the Negate values are added to configs.
                            source_set = IPSet()
                            for source in config[context]['policies'][policy_index]['policySrcNet']:
                                if config[context]['addresses'][source]['addrObjType'] in ['8',
                                                                                           '98']:  ## Address is group, or group with exception, ipset is already calculated
                                    source_set = source_set | config[context]['addresses'][source]['IPSet']

                                else:
                                    for member in expand_address(config[context]['addresses'], source,
                                                                 config[context]['addressmappings']):
                                        # debug('IPSET', member)
                                        # source_set.add([str(addr))
                                        for addr in config[context]['addresses'][member]['IPv4Networks']:
                                            source_set.add(str(addr))
                            negated_set = IPSet(['0.0.0.0/0']) ^ source_set
                            # log('NEGATED: ')
                            policy_source = []
                            for network in negated_set.iter_cidrs():
                                if len(network) > 8:

                                    if '{}'.format(network).split('/')[0] != '0.0.0.0':
                                        if IPNetwork(network) < IPNetwork('224.0.0.0/3'):
                                            policy_source.append('{}'.format(network[4]))
                                            # log('ADDING NEGATED: {}'.format(network[4]))
                                    else:
                                        policy_source.append('0.0.0.0')
                        elif config[context]['policies'][policy_index]['policySrcNet'] == [''] or \
                                config[context]['policies'][policy_index]['policySrcNet'] in [['any'], ['Any']] or \
                                config[context]['policies'][policy_index]['policySrcNet'] == []:
                            policy_source = ['0.0.0.0']
                        else:
                            policy_source = []
                            for source in config[context]['policies'][policy_index]['policySrcNet']:
                                for member in expand_address(config[context]['addresses'], source,
                                                             config[context]['addressmappings']):
                                    policy_source.append(member)

                        if negate_dest:  ## this will break tuple creation for palo and sonicwall until the Negate values are added to configs.
                            dest_set = IPSet()
                            for dest in config[context]['policies'][policy_index]['policyDstNet']:
                                if config[context]['addresses'][dest]['addrObjType'] in ['8',
                                                                                         '98']:  ## Address is group, or group with exception, ipset is already calculated
                                    dest_set = dest_set | config[context]['addresses'][dest]['IPSet']
                                else:
                                    for member in expand_address(config[context]['addresses'], dest,
                                                                 config[context]['addressmappings']):
                                        # [dest_set.add(str(addr)) for addr in config[context]['addresses'][member]['IPv4Networks'] ]
                                        for addr in config[context]['addresses'][member]['IPv4Networks']:
                                            dest_set.add(str(addr))
                            # for network in IPSet(['0.0.0.0/0']) ^ dest_set:
                            #    log('network:', network)
                            debug('negate_set policy index', policy_index)
                            debug('dest_set before negated', dest_set)
                            negated_set = IPSet(['0.0.0.0/0']) ^ dest_set
                            debug('negated_set after negated', negated_set)
                            policy_dest = []
                            for network in negated_set.iter_cidrs():
                                if len(network) > 8:
                                    if '{}'.format(network).split('/')[0] != '0.0.0.0':
                                        if IPNetwork(network) < IPNetwork('224.0.0.0/3'):
                                            # log('negated', network, '{}'.format(network[4]))
                                            policy_dest.append('{}'.format(network[4]))
                                    else:
                                        policy_dest.append('0.0.0.0')


                        elif config[context]['policies'][policy_index]['policyDstNet'] == [''] or \
                                config[context]['policies'][policy_index]['policyDstNet'] in [['any'], ['Any']] or \
                                config[context]['policies'][policy_index]['policyDstNet'] == []:
                            policy_dest = ['0.0.0.0']
                        else:
                            policy_dest = []
                            for dest in config[context]['policies'][policy_index]['policyDstNet']:
                                for member in expand_address(config[context]['addresses'], dest,
                                                             config[context]['addressmappings']):
                                    policy_dest.append(member)
                        if config[context]['policies'][policy_index]['policyDstSvc'] == [''] or \
                                config[context]['policies'][policy_index]['policyDstSvc'] in [['any'], ['Any']] or \
                                config[context]['policies'][policy_index]['policyDstSvc'] == []:
                            policy_services = ['0']
                        else:
                            policy_services = []
                            for svc in config[context]['policies'][policy_index]['policyDstSvc']:
                                if svc != 'application-default':
                                    for member in expand_service(config[context]['services'], svc,
                                                                 config[context]['servicemappings']):
                                        policy_services.append(member)
                        for source_index in policy_source:
                            # log(source_index)
                            if negate_source:
                                source = '{}'.format(source_index)
                                srcmask = '32'
                                # log('source', source)
                            else:
                                source, srcmask = get_address_of(config[context]['addresses'], source_index)
                            if source != None and source != '':
                                if config[context]['policies'][policy_index]['policySrcZone'] != '':
                                    src_zone = config[context]['policies'][policy_index]['policySrcZone'][0]
                                else:
                                    src_zone = str(get_zone_old(context, '{}'.format(source)))
                                for dest_index in policy_dest:
                                    if negate_dest:
                                        dest = '{}'.format(
                                            dest_index)  ## shouldnt be needed, when building dest_index above, just add it in correctly as a string, or a set (objectname, address) - may be difficult to include names of negated objects, or will need to update routines
                                        destmask = '32'
                                    else:
                                        dest, destmask = get_address_of(config[context]['addresses'],
                                                                        dest_index)  # look into updating routines above to do the lookup directly, and add as a set of (objectname, address)
                                    if dest != None and dest != '':
                                        if config[context]['policies'][policy_index]['policyDstZone'] != '':
                                            dst_zone = config[context]['policies'][policy_index]['policyDstZone'][0]
                                        else:
                                            dst_zone = str(get_zone_old(context, '{}'.format(dest)))
                                        if IPNetwork(source) < IPNetwork('224.0.0.0/3') and IPNetwork(dest) < IPNetwork(
                                                '224.0.0.0/3'):
                                            for service_index in policy_services:
                                                prot = get_prot_of(config[context]['services'], service_index)
                                                port = get_ports_of(config[context]['services'], service_index)
                                                # src_port=get_src_ports_of(config[context]['services'],service_index)
                                                # log('service idx', service_index, prot, port)
                                                if len(port) > 0:
                                                    port = str(port[0])
                                                else:
                                                    port = '0'

                                                try:
                                                    # log(config[context]['services'][service_index])
                                                    if (
                                                            srctuplezone.lower() == src_zone.lower() or srctuplezone.lower() == 'all') and (
                                                            dsttuplezone.lower() == dst_zone.lower() or dsttuplezone.lower() == 'all'):
                                                        log(source + '/' + srcmask + ',' + dest + '/' + destmask + ',' + prot + ',' + port + ',' +
                                                            config[context]['policies'][policy_index][
                                                                'policyAction'] + ',' + str(
                                                            config[context]['policies'][policy_index][
                                                                'policyNum']) + ',' + source_index + ',' + dest_index + ',' + service_index,
                                                            src_zone, dst_zone)
                                                        ## + ',' + str(config[context]['policies'][policy_index]['policyUiNum']) + ',' + str(config[context]['policies'][policy_index]['policyNum']) + ',' + str(config[context]['policies'][policy_index]['policySrcZone']) + ',' + str(config[context]['policies'][policy_index]['policyDstZone']) )
                                                    elif src_zone == "None" or dst_zone == "None":
                                                        log('NONE: src_zone {} src {} dst_zone {} dst {}'.format(
                                                            src_zone, source, dst_zone, dest))
                                                except Exception as e:
                                                    # log(e)
                                                    log('EXCEPTION {}: {}'.format(e, config[context]['services'][
                                                        service_index]))
    out.close()
    sys.stdout = stdout

    return;


def policy_objects_to_list(policy_dict, prop_list):
    ## This converts elements in a sonicwall policy dictionary to a list, to match how it is stored by Palo Alto.
    ## Sonicwall policies can only have a single object per element, but the Palo Alto can have several, so these
    ## items are now stored as a list.

    tmp_dict = policy_dict
    for index in policy_dict:
        for prop in prop_list:
            tmp_dict[index][prop] = [policy_dict[index][prop]]
        if 'policyUUID' not in policy_dict[index]:
            tmp_dict[index]['policyUUID'] = None
            tmp_dict[index]['policySrcNegate'] = False
            tmp_dict[index]['policyDstNegate'] = False
            tmp_dict[index]['policySvcNegate'] = False
    return tmp_dict;


def add_IPv4Network(addresses):
    ## This adds a IPv4Network dictionary entry for Sonicwall configurations after the configuration is read

    import ipaddress
    from netaddr import IPSet

    for address in addresses:
        debug(addresses[address])
        addresses[address]['IPSet'] = IPSet([])
        try:
            if addresses[address]['addrObjType'] == '1':  ## host
                addresses[address]['IPv4Networks'] = [ipaddress.IPv4Network(addresses[address]['addrObjIp1'] + '/32')]
            if addresses[address]['addrObjType'] == '2':  ## range
                addresses[address]['IPv4Networks'] = [ipaddr for ipaddr in ipaddress.summarize_address_range(
                    ipaddress.IPv4Address(addresses[address]['addrObjIp1']),
                    ipaddress.IPv4Address(addresses[address]['addrObjIp2']))]
            if addresses[address]['addrObjType'] == '4':
                bitmask = sum([bin(int(x)).count("1") for x in addresses[address]['addrObjIp2'].split(".")])
                addresses[address]['IPv4Networks'] = [
                    ipaddress.IPv4Network(addresses[address]['addrObjIp1'] + '/' + str(bitmask))]
            if addresses[address]['addrObjType'] == '8':
                addresses[address]['IPv4Networks'] = []
                pass
                # cant do anything with the group at this point
        except:
            pass
        for network in addresses[address]['IPv4Networks']:
            addresses[address]['IPSet'].add('{}'.format(network))
            pass
    return addresses;


def create_config(config, interface_map, outfile, context):
    ## Create a Palo Alto configuration file.  Intended to be used with a Sonicwall source input file.
    ## Not intended to be used for Palo Alto to Palo Alto use.

    import sys
    import re

    if options.zonemaps:
        zone_map = {}
        for zonemap in options.zonemaps:
            old_zone, new_zone = zonemap.split(',')
            zone_map[old_zone.lower()] = new_zone

    out = open(outfile, 'w')
    stdout = sys.stdout
    sys.stdout = out

    # zone_map={}

    '''
    if options.zonemaps:
        for zonemap in options.zonemaps:
            if len(re.findall(',', zonemap))==1:
                zonemap=zonemap.replace(', ',',').replace(' ,',',')
                old_zone, new_zone=zonemap.split(',')
                zone_map[old_zone.lower()]=new_zone
                #zone_map[xls.lower()]['fwzone']=fwzone
                #zone_map[xls.lower()]['policytext']=policytext
                #debug(xls, fwzone, policytext)
    '''

    ## build list of built-in objects that are in use by nat policies
    builtin_map = {}
    builtin_index = 0
    for policy in config['nat']:
        if config['nat'][policy]['natPolicyProperties'] not in ['1023', '17407']:
            for obj_type in ['natPolicyOrigSrc', 'natPolicyOrigDst', 'natPolicyTransSrc', 'natPolicyTransDst']:
                if config['nat'][policy][obj_type][0] != '':
                    if config['addresses'][config['nat'][policy][obj_type][0]]['addrObjProperties'] != '14':
                        if config['nat'][policy][obj_type][0] not in builtin_map:
                            builtin_map[config['nat'][policy][obj_type][0]] = 'BUILTIN_' + sc(
                                config['nat'][policy][obj_type][0])
                            # debug('built-in object {}'.format(config['nat'][policy][obj_type][0]))
                            # debug('built-in object {}'.format(sc(config['nat'][policy][obj_type][0])))
                        if config['addresses'][config['nat'][policy][obj_type][0]]['addrObjType'] == '8':
                            ## def expand_address(address_dict, address_object, address_map, inc_group=False):
                            for addr in expand_address(config['addresses'],
                                                       config['addresses'][config['nat'][policy][obj_type][0]][
                                                           'addrObjId'], config['addressmappings']):
                                if config['addresses'][addr]['addrObjProperties'] != '14':
                                    if addr not in builtin_map:
                                        # debug('built-in group member {}'.format(ss(addr)))
                                        builtin_map[addr] = 'BUILTIN_' + sc(addr)

        '''
        if config['nat'][policy]['natPolicyOrigDst'][0]!='':
            if config['addresses'][config['nat'][policy]['natPolicyOrigDst'][0]]['addrObjProperties'] != '14':
                debug('built-in object {}'.format(config['nat'][policy]['natPolicyOrigDst']))
                if config['nat'][policy]['natPolicyOrigDst'][0] not in builtin_map:
                    builtin_map[config['nat'][policy]['natPolicyOrigDst'][0]]='Temp'
        if config['nat'][policy]['natPolicyTransSrc'][0]!='':
            if config['addresses'][config['nat'][policy]['natPolicyTransSrc'][0]]['addrObjProperties'] != '14':
                debug('built-in object {}'.format(config['nat'][policy]['natPolicyTransSrc']))
                if config['nat'][policy]['natPolicyTransSrc'][0] not in builtin_map:
                    builtin_map[config['nat'][policy]['natPolicyTransSrc'][0]]='Temp'
        if config['nat'][policy]['natPolicyTransDst'][0]!='':
            if config['addresses'][config['nat'][policy]['natPolicyTransDst'][0]]['addrObjProperties'] != '14':
                debug('built-in object {}'.format(config['nat'][policy]['natPolicyTransDst']))
                if config['nat'][policy]['natPolicyTransDst'][0] not in builtin_map:
                    builtin_map[config['nat'][policy]['natPolicyTransDst'][0]]='Temp'
        '''

    log('<config version=\"7.1.0\" urldb=\"paloaltonetworks\">')
    create_logging()
    log('  <devices>')
    log('    <entry name=\"localhost.localdomain\">')
    create_network(config['interfaces'], interface_map, config['zones'], config['routing'], context, zone_map)
    log('      <device-group>')
    log('        <entry name="' + customops.devicegroup_name + '">')
    create_addresses(config['addresses'], config['addressesfqdn'], config['addressmappings'], builtin_map)
    create_services(config['services'], config['servicemappings'])
    log('          <pre-rulebase>')

    create_policies(config['policies'], context, zone_map)
    create_nat(config['nat'], context, zone_map, interface_map, config['interfaces'], builtin_map)
    log('          </pre-rulebase>')
    log('          <profile-group>')
    log('            <entry name="' + customops.rule_profile_setting + '"/>')
    log('          </profile-group>')
    log('        <devices/>')
    log('        </entry>')
    log('      </device-group>')
    log('    </entry>')
    log('  </devices>')
    log('</config>')
    sys.stdout = stdout
    out.close
    return;


def dump_config(config, contexts):
    # Not complete?  There might be cases in with shared objects are not handled correctly?
    # Dynamic column widths by tracking longest length item and calling set_column after data is written?

    import xlsxwriter

    sh_addr = []
    sh_svc = []

    ## Output to XLSX
    path = ''

    for context in contexts:
        log('\r!-- Dumping ' + context + ' to Excel                                                 ')
        workbook = xlsxwriter.Workbook(path + context + '.xlsx')

        xl_policies = workbook.add_worksheet('Policies')
        xl_policies.set_column('A:I', 50)
        xl_policies.set_column('B:B', 15)
        xl_addresses = workbook.add_worksheet('Addresses')
        xl_addresses.set_column('A:H', 50)
        xl_addresses.set_column('C:C', 12)
        xl_addresses.set_column('D:D', 12)
        xl_addresses.set_column('E:E', 20)
        xl_addresses.set_column('F:F', 20)
        xl_addresses.set_column('G:G', 20)
        xl_addressgroups = workbook.add_worksheet('Address Groups')
        xl_addressgroups.set_column('A:H', 50)
        xl_services = workbook.add_worksheet('Services')
        xl_services.set_column('A:H', 50)
        xl_services.set_column('B:B', 15)
        xl_services.set_column('C:C', 15)
        xl_services.set_column('D:D', 15)
        xl_services.set_column('E:E', 12)
        xl_services.set_column('F:F', 12)

        xl_servicegroups = workbook.add_worksheet('Service Groups')
        xl_servicegroups.set_column('A:H', 50)
        xl_networking = workbook.add_worksheet('Networking')
        xl_networking.set_column('A:H', 50)

        ## print headers for each worksheet
        if len(list(config[context]['policies'].keys())) > 0:
            for col, key in enumerate(config[context]['policies'][list(config[context]['policies'].keys())[0]]):
                xl_policies.write(0, col, key)
        xl_addressgroups.write(0, 0, 'Address Mappings')
        xl_servicegroups.write(0, 0, 'Service Mappings')

        xl_addresses.write(0, 0, 'Addresses')
        if len(list(config[context]['addresses'].keys())) > 0:
            for col, key in enumerate(config[context]['addresses'][list(config[context]['addresses'].keys())[0]]):
                xl_addresses.write(0, col, key)
        xl_services.write(0, 0, 'Services')
        row = 1
        if len(list(config[context]['services'].keys())) > 0:
            for col, key in enumerate(config[context]['services'][list(config[context]['services'].keys())[0]]):
                xl_services.write(0, col, key)

        row = 1
        for policy in config[context]['policies']:
            # build list of address and service objects that might be in shared
            for src in config[context]['policies'][policy]['policySrcNet']:
                if src not in config[context]['addresses'] and src in config['shared']['addresses']:
                    if src not in sh_addr:
                        sh_addr.append(src)
            for dst in config[context]['policies'][policy]['policyDstNet']:
                if dst not in config[context]['addresses'] and dst in config['shared']['addresses']:
                    if dst not in sh_addr:
                        sh_addr.append(dst)
            for svc in config[context]['policies'][policy]['policyDstSvc']:
                if svc not in config[context]['services'] and svc in config['shared']['services']:
                    if svc not in sh_svc:
                        sh_svc.append(svc)

            for col, key in enumerate(config[context]['policies'][policy]):
                output = ''
                if type(config[context]['policies'][policy][key]) == list:
                    for index, item in enumerate(config[context]['policies'][policy][key]):
                        # output += item
                        if key in ['policySrcNet', 'policyDstNet', 'policyDstSvc'] and item in ['']:
                            output += 'any'
                        else:
                            output += item
                        if index < len(config[context]['policies'][policy][key]) - 1:
                            output += '\n'
                elif key == 'policyAction':
                    if config[context]['policies'][policy][key] == '0':
                        output = 'Deny'
                    elif config[context]['policies'][policy][key] == '1':
                        output = 'Discard'
                    elif config[context]['policies'][policy][key] == '2':
                        output = 'Allow'
                    else:
                        output = config[context]['policies'][policy][key]
                elif key == 'policyEnabled':
                    if config[context]['policies'][policy][key] == '1':
                        output = 'Enabled'
                    else:
                        output = 'Disabled'
                else:
                    output = str(config[context]['policies'][policy][key])
                if row % 2 == 1:
                    cell_format = workbook.add_format({'bg_color': '#DDDDDD', 'text_wrap': True})
                else:
                    cell_format = workbook.add_format({'bg_color': '#BBBBBB', 'text_wrap': True})
                xl_policies.write(row, col, ss(output), cell_format)
            row += 1

        row = 1
        for map in config[context]['addressmappings']:
            if row % 2 == 1:
                cell_format = workbook.add_format({'bg_color': '#DDDDDD', 'text_wrap': True})
            else:
                cell_format = workbook.add_format({'bg_color': '#BBBBBB', 'text_wrap': True})
            xl_addressgroups.write(row, 0, ss(map), cell_format)
            output = ''
            for index, item in enumerate(config[context]['addressmappings'][map]):
                output += item
                if index < len(config[context]['addressmappings'][map]) - 1:
                    output += '\n'
            xl_addressgroups.write(row, 1, ss(output), cell_format)
            row += 1
        if 'shared' in config:
            for map in config['shared']['addressmappings']:
                if map in sh_addr:
                    if row % 2 == 1:
                        cell_format = workbook.add_format({'bg_color': '#AAAAAA', 'text_wrap': True})
                    else:
                        cell_format = workbook.add_format({'bg_color': '#999999', 'text_wrap': True})
                    xl_addressgroups.write(row, 0, ss(map), cell_format)
                    output = ''
                    for index, item in enumerate(config['shared']['addressmappings'][map]):
                        output += item
                        if index < len(config['shared']['addressmappings'][map]) - 1:
                            output += '\n'

                    xl_addressgroups.write(row, 1, ss(output), cell_format)
                    row += 1

        row = 1
        for map in config[context]['servicemappings']:
            if row % 2 == 1:
                cell_format = workbook.add_format({'bg_color': '#DDDDDD', 'text_wrap': True})
            else:
                cell_format = workbook.add_format({'bg_color': '#BBBBBB', 'text_wrap': True})
            xl_servicegroups.write(row, 0, ss(map), cell_format)
            output = ''
            for index, item in enumerate(config[context]['servicemappings'][map]):
                output += item
                if index < len(config[context]['servicemappings'][map]) - 1:
                    output += '\n'
            xl_servicegroups.write(row, 1, ss(output), cell_format)
            row += 1
        if 'shared' in config:
            for map in config['shared']['servicemappings']:
                if map in sh_svc:
                    xl_servicegroups.write(row, 0, map)
                    output = ''
                    for index, item in enumerate(config['shared']['servicemappings'][map]):
                        output += item
                        if index < len(config['shared']['servicemappings'][map]) - 1:
                            output += '\n'
                    if row % 2 == 1:
                        cell_format = workbook.add_format({'bg_color': '#AAAAAA', 'text_wrap': True})
                    else:
                        cell_format = workbook.add_format({'bg_color': '#999999', 'text_wrap': True})
                    xl_servicegroups.write(row, 1, ss(output), cell_format)
                    row += 1
        row = 1
        for address in config[context]['addresses']:
            for col, key in enumerate(config[context]['addresses'][address]):
                if key == 'addrObjType':
                    if config[context]['addresses'][address][key] == '1':
                        output = 'Host'
                    elif config[context]['addresses'][address][key] == '2':
                        output = 'Range'
                    elif config[context]['addresses'][address][key] == '4':
                        output = 'Network'
                    elif config[context]['addresses'][address][key] == '8':
                        output = 'Group'
                    else:
                        output = config[context]['addresses'][address][key]
                elif key == 'addrObjProperties':
                    if config[context]['addresses'][address][key] == '14':
                        output = 'User Defined'
                    else:
                        output = config[context]['addresses'][address][key]
                else:
                    output = str(config[context]['addresses'][address][key])
                if row % 2 == 1:
                    cell_format = workbook.add_format({'bg_color': '#DDDDDD', 'text_wrap': True})
                else:
                    cell_format = workbook.add_format({'bg_color': '#BBBBBB', 'text_wrap': True})
                xl_addresses.write(row, col, ss(output), cell_format)
            row += 1
        if 'shared' in config:
            for address in sh_addr:
                if address in config['shared']['addresses']:
                    for col, key in enumerate(config['shared']['addresses'][address]):
                        if key == 'addrObjType':
                            if config['shared']['addresses'][address][key] == '1':
                                output = 'Host'
                            elif config['shared']['addresses'][address][key] == '2':
                                output = 'Range'
                            elif config['shared']['addresses'][address][key] == '4':
                                output = 'Network'
                            elif config['shared']['addresses'][address][key] == '8':
                                output = 'Group'
                            else:
                                output = config['shared']['addresses'][address][key]
                        elif key == 'addrObjProperties':
                            if config['shared']['addresses'][address][key] == '14':
                                output = 'User Defined'
                            else:
                                output = config['shared']['addresses'][address][key]
                        else:
                            output = str(config['shared']['addresses'][address][key])
                        if row % 2 == 1:
                            cell_format = workbook.add_format({'bg_color': '#AAAAAA', 'text_wrap': True})
                        else:
                            cell_format = workbook.add_format({'bg_color': '#999999', 'text_wrap': True})
                        xl_addresses.write(row, col, ss(output), cell_format)
                    row += 1
        row = 1

        for service in config[context]['services']:
            for col, key in enumerate(config[context]['services'][service]):
                if key == 'svcObjType':
                    if config[context]['services'][service][key] == '1':
                        output = 'Service'
                    elif config[context]['services'][service][key] == '2':
                        output = 'Service Group'
                    else:
                        output = config[context]['services'][service][key]
                elif key == 'svcObjProperties':
                    if config[context]['services'][service][key] == '14':
                        output = 'User Defined'
                    else:
                        output = config[context]['services'][service][key]
                elif key == 'svcObjIpType':
                    if config[context]['services'][service][key] == '6':
                        output = 'TCP'
                    elif config[context]['services'][service][key] == '17':
                        output = 'UDP'
                    elif config[context]['services'][service][key] == '0':
                        output = 'Service Group'
                    else:
                        output = 'Other'
                else:
                    # debug('col:' + str(col))
                    # debug('key: ' + str(key))
                    # debug(config[context]['services'][service])
                    # debug(config[context]['services'][service][key])
                    if key in config[context]['services'][service]:
                        output = str(config[context]['services'][service][key])
                    pass
                if row % 2 == 1:
                    cell_format = workbook.add_format({'bg_color': '#DDDDDD', 'text_wrap': True})
                else:
                    cell_format = workbook.add_format({'bg_color': '#BBBBBB', 'text_wrap': True})
                xl_services.write(row, col, ss(output), cell_format)
            row += 1
        if 'shared' in config:
            for service in sh_svc:
                if service in config['shared']['services']:
                    for col, key in enumerate(config['shared']['services'][service]):
                        if key == 'svcObjType':
                            if config['shared']['services'][service][key] == '1':
                                output = 'Service'
                            elif config['shared']['services'][service][key] == '2':
                                output = 'Service Group'
                            else:
                                output = config['shared']['services'][service][key]
                        elif key == 'svcObjProperties':
                            if config['shared']['services'][service][key] == '14':
                                output = 'User Defined'
                            else:
                                output = config['shared']['services'][service][key]
                        elif key == 'svcObjIpType':
                            if config['shared']['services'][service][key] == '6':
                                output = 'TCP'
                            elif config['shared']['services'][service][key] == '17':
                                output = 'UDP'
                            elif config['shared']['services'][service][key] == '0':
                                output = 'Service Group'
                            else:
                                output = 'Other'
                        else:
                            output = str(config['shared']['services'][service][key])
                        if row % 2 == 1:
                            cell_format = workbook.add_format({'bg_color': '#AAAAAA', 'text_wrap': True})
                        else:
                            cell_format = workbook.add_format({'bg_color': '#999999', 'text_wrap': True})
                        xl_services.write(row, col, ss(output), cell_format)
                    row += 1

        workbook.close()


def find_ip_address(config, ip_address_list, context_list, exact=False):
    ##  Given an IP address, find all the address and address-group objects that contain the address

    return_list = []
    import ipaddress
    import re

    for ip_to_find in ip_address_list:
        if re.findall('/', ip_to_find):
            ipaddr, netmask = ip_to_find.split('/')
        else:
            ipaddr = ip_to_find
            netmask = '32'
        log("=" * 120)
        log('Searching for IP address : ' + ip_to_find)
        for context in context_list:
            found = False
            if context in config:
                ## only print this header if something is found in each context

                for address_index in config[context]['addresses']:
                    if 'addrObjId' in config[context]['addresses'][address_index] and 'addressmappings' in config[
                        context]:
                        for expanded_index in expand_address(config[context]['addresses'],
                                                             config[context]['addresses'][address_index]['addrObjId'],
                                                             config[context]['addressmappings']):
                            for network in config[context]['addresses'][expanded_index]['IPv4Networks']:
                                if ((ipaddress.IPv4Network(ipaddr + '/' + netmask, strict=False).overlaps(
                                        network) or network.overlaps(ipaddress.IPv4Network(ipaddr + '/' + netmask,
                                                                                           strict=False))) and not exact) or (
                                        ipaddress.IPv4Network(ipaddr + '/' + netmask,
                                                              strict=False) == network and exact):
                                    if network != ipaddress.IPv4Network('0.0.0.0/0') or options.zero_network:
                                        if found == False:
                                            found = True
                                            log('-' * 120)
                                            log('%-40s :' % ' Device Group', end='')
                                            log('%-40s :' % ' Root Object Name', end='')
                                            log('%-40s' % ' Member Address Object')
                                            log('-' * 120)
                                        log('%-40s : ' % context, end='')
                                        log('%-40s : ' % config[context]['addresses'][address_index]['addrObjId'],
                                            end='')
                                        log('%-40s : ' % expanded_index, end='')
                                        log('%-40s' % config[context]['addresses'][address_index]['addrObjComment'])

                                        return_list.append(expanded_index)
            else:
                log('Device Group (context)' + context + ' not found, Skipped!')
    return return_list;


def find_service(config, search_list, context_list, exact=False):
    ## Given a service definition "protocol/port", find all the service and service-group objects that contain the service
    return_list = []
    for service_to_find in search_list:
        prot, port = service_to_find.split('/')
        log('-' * 120)
        log('%-40s : ' % 'Device Group', end='')
        log('%-40s : ' % 'Root Object Name', end='')
        log('%-40s' % 'Member Service Object')
        log('-' * 120)

        ## svcPortSet FIX

        for context in context_list:
            for service_index in config[context]['services']:
                for expanded_index in expand_service(config[context]['services'],
                                                     config[context]['services'][service_index]['svcObjId'],
                                                     config[context]['servicemappings']):
                    # start, end = get_port_of(config[context]['services'],expanded_index)
                    portlist = get_ports_of(config[context]['services'], expanded_index)
                    # start=int(start)
                    # end=int(end)
                    if (prot.lower() == get_prot_of(config[context]['services'], expanded_index)):
                        if (int(port) in portlist and not exact) or (
                                config[context]['services'][service_index]['svcObjType'] == '1' and [
                            int(port)] == portlist and exact):
                            log('%-40s : ' % context, end='')
                            log('%-40s : ' % config[context]['services'][service_index]['svcObjId'], end='')
                            log('%-40s' % expanded_index)
                            return_list.append(expanded_index)
    return return_list;


def show_found_ips(config, search_list, context_list):
    return


def show_found_services(config, search_list, contexts):
    return


def find_matching_rules(config, shared, params, contextnames, modify=None):
    ## redo this using IPset like I do for inverse matching

    import ipaddress
    import re
    from netaddr import IPSet
    from urllib.parse import unquote as url_unquote

    if params[0].count(',') != 2:
        log('Search string must contain exactly 3 fields source_ip,destination_ip,service')
        return False
    log('!-- Finding matching rules ' + str(params))
    if modify:
        log(modify)
        if len(modify.split(',')) > 1:
            modify_group, modify_addr = modify.split(',', 1)
            if len(modify_addr.split(',')) > 1:
                modify_addr = modify_addr.split(',')
            else:
                modify_addr = [modify_addr]
        else:
            modify = None

        ## verify that each of the address objects exists

        # for addr in modify_addr:
        # addr_found=False
        #   for context in contexts:
        #       if addr in config[context]['addresses']:
        #           addr_found=True
        #           break
        #       else:
        #           log('Address not available')
        #    if not addr_found:
        #        modify=None
        #        break

    source, dest, service = params[0].split(',')

    # log(params[0])

    if source.lower() == 'any':
        source = '0.0.0.0/0'
        log('setting source to 0.0.0.0')
    if re.findall('/', source) != []:
        src_ipaddr, src_netmask = source.split('/')
    else:
        src_ipaddr = source
        src_netmask = '32'
    sourceIPv4 = ipaddress.IPv4Network(src_ipaddr + '/' + src_netmask, strict=False)
    firstsource = sourceIPv4[0]
    lastsource = sourceIPv4[-1]

    if dest.lower() == 'any':
        dest = '0.0.0.0/0'
        log('setting dest to 0.0.0.0')
    if re.findall('/', dest):
        dst_ipaddr, dst_netmask = dest.split('/')
    else:
        dst_ipaddr = dest
        dst_netmask = '32'
    destIPv4 = ipaddress.IPv4Network(dst_ipaddr + '/' + dst_netmask, strict=False)
    firstdest = destIPv4[0]
    lastdest = destIPv4[-1]

    if service.lower() == 'any':
        service = 'any/any'
    prot, port = service.split('/')
    try:
        portnum = int(port)
    except:
        if port == 'any': portnum = 0
    return_list = []

    nomatches = []
    for context in contextnames:
        policymatches = 0
        if 'policies' in config[context]:
            for policy in config[context]['policies']:
                log(config[context]['policies'][policy])
                if (config[context]['config']['fw_type'] == 'checkpoint' and config[context]['policies'][policy][
                    'policyName'] in options.policynames) or config[context]['config']['fw_type'] != 'checkpoint' or \
                        options.policynames[0].lower() in ['', 'any', 'all']:
                    if (len(set(config[context]['policies'][policy]['policySrcZone']) & set(
                            config[context]['usedzones'])) > 0 or config[context]['usedzones'] == []) and (
                            len(set(config[context]['policies'][policy]['policyDstZone']) & set(
                                    config[context]['usedzones'])) > 0 or config[context]['usedzones'] == []):
                        found_in_source = False
                        found_in_dest = False
                        found_in_service = False
                        prefix = ''
                        if source == '0.0.0.0/0':  # and options.zero_network: -- not applicable here
                            found_in_source = True
                            if len(config[context]['policies'][policy]['policySrcNet']) >= 1:
                                source_addr = config[context]['policies'][policy]['policySrcNet']
                                if source_addr == ['']: source_addr = ['Any']
                            else:
                                source_addr = ['Any']
                        else:
                            for source_index in config[context]['policies'][policy]['policySrcNet']:
                                if source_index.lower() == 'any' and options.zero_network:
                                    found_in_source = True
                                    source_addr = ['Any']
                                    break
                                policyIPv4_list = []
                                if (source_index in config[context]['addresses']):
                                    for expanded_index in expand_address(config[context]['addresses'],
                                                                         config[context]['addresses'][source_index][
                                                                             'addrObjId'],
                                                                         config[context]['addressmappings']):
                                        if (expanded_index in config[context]['addresses']):
                                            policyIPv4_list.extend(
                                                config[context]['addresses'][expanded_index]['IPv4Networks'])
                                        elif (expanded_index in shared['addresses']):
                                            policyIPv4_list.extend(shared['addresses'][expanded_index]['IPv4Networks'])
                                elif (source_index in shared['addresses']):
                                    for expanded_index in expand_address(shared['addresses'],
                                                                         shared['addresses'][source_index]['addrObjId'],
                                                                         shared['addressmappings']):
                                        policyIPv4_list.extend(shared['addresses'][expanded_index]['IPv4Networks'])
                                        prefix = '*'
                                else:
                                    try:
                                        if re.findall('-', source_index) != []:
                                            first, last = source_index.split('-')
                                            for x in ipaddress.summarize_address_range(ipaddress.IPv4Address(first),
                                                                                       ipaddress.IPv4Address(last)):
                                                policyIPv4_list.extend([x])
                                        else:
                                            first = source_index
                                            last = source_index
                                            if re.findall('/', first) == []:
                                                first = first + '/32'
                                            policyIPv4_list.extend([ipaddress.IPv4Network(first)])
                                    except Exception as e:
                                        pass

                                polSet = IPSet([])
                                srcSet = IPSet([])
                                for x in policyIPv4_list:
                                    polSet.add(str(x))
                                srcSet.add(sourceIPv4.with_netmask)
                                if (srcSet & polSet) or ((
                                                                 source_index.lower() == 'any' or source.lower() == '0.0.0.0/0') and options.zero_network):
                                    found_in_source = True
                                    source_addr = config[context]['policies'][policy]['policySrcNet']
                                    break
                        if found_in_source:
                            prefix = ''
                            if dest == '0.0.0.0/0':  # and options.zero_network: -- not applicable here
                                found_in_dest = True
                                if len(config[context]['policies'][policy]['policyDstNet']) >= 1:
                                    dest_addr = config[context]['policies'][policy]['policyDstNet']
                                    if dest_addr == ['']: dest_addr = ['Any']
                                else:
                                    dest_addr = ['Any']
                            else:
                                for dest_index in config[context]['policies'][policy]['policyDstNet']:
                                    if dest_index.lower() == 'any' and options.zero_network:
                                        found_in_dest = True
                                        dest_addr = ['Any']
                                        break
                                    policyIPv4_list = []
                                    if (dest_index in config[context]['addresses']):
                                        for expanded_index in expand_address(config[context]['addresses'],
                                                                             config[context]['addresses'][dest_index][
                                                                                 'addrObjId'],
                                                                             config[context]['addressmappings']):
                                            if (expanded_index in config[context]['addresses']):
                                                policyIPv4_list.extend(
                                                    config[context]['addresses'][expanded_index]['IPv4Networks'])
                                            elif (expanded_index in shared['addresses']):
                                                policyIPv4_list.extend(
                                                    shared['addresses'][expanded_index]['IPv4Networks'])
                                    elif (dest_index in shared['addresses']):
                                        for expanded_index in expand_address(shared['addresses'],
                                                                             shared['addresses'][dest_index][
                                                                                 'addrObjId'],
                                                                             shared['addressmappings']):
                                            policyIPv4_list.extend(shared['addresses'][expanded_index]['IPv4Networks'])
                                            prefix = '*'
                                    else:
                                        try:
                                            if re.findall('-', dest_index) != []:
                                                first, last = dest_index.split('-')
                                                for x in ipaddress.summarize_address_range(ipaddress.IPv4Address(first),
                                                                                           ipaddress.IPv4Address(last)):
                                                    policyIPv4_list.extend([x])
                                            else:
                                                first = dest_index
                                                last = dest_index
                                                if re.findall('/', first) == []:
                                                    first = first + '/32'
                                                policyIPv4_list.extend([ipaddress.IPv4Network(first)])
                                        except Exception as e:
                                            pass
                                    polSet = IPSet([])
                                    destSet = IPSet([])
                                    for x in policyIPv4_list: polSet.add(str(x))
                                    destSet.add(destIPv4.with_netmask)
                                    if (polSet & destSet) or ((
                                                                      dest_index.lower() == 'any' or dest.lower() == '0.0.0.0/0') and options.zero_network):
                                        found_in_dest = True
                                        dest_addr = config[context]['policies'][policy]['policyDstNet']
                                        break;

                        if found_in_dest:
                            # perform checking of service
                            # verify that get port of icmp returns "any"
                            if (config[context]['policies'][policy]['policyDstSvc'] == [
                                ''] and options.zero_network) or (
                                    [x.lower() for x in config[context]['policies'][policy]['policyDstSvc']] == [
                                'any'] and options.zero_network) or config[context]['policies'][policy][
                                'policyDstSvc'] == ['application-default']:
                                found_in_service = True
                                if config[context]['policies'][policy]['policyDstSvc'] == ['']:
                                    dest_service = ['any']
                                else:
                                    dest_service = config[context]['policies'][policy]['policyDstSvc']
                            elif service == 'any/any' and options.zero_network:
                                found_in_service = True
                                dest_service = config[context]['policies'][policy]['policyDstSvc']
                            else:
                                for dest_index in config[context]['policies'][policy]['policyDstSvc']:
                                    if (dest_index in config[context]['services']):
                                        for expanded_index in expand_service(config[context]['services'],
                                                                             config[context]['services'][dest_index][
                                                                                 'svcObjId'],
                                                                             config[context]['servicemappings']):
                                            policy_prot = get_prot_of(config[context]['services'], expanded_index)
                                            # start_port, end_port = get_port_of(config[context]['services'],expanded_index)
                                            policy_ports = get_ports_of(config[context]['services'], expanded_index)
                                            # if start_port=='': start_port='0'
                                            # if end_port=='': end_port='0'

                                            try:
                                                if ((prot.lower() == policy_prot or prot.lower() == 'any') and (
                                                        int(portnum) in policy_ports)) or (
                                                        dest_index.lower() == 'any' and options.zero_network) or (
                                                        service.lower() == 'any/any' and options.zero_network):
                                                    if found_in_service == False:
                                                        found_in_service = True
                                                        dest_service = config[context]['policies'][policy][
                                                            'policyDstSvc']
                                                        break
                                            except Exception as e:
                                                # print(type(prot.lower()))
                                                print(prot.lower())

                                                # print(type(policy_prot))
                                                print(policy_prot)
                                                print("'" + start_port + "'")
                                                print(end_port)
                                                print(expanded_index)
                                                log(e)

                                    if (dest_index in shared['services']):
                                        for expanded_index in expand_service(shared['services'],
                                                                             shared['services'][dest_index]['svcObjId'],
                                                                             shared['servicemappings']):
                                            policy_prot = get_prot_of(shared['services'], expanded_index).lower()
                                            # start_port, end_port = get_port_of(shared['services'],expanded_index)
                                            policy_ports = get_ports_of(config[context]['services'], expanded_index)
                                            # if start_port=='': start_port='0'
                                            # if end_port=='': end_port='0'
                                            if ((
                                                        prot.lower() == policy_prot or prot.lower() == 'any') and portnum in policy_ports) or dest_index.lower() == 'any' or (
                                                    service.lower() == 'any/any' and options.zero_network):
                                                if found_in_service == False:
                                                    found_in_service = True
                                                    dest_service = config[context]['policies'][policy]['policyDstSvc']
                                                    break

                        if found_in_source and found_in_dest and found_in_service:
                            # I believe zone/net/service is empty if "any", so temporarily set these values to variables before printing them
                            if config[context]['policies'][policy]['policyEnabled'] == '0':
                                enabled = "."
                            elif config[context]['policies'][policy]['policyEnabled'] == '1':
                                if not options.web:
                                    enabled = u'\u2713'
                                else:
                                    enabled = 'Y'
                            if config[context]['policies'][policy]['policyAction'] == '0':
                                action = 'deny'
                            elif config[context]['policies'][policy]['policyAction'] == '1':
                                action = 'discard'
                            elif config[context]['policies'][policy]['policyAction'] == '2':
                                action = 'allow'
                            elif config[context]['policies'][policy]['policyAction'] == '3':
                                action = 'CltAuth'
                            name = config[context]['policies'][policy]['policyName']

                            if config[context]['policies'][policy]['policySrcZone'] == []:
                                source_zone = ['any']
                            else:
                                source_zone = config[context]['policies'][policy]['policySrcZone']

                            if config[context]['policies'][policy]['policyDstZone'] == []:
                                dest_zone = ['any']
                            else:
                                dest_zone = config[context]['policies'][policy]['policyDstZone']

                            policymatches += 1

                            if config[context]['policies'][policy]['policySrcZone'] == [] or \
                                    config[context]['policies'][policy]['policySrcZone'] == ['']:
                                source_zones = ['any']
                            else:
                                source_zones = config[context]['policies'][policy]['policySrcZone']

                            if config[context]['policies'][policy]['policyDstZone'] == [] or \
                                    config[context]['policies'][policy]['policyDstZone'] == ['']:
                                dest_zones = ['any']
                            else:
                                dest_zones = config[context]['policies'][policy]['policyDstZone']

                            if config[context]['policies'][policy]['policySrcNet'] == [] or \
                                    config[context]['policies'][policy]['policySrcNet'] == ['']:
                                source_nets = ['any']
                            else:
                                source_nets = config[context]['policies'][policy]['policySrcNet']

                            if config[context]['policies'][policy]['policyDstNet'] == [] or \
                                    config[context]['policies'][policy]['policyDstNet'] == ['']:
                                dest_nets = ['any']
                            else:
                                dest_nets = config[context]['policies'][policy]['policyDstNet']

                            if config[context]['policies'][policy]['policyDstSvc'] == [] or \
                                    config[context]['policies'][policy]['policyDstSvc'] == ['']:
                                dest_services = ['any']
                            else:
                                dest_services = config[context]['policies'][policy]['policyDstSvc']

                            if options.web:
                                if policymatches == 1:
                                    log('<p align=cneter><font size=8 >')
                                    log('context: ' + context)
                                    log('</font></p>')
                                    log('<table border="1" width="90%">')
                                    if config[context]['config']['fw_type'] == 'checkpoint':
                                        log('<th>Enabled</th><th>Action</th><th>Name</th><th>Source Zone</th><th>Dest Zone</th><th>Source Address</th><th>Destination Address</th><th>Service</th>')
                                    else:
                                        log('<th>Enabled</th><th>Action</th><th>Name</th><th>UiNum</th><th>IndexNum</th><th>Source Address</th><th>Destination Address</th><th>Service</th>')
                                if enabled != "Y":
                                    trcolor = '#aaaaaa'
                                elif action.lower() == 'allow':
                                    trcolor = '#00aa00'
                                else:
                                    trcolor = '#aa0000'
                                log('<tr bgcolor="' + trcolor + '">')
                                log('<td>' + enabled + '</td>')
                                log('<td>' + action + '</td>')
                                log('<td>' + name + '</td>')
                                ## only do src/dest zones for non-checkpoint
                                ## for checkpoint, add ruleUI number
                                if config[context]['config']['fw_type'] == 'checkpoint':
                                    log('<td>' + str(config[context]['policies'][policy]['policyUiNum']) + '</td>')
                                    log('<td>' + str(config[context]['policies'][policy]['policyNum']) + '</td>')
                                else:
                                    log('<td>')
                                    for source_zone in source_zones:
                                        log(url_unquote(source_zone) + '<br>')
                                    log('</td>')
                                    log('<td>')
                                    for dest_zone in dest_zones:
                                        log(url_unquote(dest_zone) + '<br>')
                                    log('</td>')
                                log('<td>')
                                for source_address in source_nets:
                                    log(url_unquote(source_address) + '<br>')
                                log('</td>')
                                log('<td>')
                                for dest_address in dest_nets:
                                    log(url_unquote(dest_address) + '<br>')
                                log('</td>')
                                log('<td>')
                                for dest_service in dest_services:
                                    log(url_unquote(dest_service) + '<br>')
                                log('</td>')
                                log('<tr>')

                            else:
                                if policymatches == 1:
                                    log('Context : ' + context)
                                    if config[context]['config']['fw_type'] == 'checkpoint':
                                        log('{:2.2s} {:8.8s} {:15.15s} {:30.30s} {:8.8s} {:8.8s} {:40.40s} {:40.40s} {:40.40s}'.format(
                                            'En', 'Action', 'CMA', 'Policy Name', 'Rule UI#', 'Rule Idx',
                                            'Source Address', 'Destination Address', 'Service'))
                                    else:
                                        log('{:2.2s} {:8.8s} {:30.30s} {:20.20s} {:20.20s} {:40.40s} {:40.40s} {:40.40s}'.format(
                                            'En', 'Action', 'Rule Name', 'Source Zone', 'Destination Zone',
                                            'Source Address', 'Destination Address', 'Service'))
                                    log('=' * 200)
                                if config[context]['config']['fw_type'] == 'checkpoint':
                                    log('{:2.2s} {:8.8s} {:15.15s} {:30.30s} {:8.8s} {:8.8s} {:40.40s} {:40.40s} {:40.40s}'.format(
                                        enabled, action, context, url_unquote(name),
                                        str(config[context]['policies'][policy]['policyUiNum']),
                                        str(config[context]['policies'][policy]['policyNum']),
                                        url_unquote(source_addr[0]), url_unquote(dest_addr[0]),
                                        url_unquote(dest_service[0])))
                                else:
                                    log('{:2.2s} {:8.8s} {:30.30s} {:20.20s} {:20.20s} {:40.40s} {:40.40s} {:40.40s}'.format(
                                        enabled, action, url_unquote(name), url_unquote(source_zone[0]),
                                        url_unquote(dest_zone[0]), url_unquote(source_addr[0]),
                                        url_unquote(dest_addr[0]), url_unquote(dest_service[0])))
                                longestval = max(len(source_addr), len(dest_addr), len(dest_service))
                                if longestval > 1:
                                    for index in range(1, longestval):
                                        tmpsrc = ''
                                        tmpdst = ''
                                        tmpsvc = ''
                                        if index < len(source_addr):
                                            tmpsrc = source_addr[index]
                                        if index < len(dest_addr):
                                            tmpdst = dest_addr[index]
                                        if index < len(dest_service):
                                            tmpsvc = dest_service[index]
                                        if config[context]['config']['fw_type'] == 'checkpoint':
                                            log('{:2.2s} {:8.8s} {:15.15s} {:30.30s} {:8.8s} {:8.8s} {:40.40s} {:40.40s} {:40.40s}'.format(
                                                '', '', '', '', '', '', url_unquote(tmpsrc), url_unquote(tmpdst),
                                                url_unquote(tmpsvc)))
                                        else:
                                            log('{:2.2s} {:8.8s} {:30.30s} {:20.20s} {:20.20s} {:40.40s} {:40.40s} {:40.40s}'.format(
                                                '', '', '', '', '', url_unquote(tmpsrc), url_unquote(tmpdst),
                                                url_unquote(tmpsvc)))
                                log('-' * 200)
                                if modify:
                                    if modify_group not in config[context]['policies'][policy]['policyDstNet']:
                                        for addr in modify_addr:
                                            log('addelement fw_policies {} rule:{}:dst:\'\' network_objects:{}'.format(
                                                url_unquote(name), config[context]['policies'][policy]['policyNum'],
                                                addr))
                                    else:
                                        log('Rule already contains group: ' + modify_group)

            if policymatches != 0 and options.web:
                log('</table>')
                log('<hr>')

            if policymatches == 0:
                nomatches.append(context)

    log('No matches were found for the following contexts')
    for nomatch in nomatches:
        log(nomatch)
        if options.web: log('<br>')
    return


def find_matching_rules2(config, shared, params_list, contextnames, modify=None):
    ## redo this using IPset like I do for inverse matching

    import ipaddress
    import re
    from netaddr import IPSet
    from urllib.parse import unquote as url_unquote
    import codecs

    ##CHANGEME - move excluded addresses to a CLI option

    excluded_addresses = []
    excluded_addresses = options.excludeaddress
    excluded_src_networks = IPSet([addr for addr in options.excludesrcnetwork])
    excluded_dst_networks = IPSet([addr for addr in options.excludedstnetwork])
    # log(excluded_networks)

    # ['Net_10.0.0.0', 'DellNets', 'glbl-Dell_Internal_Networks', 'DellNets-Only', 'Dell-10.0.0.0', 'Net10', 'Dell-DMS-Users', 'DellAssignedNets-NonDell', 'DC-Networks']

    for params in params_list:
        if params.count(',') != 2:
            log('Search string must contain exactly 3 fields source_ip,destination_ip,service')
            return False
        log('!-- Finding matching rules ' + str(params))
        if modify:
            log(modify)
            if len(modify.split(',')) > 1:
                modify_group, modify_addr = modify.split(',', 1)
                if len(modify_addr.split(',')) > 1:
                    modify_addr = modify_addr.split(',')
                else:
                    modify_addr = [modify_addr]
            else:
                modify = None

            ## verify that each of the address objects exists

            # for addr in modify_addr:
            # addr_found=False
            #   for context in contexts:
            #       if addr in config[context]['addresses']:
            #           addr_found=True
            #           break
            #       else:
            #           log('Address not available')
            #    if not addr_found:
            #        modify=None
            #        break

        source, dest, service = params.split(',')

        if source.lower() == 'any':
            source = '0.0.0.0/0'
        if re.findall('/', source) != []:
            src_ipaddr, src_netmask = source.split('/')
        else:
            src_ipaddr = source
            src_netmask = '32'
        sourceIPv4 = ipaddress.IPv4Network(src_ipaddr + '/' + src_netmask, strict=False)
        firstsource = sourceIPv4[0]
        lastsource = sourceIPv4[-1]

        if dest.lower() == 'any':
            dest = '0.0.0.0/0'
        if re.findall('/', dest):
            dst_ipaddr, dst_netmask = dest.split('/')
        else:
            dst_ipaddr = dest
            dst_netmask = '32'
        destIPv4 = ipaddress.IPv4Network(dst_ipaddr + '/' + dst_netmask, strict=False)
        firstdest = destIPv4[0]
        lastdest = destIPv4[-1]

        if service.lower() == 'any':
            service = 'any/any'
        prot, port = service.split('/')
        try:
            portnum = int(port)
        except:
            if port == 'any': portnum = 0
        return_list = []

        nomatches = []
        # if options.csv:
        #    with codecs.open('/opt/scripts/downloads/rulematch.csv', 'w', 'utf-8') as outfile:
        #        pass
        for context in contextnames:
            log(context)
            policymatches = 0
            if 'policies' in config[context]:
                for policy in config[context]['policies']:
                    source_match_type = None
                    dest_match_type = None
                    if 'policySrcNegate' in config[context]['policies'][policy]:
                        negate_source = config[context]['policies'][policy]['policySrcNegate']
                    else:
                        negate_source = False
                    if negate_source:
                        pass
                        # log('SOURCE NEGATED Idx: {} UI: {} '.format(str(config[context]['policies'][policy]['policyNum']), str(config[context]['policies'][policy]['policyUiNum'])))
                    if 'policyDstNegate' in config[context]['policies'][policy]:
                        negate_dest = config[context]['policies'][policy]['policyDstNegate']
                    else:
                        negate_dest = False

                    if (config[context]['config']['fw_type'] == 'checkpoint' and config[context]['policies'][policy][
                        'policyName'] in options.policynames) or config[context]['config']['fw_type'] != 'checkpoint' or \
                            options.policynames[0].lower() in ['', 'any', 'all']:

                        # log(config[context]['usedzones'])
                        # if (len(set(config[context]['policies'][policy]['policySrcZone']) & set(config[context]['usedzones']))>0 or config[context]['usedzones']==[]  ) and (len(set(config[context]['policies'][policy]['policyDstZone']) & set(config[context]['usedzones']))>0 or config[context]['usedzones']==[]) or config[context]['config']['fw_type']=='checkpoint':
                        # log(config[context]['policies'][policy])
                        # log('jeff')
                        found_in_source = False
                        found_in_dest = False
                        found_in_service = False
                        prefix = ''
                        source_found_index = []
                        if source == '0.0.0.0/0':  # and options.zero_network: -- not applicable here
                            found_in_source = True
                            source_match_type = "Any"
                            if len(config[context]['policies'][policy]['policySrcNet']) >= 1:
                                source_addr = config[context]['policies'][policy]['policySrcNet']
                                if source_addr == ['']: source_addr = ['Any']
                            else:
                                source_addr = ['Any']
                        else:
                            for source_index in config[context]['policies'][policy]['policySrcNet']:
                                if source_index.lower() in ['any', ''] and options.zero_network:
                                    found_in_source = True
                                    source_addr = ['Any']
                                    break
                                policyIPv4_list = []
                                if source_index not in excluded_addresses:
                                    if (source_index in config[context]['addresses']):
                                        for expanded_index in expand_address(config[context]['addresses'],
                                                                             config[context]['addresses'][source_index][
                                                                                 'addrObjId'],
                                                                             config[context]['addressmappings']):
                                            if (expanded_index in config[context]['addresses']):
                                                policyIPv4_list.extend(
                                                    config[context]['addresses'][expanded_index]['IPv4Networks'])
                                            elif (expanded_index in shared['addresses']):
                                                policyIPv4_list.extend(
                                                    shared['addresses'][expanded_index]['IPv4Networks'])
                                    elif (source_index in shared['addresses']):
                                        for expanded_index in expand_address(shared['addresses'],
                                                                             shared['addresses'][source_index][
                                                                                 'addrObjId'],
                                                                             shared['addressmappings']):
                                            policyIPv4_list.extend(shared['addresses'][expanded_index]['IPv4Networks'])
                                            prefix = '*'
                                    else:
                                        if source_index.lower() not in ['any', '']: log(
                                            'UNKNOWN SOURCE "{}"'.format(source_index))
                                        try:
                                            if re.findall('-', source_index) != []:
                                                first, last = source_index.split('-')
                                                for x in ipaddress.summarize_address_range(ipaddress.IPv4Address(first),
                                                                                           ipaddress.IPv4Address(last)):
                                                    policyIPv4_list.extend([x])
                                                    debug('Adding Range to policy list {}'.format(x))
                                            else:
                                                first = source_index
                                                last = source_index
                                                if re.findall('/', first) == []:
                                                    first = first + '/32'
                                                policyIPv4_list.extend([ipaddress.IPv4Network(first)])
                                                debug('Adding network/host to policy list {}'.format(x))
                                        except Exception as e:
                                            # if source_index.lower() not in ['any', '']: log('UNKNOWN SOURCE "{}"'.format(source_index))
                                            log('Exception {} handling unknown source : {}'.format(e, source_index))
                                            pass

                                polSet = IPSet([])
                                srcSet = IPSet([])
                                for x in policyIPv4_list:
                                    polSet.add(str(x))
                                srcSet.add(sourceIPv4.with_netmask)
                                # log('intersection', excluded_networks & polSet)
                                # if excluded_networks not in polSet:
                                if excluded_src_networks & polSet == IPSet([]):
                                    if (srcSet & polSet) or ((
                                                                     source_index.lower() == 'any' or source.lower() == '0.0.0.0/0') and options.zero_network):
                                        if srcSet == polSet:
                                            source_match_type = 'Exact'
                                        elif (srcSet & polSet) == srcSet:
                                            source_match_type = 'Complete'
                                        elif (srcSet & polSet) == polSet:
                                            source_match_type = 'Partial'
                                        elif (source_index.lower() == 'any' or source.lower() == '0.0.0.0/0'):
                                            source_match_type = 'Any'
                                        else:
                                            source_match_type = 'Mixed'
                                        found_in_source = True
                                        source_addr = config[context]['policies'][policy]['policySrcNet']
                                        source_found_index.append(source_index)
                                        # break
                                else:
                                    source_addr = config[context]['policies'][policy]['policySrcNet']
                                    debug('Excluded network found in source - skipping rule')
                        if negate_source:
                            found_in_source = not found_in_source
                        if found_in_source:
                            prefix = ''
                            dest_found_index = []
                            if dest == '0.0.0.0/0':  # and options.zero_network: -- not applicable here
                                found_in_dest = True
                                dest_match_type = "Any"
                                if len(config[context]['policies'][policy]['policyDstNet']) >= 1:
                                    dest_addr = config[context]['policies'][policy]['policyDstNet']
                                    if dest_addr == ['']: dest_addr = ['Any']
                                else:
                                    dest_addr = ['Any']
                            else:
                                for dest_index in config[context]['policies'][policy]['policyDstNet']:
                                    # print(dest_index)
                                    if dest_index.lower() in ['any', ''] and options.zero_network:
                                        found_in_dest = True
                                        dest_addr = ['Any']
                                        break
                                    policyIPv4_list = []
                                    if dest_index in config[context]['addresses'] or dest_index.lower() in ['any', '']:
                                        pass
                                    else:
                                        print('{} not found in config'.format(dest_index))
                                    if dest_index not in excluded_addresses:
                                        if (dest_index in config[context]['addresses']):
                                            for expanded_index in expand_address(config[context]['addresses'],
                                                                                 config[context]['addresses'][
                                                                                     dest_index]['addrObjId'],
                                                                                 config[context]['addressmappings']):
                                                if (expanded_index in config[context]['addresses']):
                                                    policyIPv4_list.extend(
                                                        config[context]['addresses'][expanded_index]['IPv4Networks'])
                                                elif (expanded_index in shared['addresses']):
                                                    policyIPv4_list.extend(
                                                        shared['addresses'][expanded_index]['IPv4Networks'])
                                                # else:
                                                #    print('{} not found in config'.format(dest_index))

                                        elif (dest_index in shared['addresses']):
                                            for expanded_index in expand_address(shared['addresses'],
                                                                                 shared['addresses'][dest_index][
                                                                                     'addrObjId'],
                                                                                 shared['addressmappings']):
                                                policyIPv4_list.extend(
                                                    shared['addresses'][expanded_index]['IPv4Networks'])
                                                prefix = '*'
                                        # else:
                                        #
                                        else:
                                            if dest_index.lower() not in ['any', '']:  log(
                                                'UNKNOWN DEST in policy {} "{}"'.format(
                                                    config[context]['policies'][policy]['policyName'], dest_index))
                                            try:
                                                if re.findall('-', dest_index) != []:
                                                    first, last = dest_index.split('-')
                                                    for x in ipaddress.summarize_address_range(
                                                            ipaddress.IPv4Address(first), ipaddress.IPv4Address(last)):
                                                        policyIPv4_list.extend([x])
                                                else:
                                                    first = dest_index
                                                    last = dest_index
                                                    if re.findall('/', first) == []:
                                                        first = first + '/32'
                                                    policyIPv4_list.extend([ipaddress.IPv4Network(first)])

                                            except Exception as e:
                                                pass
                                    polSet = IPSet([])
                                    destSet = IPSet([])
                                    for x in policyIPv4_list:
                                        polSet.add(str(x))
                                    destSet.add(destIPv4.with_netmask)
                                    # log(polSet)
                                    # log('intersection', excluded_networks & polSet)
                                    if excluded_dst_networks & polSet == IPSet([]):
                                        if (polSet & destSet) or ((
                                                                          dest_index.lower() == 'any' or dest.lower() == '0.0.0.0/0') and options.zero_network):
                                            if destSet == polSet:
                                                dest_match_type = 'Exact'
                                            elif (destSet & polSet) == destSet:
                                                dest_match_type = 'Complete'
                                            elif (destSet & polSet) == polSet:
                                                dest_match_type = 'Partial'
                                            elif (dest_index.lower() == 'any' or dest.lower() == '0.0.0.0/0'):
                                                dest_match_type = 'Any'
                                            else:
                                                dest_match_type = 'Mixed'
                                            found_in_dest = True
                                            dest_addr = config[context]['policies'][policy]['policyDstNet']
                                            dest_found_index.append(dest_index)
                                            if dest_match_type == 'Exact':
                                                debug(policyIPv4_list)
                                                debug(polSet)
                                                debug(destSet)
                                            # break
                                    else:
                                        dest_addr = config[context]['policies'][policy]['policyDstNet']
                                        debug('Excluded network found in dest - skipping rule')
                        if negate_dest:
                            found_in_dest = not found_in_dest
                        if found_in_dest:
                            # perform checking of service
                            # verify that get port of icmp returns "any"
                            if (config[context]['policies'][policy]['policyDstSvc'] == [
                                ''] and options.zero_service) or (
                                    [x.lower() for x in config[context]['policies'][policy]['policyDstSvc']] == [
                                'any'] and options.zero_service) or config[context]['policies'][policy][
                                'policyDstSvc'] == ['application-default']:
                                found_in_service = True
                                if config[context]['policies'][policy]['policyDstSvc'] == ['']:
                                    dest_service = ['any']
                                else:
                                    dest_service = config[context]['policies'][policy]['policyDstSvc']
                            elif service == 'any/any':  # and options.zero_network:
                                found_in_service = True
                                dest_service = config[context]['policies'][policy]['policyDstSvc']
                            else:
                                for dest_index in config[context]['policies'][policy]['policyDstSvc']:
                                    if (dest_index in config[context]['services']):
                                        for expanded_index in expand_service(config[context]['services'],
                                                                             config[context]['services'][dest_index][
                                                                                 'svcObjId'],
                                                                             config[context]['servicemappings']):
                                            policy_prot = get_prot_of(config[context]['services'], expanded_index)
                                            # start_port, end_port = get_port_of(config[context]['services'],expanded_index)
                                            policy_ports = get_ports_of(config[context]['services'], expanded_index)
                                            # log(policy_ports)
                                            # if start_port=='': start_port='0'
                                            # if end_port=='': end_port='0'
                                            ## svcPortSet FIX
                                            try:
                                                if ((prot.lower() == policy_prot or prot.lower() == 'any') and (
                                                        int(portnum) in policy_ports)) or (
                                                        dest_index.lower() == 'any' and options.zero_network) or (
                                                        service.lower() == 'any/any' and options.zero_network):
                                                    if found_in_service == False:
                                                        found_in_service = True
                                                        dest_service = config[context]['policies'][policy][
                                                            'policyDstSvc']
                                                        break
                                            except Exception as e:
                                                # print(type(prot.lower()))
                                                print(prot.lower())

                                                # print(type(policy_prot))
                                                print(policy_prot)
                                                print("'" + start_port + "'")
                                                print(end_port)
                                                print(expanded_index)
                                                log(e)

                                    if (dest_index in shared['services']):
                                        for expanded_index in expand_service(shared['services'],
                                                                             shared['services'][dest_index]['svcObjId'],
                                                                             shared['servicemappings']):
                                            policy_prot = get_prot_of(shared['services'], expanded_index).lower()
                                            # start_port, end_port = get_port_of(shared['services'],expanded_index)
                                            policy_ports = get_ports_of(config[context]['services'], expanded_index)
                                            # if start_port=='': start_port='0'
                                            # if end_port=='': end_port='0'
                                            if ((
                                                        prot.lower() == policy_prot or prot.lower() == 'any') and portnum in policy_ports) or dest_index.lower() == 'any' or (
                                                    service.lower() == 'any/any' and options.zero_network):
                                                if found_in_service == False:
                                                    found_in_service = True
                                                    dest_service = config[context]['policies'][policy]['policyDstSvc']
                                                    break

                        if found_in_source and found_in_dest and found_in_service and (
                                options.matchtypes in [['all'], ['any']] or (
                                source_match_type.lower() in [x.lower() for x in
                                                              options.matchtypes] or source_match_type.lower() == 'any') and (
                                        dest_match_type.lower() in [x.lower() for x in
                                                                    options.matchtypes] or dest_match_type.lower() == 'any')):
                            # I believe zone/net/service is empty if "any", so temporarily set these values to variables before printing them
                            if config[context]['policies'][policy]['policyEnabled'] == '0':
                                enabled = "."
                            elif config[context]['policies'][policy]['policyEnabled'] == '1':
                                if options.web or options.csv:
                                    enabled = 'Y'
                                else:
                                    enabled = u'\u2713'

                            comment = re.sub('"', "'", str(config[context]['policies'][policy]['policyComment']))
                            if 'policyUUID' in config[context]['policies'][policy]:
                                uuid = config[context]['policies'][policy]['policyUUID']
                            elif 'policyUid' in config[context]['policies'][policy]:
                                uuid = config[context]['policies'][policy]['policyUid']
                            else:
                                uuid = 'unknown'

                            if config[context]['policies'][policy]['policyAction'] == '0':
                                action = 'deny'
                            elif config[context]['policies'][policy]['policyAction'] == '1':
                                action = 'discard'
                            elif config[context]['policies'][policy]['policyAction'] == '2':
                                action = 'allow'
                            elif config[context]['policies'][policy]['policyAction'] == '3':
                                action = 'CltAuth'
                            name = config[context]['policies'][policy]['policyName']

                            if config[context]['policies'][policy]['policySrcZone'] == []:
                                source_zone = ['any']
                            else:
                                source_zone = config[context]['policies'][policy]['policySrcZone']

                            if config[context]['policies'][policy]['policyDstZone'] == []:
                                dest_zone = ['any']
                            else:
                                dest_zone = config[context]['policies'][policy]['policyDstZone']

                            policymatches += 1

                            if config[context]['policies'][policy]['policySrcZone'] == [] or \
                                    config[context]['policies'][policy]['policySrcZone'] == ['']:
                                source_zones = ['any']
                            else:
                                source_zones = config[context]['policies'][policy]['policySrcZone']

                            if config[context]['policies'][policy]['policyDstZone'] == [] or \
                                    config[context]['policies'][policy]['policyDstZone'] == ['']:
                                dest_zones = ['any']
                            else:
                                dest_zones = config[context]['policies'][policy]['policyDstZone']

                            if config[context]['policies'][policy]['policySrcNet'] == [] or \
                                    config[context]['policies'][policy]['policySrcNet'] == ['']:
                                source_nets = ['any']
                            else:
                                source_nets = config[context]['policies'][policy]['policySrcNet']

                            if config[context]['policies'][policy]['policyDstNet'] == [] or \
                                    config[context]['policies'][policy]['policyDstNet'] == ['']:
                                dest_nets = ['any']
                            else:
                                dest_nets = config[context]['policies'][policy]['policyDstNet']

                            if config[context]['policies'][policy]['policyDstSvc'] == [] or \
                                    config[context]['policies'][policy]['policyDstSvc'] == ['']:
                                dest_services = ['any']
                            else:
                                dest_services = config[context]['policies'][policy]['policyDstSvc']
                            if 'policySection' in config[context]['policies'][policy]:
                                section = config[context]['policies'][policy]['policySection']
                            else:
                                section = 'Unknown'

                            if options.html:
                                if policymatches == 1:
                                    log('<p align=cneter><font size=8 >')
                                    log('context: ' + context)
                                    log('</font></p>')
                                    log('<table border="1" width="90%">')
                                    if config[context]['config']['fw_type'] == 'checkpoint':
                                        log('<th>Enabled</th><th>Action</th><th>PolicyName</th><th>UiNum</th><th>IndexNum</th><th>Source Address</th><th>Destination Address</th><th>Service</th>')
                                    else:
                                        log('<th>Enabled</th><th>Action</th><th>Name</th><th>Source Zone</th><th>Dest Zone</th><th>Source Address</th><th>Destination Address</th><th>Service</th>')
                                if enabled != "Y":
                                    trcolor = '#aaaaaa'
                                elif action.lower() == 'allow':
                                    trcolor = '#00aa00'
                                else:
                                    trcolor = '#aa0000'
                                log('<tr bgcolor="' + trcolor + '">')
                                log('<td>' + enabled + '</td>')
                                log('<td>' + action + '</td>')
                                log('<td>' + name + '</td>')
                                ## only do src/dest zones for non-checkpoint
                                ## for checkpoint, add ruleUI number
                                if config[context]['config']['fw_type'] == 'checkpoint':
                                    log('<td>' + str(config[context]['policies'][policy]['policyUiNum']) + '</td>')
                                    log('<td>' + str(config[context]['policies'][policy]['policyNum']) + '</td>')
                                else:
                                    log('<td>')
                                    for source_zone in source_zones:
                                        log(url_unquote(source_zone) + '<br>')
                                    log('</td>')
                                    log('<td>')
                                    for dest_zone in dest_zones:
                                        log(url_unquote(dest_zone) + '<br>')
                                    log('</td>')
                                log('<td>')
                                for source_address in source_nets:
                                    if source_address in source_found_index:
                                        log('<p style="color:green">{}</p><br>'.format(url_unquote(source_address)))
                                    else:
                                        log(url_unquote(source_address) + '<br>')
                                log('</td>')
                                log('<td>')
                                for dest_address in dest_nets:
                                    if dest_address in dest_found_index:
                                        log('<p style="color:green">{}</p><br>'.format(url_unquote(dest_address)))
                                    else:
                                        log(url_unquote(dest_address) + '<br>')
                                log('</td>')
                                log('<td>')
                                for dest_service in dest_services:
                                    log(url_unquote(dest_service) + '<br>')
                                log('</td>')
                                log('<tr>')
                            elif options.csv:
                                with codecs.open(options.csv, 'a+', 'utf-8') as outfile:
                                    if policymatches == 1:  ## this is to print a header line
                                        if config[context]['config']['fw_type'] == 'checkpoint':
                                            outfile.write(
                                                'Context,Enabled,Action,PolicyName,Section,UiNum,IndexNum,Source Address,Destination Address,Service,Comment,UUID\n')

                                        else:
                                            outfile.write(
                                                'Context,Enabled,Action,Name,Source Zone,Dest Zone,Source Address,Destination Address,Service,Comment,UUID\n')

                                    # with codecs.open('/dev/stdout', 'w', 'utf-8') as outfile:
                                    # outfile.write('-' * 180+'\n')
                                    # outfile.write ('context: ' + context + '\n')
                                    # outfile.write('\n')

                                    outfile.write('"{}",'.format(context))
                                    outfile.write('"{}",'.format(enabled))
                                    outfile.write('"{}",'.format(action))
                                    outfile.write('"{}",'.format(name))
                                    ## only do src/dest zones for non-checkpoint
                                    ## for checkpoint, add ruleUI number
                                    if config[context]['config']['fw_type'] == 'checkpoint':
                                        outfile.write('"{}",'.format(str(section)))
                                        outfile.write(
                                            '"{}",'.format(str(config[context]['policies'][policy]['policyUiNum'])))
                                        outfile.write(
                                            '"{}",'.format(str(config[context]['policies'][policy]['policyNum'])))
                                    # else:

                                    outfile.write('"')
                                    if config[context]['config']['fw_type'] != 'checkpoint':
                                        for source_zone in source_zones:
                                            outfile.write('{}'.format(url_unquote(source_zone)))
                                            if source_zone == source_zones[-1]:
                                                outfile.write('",')
                                            else:
                                                outfile.write('\n')
                                        outfile.write('"')
                                        for dest_zone in dest_zones:
                                            outfile.write('{}'.format(url_unquote(dest_zone)))
                                            if dest_zone == dest_zones[-1]:
                                                outfile.write('",')
                                            else:
                                                outfile.write('\n')
                                        outfile.write('"')
                                    for source_address in source_nets:
                                        if source_address in source_found_index:
                                            sourceprefix = '*'
                                        else:
                                            sourceprefix = ''
                                        outfile.write('{}{}'.format(sourceprefix, url_unquote(source_address)))
                                        if source_address == source_nets[-1]:
                                            outfile.write('",')
                                        else:
                                            outfile.write('\n')
                                    outfile.write('"')
                                    for dest_address in dest_nets:
                                        if dest_address in dest_found_index:
                                            destprefix = '*'
                                        else:
                                            destprefix = ''
                                        outfile.write('{}{}'.format(destprefix, url_unquote(dest_address)))
                                        if dest_address == dest_nets[-1]:
                                            outfile.write('",')
                                        else:
                                            outfile.write('\n')
                                    outfile.write('"')
                                    for dest_service in dest_services:
                                        outfile.write('{}'.format(url_unquote(dest_service)))
                                        if dest_service == dest_services[-1]:
                                            outfile.write('",')
                                        else:
                                            outfile.write('\n')
                                    outfile.write('"{}",'.format(comment))
                                    outfile.write('"{}"'.format(uuid))
                                    outfile.write('\n')  # end of line

                            else:
                                # print (source_match_type)
                                if policymatches == 1:
                                    log('Context : ' + context)
                                    if config[context]['config']['fw_type'] == 'checkpoint':
                                        log('{:2.2s} | {:8.8s} | {:15.15s} | {:30.30s} | {:8.8s} | {:8.8s} | {:10.10s} | {:60.60s} | {:10.10s} | {:40.40s} | {:40.40s}'.format(
                                            'En', 'Action', 'CMA', 'Policy Name', 'Rule UI#', 'Rule Idx', 'Src_match',
                                            'Source Address', 'Dst_match', 'Destination Address', 'Service'))
                                    else:
                                        log('{:2.2s} | {:8.8s} | {:30.30s} | {:20.20s} | {:20.20s} | {:10.10s} | {:60.60s} | {:10.10s} | {:40.40s} | {:40.40s}'.format(
                                            'En', 'Action', 'Rule Name', 'Source Zone', 'Destination Zone', 'Src_match',
                                            'Source Address', 'Dst_match', 'Destination Address', 'Service'))
                                    log('=' * 250)
                                # if config[context]['config']['fw_type']=='checkpoint':
                                #    log ('{:2.2s} {:8.8s} {:15.15s} {:30.30s} {:8.8s} {:8.8s} {:10.10s} {:60.60s} {:10.10s} {:40.40s} {:40.40s}'.format(enabled, action, context, url_unquote(name), str(config[context]['policies'][policy]['policyUiNum']), str(config[context]['policies'][policy]['policyNum']), str(source_match_type), url_unquote(source_addr[0]), str(dest_match_type), url_unquote(dest_addr[0]), url_unquote(dest_service[0])))
                                # else:
                                #    log ('{:2.2s} {:8.8s} {:30.30s} {:20.20s} {:20.20s} {:10.10s} {:60.60s} {:10.10s} {:40.40s} {:40.40s}'.format(enabled, action, url_unquote(name), url_unquote(source_zone[0]), url_unquote(dest_zone[0]), str(source_match_type), url_unquote(source_addr[0]), str(dest_match_type), url_unquote(dest_addr[0]), url_unquote(dest_service[0])))
                                longestval = max(len(source_addr), len(dest_addr), len(dest_service), len(source_zone),
                                                 len(dest_zone))
                                # if longestval>1:
                                for index in range(0, longestval):
                                    tmpsrc = ''
                                    tmpdst = ''
                                    tmpsvc = ''
                                    tmpszone = ''
                                    tmpdzone = ''
                                    srcprefix = ''
                                    dstprefix = ''
                                    if index < len(source_zone):
                                        tmpszone = source_zone[index]
                                    if index < len(dest_zone):
                                        tmpdzone = dest_zone[index]
                                    if index < len(source_addr):
                                        tmpsrc = source_addr[index]
                                    if index < len(dest_addr):
                                        tmpdst = dest_addr[index]
                                    if index < len(dest_service):
                                        tmpsvc = dest_service[index]
                                    if tmpsrc in source_found_index:  # and source_found_index != []:
                                        srcprefix = '*'
                                    if tmpdst in dest_found_index:  # and dest_found_index != []:
                                        dstprefix = '*'
                                    if index == 0:
                                        if config[context]['config']['fw_type'] == 'checkpoint':
                                            log('{:2.2s} | {:8.8s} | {:15.15s} | {:30.30s} | {:8.8s} | {:8.8s} | {:10.10s} | {:1.1s}{:60.60s} | {:10.10s} | {:1.1s}{:40.40s} | {:40.40s}'.format(
                                                enabled, action, context, url_unquote(name),
                                                str(config[context]['policies'][policy]['policyUiNum']),
                                                str(config[context]['policies'][policy]['policyNum']),
                                                str(source_match_type), srcprefix, url_unquote(source_addr[0]),
                                                str(dest_match_type), dstprefix, url_unquote(dest_addr[0]),
                                                url_unquote(dest_service[0])))
                                        else:
                                            log('{:2.2s} | {:8.8s} | {:30.30s} | {:20.20s} | {:20.20s} | {:10.10s} | {:1.1s}{:60.60s} | {:10.10s} | {:1.1s}{:40.40s} | {:40.40s}'.format(
                                                enabled, action, url_unquote(name), url_unquote(source_zone[0]),
                                                url_unquote(dest_zone[0]), str(source_match_type), srcprefix,
                                                url_unquote(source_addr[0]), str(dest_match_type), dstprefix,
                                                url_unquote(dest_addr[0]), url_unquote(dest_service[0])))
                                    else:
                                        if config[context]['config']['fw_type'] == 'checkpoint':
                                            log('{:2.2s} | {:8.8s} | {:15.15s} | {:30.30s} | {:8.8s} | {:8.8s} | {:10.10s} | {:1.1s}{:60.60s} | {:10.10s} | {:1.1s}{:40.40s} | {:40.40s}'.format(
                                                '', '', '', '', '', '', '', srcprefix, url_unquote(tmpsrc), '',
                                                dstprefix, url_unquote(tmpdst), url_unquote(tmpsvc)))
                                        else:
                                            log('{:2.2s} | {:8.8s} | {:30.30s} | {:20.20s} | {:20.20s} | {:10.10s} | {:1.1s}{:60.60s} | {:10.10s} | {:1.1s}{:40.40s} | {:40.40s}'.format(
                                                '', '', '', tmpszone, tmpdzone, '', str(source_match_type), srcprefix,
                                                url_unquote(tmpsrc), '', str(dest_match_type), dstprefix,
                                                url_unquote(tmpdst), url_unquote(tmpsvc)))
                                log('-' * 250)
                                if modify:
                                    if modify_group not in config[context]['policies'][policy]['policyDstNet']:
                                        for addr in modify_addr:
                                            log('addelement fw_policies {} rule:{}:dst:\'\' network_objects:{}'.format(
                                                url_unquote(name), config[context]['policies'][policy]['policyNum'],
                                                addr))
                                    else:
                                        log('Rule already contains group: ' + modify_group)

                if policymatches != 0 and options.web:
                    log('</table>')
                    log('<hr>')

                if policymatches == 0:
                    nomatches.append(context)

    log('No matches were found for the following contexts')
    for nomatch in nomatches:
        log(nomatch)
        if options.web: log('<br>')
    return


def find_ip_address_in_policy(policies, addresses, address_map, ip_address):
    ## Given a list of IP addresses, find all the policy objects that contain the address
    ## CHANGEME - NOT WORKING AS expand_address is at least one thing broken here
    ## need to also receive address map config

    ## not working properly for ranges - false positives

    ## this routine is not really needed as the inverse match routines now perform this function, although that matches policies and addresses

    import ipaddress
    import re
    return_list = []
    for ip_to_find in ip_address:
        if not re.findall('/', ip_to_find):  ## if netmask is not given, add /32 host mask
            ip_to_find = ip_to_find + '/32'
        log('-' * 120)
        log('Searching policies for : ' + ip_to_find)
        log('-' * 120)
        log('%-60s :' % 'Rule Description', end=' ')
        log('%-30s :' % 'Root Object Name', end=' ')
        log('%-30s' % 'Member Address Object')
        log('-' * 120)
        for policy_index in policies:
            if policies[policy_index]['policySrcNet'] != []:
                for src in range(0, len(policies[policy_index]['policySrcNet'])):
                    for expanded_index in expand_address(addresses, policies[policy_index]['policySrcNet'][src],
                                                         address_map):
                        for network_index in range(0, len(addresses[expanded_index]['IPv4Networks'])):
                            if ipaddress.IPv4Network(ip_to_find, strict=False).overlaps(
                                    addresses[expanded_index]['IPv4Networks'][network_index]):
                                try:
                                    policydesc = re.sub(r'\n', '##', policies[policy_index]['policyName'][:60])
                                except:
                                    policydesc = ''
                                log('{:60.60}'.format(policydesc), end=' : ')
                                log('{:30.30}'.format(policies[policy_index]['policySrcNet'][src]), end=' : ')
                                log('{:30.30}'.format(expanded_index))
                                return_list.append(expanded_index)
            if policies[policy_index]['policyDstNet'] != []:
                for dst in range(0, len(policies[policy_index]['policyDstNet'])):
                    for expanded_index in expand_address(addresses, policies[policy_index]['policyDstNet'][dst],
                                                         address_map):
                        for network_index in range(0, len(addresses[expanded_index]['IPv4Networks'])):
                            if ipaddress.IPv4Network(ip_to_find, strict=False).overlaps(
                                    addresses[expanded_index]['IPv4Networks'][network_index]):
                                try:
                                    policydesc = re.sub(r'\n', '##', policies[policy_index]['policyName'][:60])
                                except:
                                    policydesc = ''
                                log('{:60.60}'.format(policydesc), end=' : ')
                                log('{:30.30}'.format(policies[policy_index]['policyDstNet'][dst]), end=' : ')
                                log('{:30.30}'.format(expanded_index))

                                return_list.append(expanded_index)
    return return_list;


def find_description(policies, descriptions):
    ## Given a string, find all the policy objects that contain the string given
    ## What fields should be checked?
    ## Should it work as a regex?

    ## Test this

    return_list = []
    for desc_to_find in descriptions:
        log('-' * 120)
        log('Searching policies for : ' + desc_to_find)
        log('-' * 120)
        log('%-60s :' % 'Rule Description', end=' ')
        log('%30s :' % 'Source', end=' ')
        log('%-30s' % 'Destination')
        log('-' * 120)
        for policy_index in policies:
            if re.findall(desc_to_find, policies[policy_index]['policyComment'], flags=re.IGNORECASE):
                log('%-60s :' % policies[policy_index]['policyComment'], end=' ')
                log('%30s :' % policies[policy_index]['policySrcNet'], end=' ')
                log('%-30s' % policies[policy_index]['policyDstNet'])
                return_list.append('')
    return return_list;


def sw_get_api_status(target, username, password):
    import sonicwall as sw
    from bs4 import BeautifulSoup

    session = requests.Session()
    session.mount('https://' + target, sw.DESAdapter())
    sw.do_login(session, username, password, target, preempt=True)
    response = sw.get_url(session, 'https://' + target + '/systemAdministrationView.html')
    # log(response.text)
    try:
        soup = BeautifulSoup(response.text, 'lxml')
    except:
        return None
    try:
        api_enabled = soup.find('input', attrs={'name': 'sonicOsApi_enable'}).has_attr('checked')
    except:
        api_enabled = False
    return api_enabled


def sw_enable_api(target, username, password):
    import sonicwall as sw
    import re

    session = requests.Session()
    session.mount('https://' + target, sw.DESAdapter())
    sw.do_login(session, username, password, target, preempt=True)
    response = sw.get_url(session, 'https://' + target + '/systemAdministrationView.html')
    try:
        csrf = re.findall(r'csrfToken.*"', response.text)[0].split('value=')[1].split('"')[1]
        postdata = {'csrfToken': csrf,
                    'cgiaction': "none",
                    'sonicOsApi_enable': "on",
                    'sonicOsApi_basicAuth': "on",
                    'cbox_sonicOsApi_enable': "",
                    'cbox_sonicOsApi_basicAuth': ""}
        url = 'https://' + target + '/main.cgi'
        api_result = send_sw_webcmd(session, url, postdata)
        sw.do_logout(session, target)
        return api_result
    except:
        return False


def sw_set_webtimeout(target, username, password, timeout):
    import sonicwall as sw
    import re

    session = requests.Session()
    session.mount('https://' + target, sw.DESAdapter())
    sw.do_login(session, username, password, target, preempt=True)
    response = sw.get_url(session, 'https://' + target + '/systemAdministrationView.html')
    try:
        csrf = re.findall(r'csrfToken.*"', response.text)[0].split('value=')[1].split('"')[1]
        postdata = {'csrfToken': csrf,
                    'cgiaction': "none",
                    'adminLoginTimeout': "{}".format(timeout),
                    # 'cli_idleTimeout': '99',
                    }
        url = 'https://' + target + '/main.cgi'
        api_result = send_sw_webcmd(session, url, postdata)
        sw.do_logout(session, target)
        return api_result
    except:
        return False


def sw_disable_api(target, username, password):
    import sonicwall as sw
    import re

    session = requests.Session()
    session.mount('https://' + target, sw.DESAdapter())
    sw.do_login(session, username, password, target, preempt=True)
    response = sw.get_url(session, 'https://' + target + '/systemAdministrationView.html')
    try:
        csrf = re.findall(r'csrfToken.*"', response.text)[0].split('value=')[1].split('"')[1]
        postdata = {'csrfToken': csrf,
                    'cgiaction': "none",
                    'sonicOsApi_enable': "off",
                    'sonicOsApi_basicAuth': "on",
                    'cbox_sonicOsApi_enable': "",
                    'cbox_sonicOsApi_basicAuth': ""}
        url = 'https://' + target + '/main.cgi'
        api_result = send_sw_webcmd(session, url, postdata)
        sw.do_logout(session, target)
        return api_result
    except:
        return False


def load_sonicwall_api(ip, username, password, skipdisabled=False, memoryconfig=None, retries=1, retry_delay=1,
                       enable_api=False, revert_api=False):
    import sonicwall as sw
    import json
    from collections import OrderedDict
    from netaddr import IPSet
    import base64

    # !Addresses
    # !Services
    # Security Rules - need to load source/dest
    # NAT Rules
    # !Routes
    # !Zones
    # !Interfaces
    # !Address and service mappings details - should be easy from group items?
    # Perform a diff in json.dumps of config read from each method
    #

    log('!-- Loading Sonicwall configuration via API requested')
    ## Use API to send CLI command for groups
    orig_api_enabled = sw_get_api_status(ip, username, password)
    # orig_api_enabled=True

    # log(orig_api_enabled)
    api_enabled = False

    if enable_api and not orig_api_enabled:  ## Add command to force API enablement, if needed
        log('!-- Sonicwall API not enabled - enablement requested')
        sw_enable_api(ip, username, password)
        api_enabled = sw_get_api_status(ip, username, password)
        # log(api_enabled)
        if api_enabled:
            log('!-- Sonicwall API enablement successful')
        else:
            log('!-- Sonicwall API enablement failed')

    sonicwall_config = defaultdict(dict)

    if api_enabled or orig_api_enabled:

        sonicwall_config['addresses'] = OrderedDict()
        sonicwall_config['config'] = OrderedDict()
        sonicwall_config['policies'] = OrderedDict()
        sonicwall_config['services'] = OrderedDict()
        sonicwall_config['routing'] = OrderedDict()
        sonicwall_config['nat'] = OrderedDict()
        sonicwall_config['interfaces'] = OrderedDict()
        sonicwall_config['zones'] = OrderedDict()
        sonicwall_config['apps'] = OrderedDict()
        sonicwall_config['policiesV6'] = OrderedDict()
        sonicwall_config['addressesV6'] = OrderedDict()
        sonicwall_config['addressesfqdn'] = OrderedDict()
        sonicwall_config['addressmappings'] = OrderedDict()
        sonicwall_config['servicemappings'] = OrderedDict()

        ## get routing table via WebUI which is complete
        ## # routing_props = ['pbrObjId', 'pbrObjProperties', 'pbrObjSrc', 'pbrObjDst', 'pbrObjSvc', 'pbrObjGw', 'pbrObjIface', 'pbrObjIfaceName', 'pbrObjMetric', 'pbrObjPriority', 'pbrObjProbe', 'pbrObjComment']

        session = requests.Session()
        session.mount('https://' + ip, sw.DESAdapter())
        urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

        session = requests.Session()
        session.mount('https://' + ip, sw.DESAdapter())
        loginResult = sw.do_login(session, options.username, options.password, ip, preempt=True)
        pbrResult = None
        if loginResult:
            pbrResult = sw.get_url(session, 'https://' + ip + '/getRouteList.json')
        sw.do_logout(session, ip)

        url = 'https://{}/api/sonicos/auth'.format(ip)
        session.headers = OrderedDict(
            [('User-Agent', 'python-requests/2.18.4'), ('Accept', '*/*'), ('Accept-Encoding', 'gzip, deflate'),
             ('Connection', 'keep-alive')])
        post_data = None
        # auth = requests.auth.HTTPBasicAuth(username, password)
        response_code = None
        login_tries = 0
        while response_code != 200 and login_tries < retries:
            try:
                login_tries += 1
                response = session.post(url=url, headers={
                    'authorization': "Basic " + base64.b64encode('{}:{}'.format(username, password).encode()).decode()},
                                        verify=False, timeout=options.timeout_sw_webui_login)
                response_code = response.status_code
                if response_code != 200:
                    debug('Login failed, retrying in 10 seconds')
                    time.sleep(retry_delay)
            except:
                response_code = None
        # /api/sonicos/access-rules/ipv4

        sonicwall_config['config']['fw_type'] = 'sonicwall'

        if response_code == 200:

            session.headers.update({'content-type': 'text/plain'})
            session.headers.update({'Accept': 'application/json'})

            log('!-- Reading Security Policy Objects')
            url = 'https://{}/api/sonicos/access-rules/ipv4'.format(ip)
            result = session.get(url=url, data=post_data, verify=False, timeout=options.timeout_sw_api)
            debug(result.text)
            security_ipv4 = json.loads(result.text)
            debug('{:20.20} {:20.20} {}'.format('Length', ' Security Policies', len(security_ipv4['access_rules'])))
            # debug(security_ipv4['access_rules'][0])

            rule_num_int = 0
            for access_rule in security_ipv4['access_rules']:
                # {'ipv4': {'schedule': {'always_on': True}, 'geo_ip_filter': False, 'comment': 'Auto-added management rule', 'name': '',
                # 'source': {'port': {'any': True}, 'address': {'any': True}}, 'sip': False, 'udp': {'timeout': 30}, 'h323': False, 'packet_monitoring': False, 'from': 'LAN', 'quality_of_service': {'class_of_service': {}, 'dscp': {'preserve': True}},
                # 'service': {'group': 'Ping'}, 'fragments': True, 'max_connections': 100, 'flow_reporting': False, 'tcp': {'timeout': 15, 'urgent': True}, 'logging': True, 'botnet_filter': False, 'enable': True, 'priority': {'manual': 1}, 'connection_limit': {'source': {}, 'destination': {}}, 'dpi': True, 'action': 'allow', 'uuid': '00b7ea07-d3f5-1e66-0700-c0eae46b8088', 'to': 'LAN',
                # 'users': {'excluded': {'none': True}, 'included': {'all': True}}, 'dpi_ssl': {'server': True, 'client': True}, 'management': True, 'destination': {'address': {'group': 'All X0 Management IP'}}}}
                # policy_props = ['policyAction', 'policySrcZone', 'policyDstZone', 'policySrcNet', 'policyDstNet', 'policyDstSvc', 'policyDstApps', 'policyComment', 'policyLog', 'policyEnabled', 'policyProps' ]
                rule_num = str(rule_num_int)
                debug(access_rule)
                # rule_num=str(access_rule['ipv4']['priority']['manual'])
                sonicwall_config['policies'][rule_num] = OrderedDict()

                sonicwall_config['policies'][rule_num]['policyAction'] = ''
                sonicwall_config['policies'][rule_num]['policySrcZone'] = ''
                sonicwall_config['policies'][rule_num]['policyDstZone'] = ''
                sonicwall_config['policies'][rule_num]['policySrcNet'] = ''
                sonicwall_config['policies'][rule_num]['policyDstNet'] = ''
                sonicwall_config['policies'][rule_num]['policyDstSvc'] = ''
                sonicwall_config['policies'][rule_num]['policySrcNegate'] = False
                sonicwall_config['policies'][rule_num]['policyDstNegate'] = False
                sonicwall_config['policies'][rule_num]['policySvcNegate'] = False
                sonicwall_config['policies'][rule_num]['policyDstApps'] = ''
                sonicwall_config['policies'][rule_num]['policyComment'] = ''
                sonicwall_config['policies'][rule_num]['policyLog'] = ''
                sonicwall_config['policies'][rule_num]['policyEnabled'] = ''
                sonicwall_config['policies'][rule_num]['policyProps'] = ''
                sonicwall_config['policies'][rule_num]['policyUUID'] = ''
                sonicwall_config['policies'][rule_num]['policyName'] = "Empty"
                sonicwall_config['policies'][rule_num]['policyNum'] = ''
                sonicwall_config['policies'][rule_num]['policyUiNum'] = ''
                sonicwall_config['policies'][rule_num]['policyDstApps'] = ['']
                if access_rule['ipv4']['action'].lower() == 'deny':
                    sonicwall_config['policies'][rule_num]['policyAction'] = '0'
                elif access_rule['ipv4']['action'].lower() in ['drop', 'discard']:
                    sonicwall_config['policies'][rule_num]['policyAction'] = '1'
                elif access_rule['ipv4']['action'].lower() == 'allow':
                    sonicwall_config['policies'][rule_num]['policyAction'] = '2'
                else:
                    log(access_rule)
                sonicwall_config['policies'][rule_num]['policySrcZone'] = [access_rule['ipv4']['from']]
                sonicwall_config['policies'][rule_num]['policyDstZone'] = [access_rule['ipv4']['to']]
                sonicwall_config['policies'][rule_num]['policyName'] = access_rule['ipv4']['name']
                if 'any' in access_rule['ipv4']['source']['address']:
                    sonicwall_config['policies'][rule_num]['policySrcNet'] = ['']
                elif 'name' in access_rule['ipv4']['source']['address']:
                    sonicwall_config['policies'][rule_num]['policySrcNet'] = [
                        access_rule['ipv4']['source']['address']['name']]
                elif 'group' in access_rule['ipv4']['source']['address']:
                    sonicwall_config['policies'][rule_num]['policySrcNet'] = [
                        access_rule['ipv4']['source']['address']['group']]
                else:
                    sonicwall_config['policies'][rule_num]['policySrcNet'] = ['']
                    log('!-- Warning Unknown Policy policySrcNet')

                if 'any' in access_rule['ipv4']['destination']['address']:
                    sonicwall_config['policies'][rule_num]['policyDstNet'] = ['']
                elif 'name' in access_rule['ipv4']['destination']['address']:
                    sonicwall_config['policies'][rule_num]['policyDstNet'] = [
                        access_rule['ipv4']['destination']['address']['name']]
                elif 'group' in access_rule['ipv4']['destination']['address']:
                    sonicwall_config['policies'][rule_num]['policyDstNet'] = [
                        access_rule['ipv4']['destination']['address']['group']]
                else:
                    sonicwall_config['policies'][rule_num]['policyDstNet'] = ['']
                    log('!-- Warning Unknown Policy policyDstNet')

                if 'any' in access_rule['ipv4']['service']:
                    sonicwall_config['policies'][rule_num]['policyDstSvc'] = ['']
                elif 'group' in access_rule['ipv4']['service']:
                    sonicwall_config['policies'][rule_num]['policyDstSvc'] = [access_rule['ipv4']['service']['group']]
                elif 'name' in access_rule['ipv4']['service']:
                    sonicwall_config['policies'][rule_num]['policyDstSvc'] = [access_rule['ipv4']['service']['name']]
                else:
                    sonicwall_config['policies'][rule_num]['policyDstSvc'] = ['']
                    log('!-- Warning Unknown Policy policyDstSvc')

                sonicwall_config['policies'][rule_num]['policyComment'] = access_rule['ipv4']['comment']
                if access_rule['ipv4']['logging']:
                    sonicwall_config['policies'][rule_num]['policyLog'] = '1'
                else:
                    sonicwall_config['policies'][rule_num]['policyLog'] = '0'
                if access_rule['ipv4']['enable']:
                    sonicwall_config['policies'][rule_num]['policyEnabled'] = '1'
                else:
                    sonicwall_config['policies'][rule_num]['policyEnabled'] = '0'
                sonicwall_config['policies'][rule_num]['policyProps'] = ''  ## unknown for sonicwall6.5 policies
                sonicwall_config['policies'][rule_num]['policyUUID'] = access_rule['ipv4']['uuid']
                # log(json.dumps(access_rule, indent=3))
                # log(json.dumps(sonicwall_config['policies'][rule_num], indent=3))
                # log('-' *100)
                rule_num_int += 1

            # policyV6_props = ['policyActionV6', 'policySrcZoneV6', 'policyDstZoneV6', 'policySrcNetV6', 'policyDstNetV6', 'policyDstSvcV6', 'policyCommentV6', 'policyLogV6', 'policyEnabledV6', 'policyPropsV6' ]

            log('!-- Reading IPv6 Security Policy Objects')
            url = 'https://{}/api/sonicos/access-rules/ipv6'.format(ip)
            result = session.get(url=url, data=post_data, verify=False, timeout=options.timeout_sw_api)
            debug(result.text)
            security_ipv6 = json.loads(result.text)
            if 'access_rules' in security_ipv6:
                debug(security_ipv6)
                debug('{:20.20} {:20.20} {}'.format('Length', ' Security Policies', len(security_ipv6['access_rules'])))
                rule_num_int = 0
                for access_rule in security_ipv6['access_rules']:
                    # {'ipv4': {'schedule': {'always_on': True}, 'geo_ip_filter': False, 'comment': 'Auto-added management rule', 'name': '',
                    # 'source': {'port': {'any': True}, 'address': {'any': True}}, 'sip': False, 'udp': {'timeout': 30}, 'h323': False, 'packet_monitoring': False, 'from': 'LAN', 'quality_of_service': {'class_of_service': {}, 'dscp': {'preserve': True}},
                    # 'service': {'group': 'Ping'}, 'fragments': True, 'max_connections': 100, 'flow_reporting': False, 'tcp': {'timeout': 15, 'urgent': True}, 'logging': True, 'botnet_filter': False, 'enable': True, 'priority': {'manual': 1}, 'connection_limit': {'source': {}, 'destination': {}}, 'dpi': True, 'action': 'allow', 'uuid': '00b7ea07-d3f5-1e66-0700-c0eae46b8088', 'to': 'LAN',
                    # 'users': {'excluded': {'none': True}, 'included': {'all': True}}, 'dpi_ssl': {'server': True, 'client': True}, 'management': True, 'destination': {'address': {'group': 'All X0 Management IP'}}}}
                    # policy_props = ['policyAction', 'policySrcZone', 'policyDstZone', 'policySrcNet', 'policyDstNet', 'policyDstSvc', 'policyDstApps', 'policyComment', 'policyLog', 'policyEnabled', 'policyProps' ]
                    # policyV6_props = ['policyActionV6', 'policySrcZoneV6', 'policyDstZoneV6', 'policySrcNetV6', 'policyDstNetV6', 'policyDstSvcV6', 'policyCommentV6', 'policyLogV6', 'policyEnabledV6', 'policyPropsV6' ]

                    rule_num = str(rule_num_int)
                    debug(access_rule)
                    # rule_num=str(access_rule['ipv6']['priority']['manual'])
                    sonicwall_config['policiesV6'][rule_num] = OrderedDict()

                    sonicwall_config['policiesV6'][rule_num]['policyAction'] = ''
                    sonicwall_config['policiesV6'][rule_num]['policySrcZone'] = ''
                    sonicwall_config['policiesV6'][rule_num]['policyDstZone'] = ''
                    sonicwall_config['policiesV6'][rule_num]['policySrcNet'] = ''
                    sonicwall_config['policiesV6'][rule_num]['policyDstNet'] = ''
                    sonicwall_config['policiesV6'][rule_num]['policyDstSvc'] = ''
                    sonicwall_config['policiesV6'][rule_num]['policyDstApps'] = ''
                    sonicwall_config['policiesV6'][rule_num]['policyComment'] = ''
                    sonicwall_config['policiesV6'][rule_num]['policyLog'] = ''
                    sonicwall_config['policiesV6'][rule_num]['policyEnabled'] = ''
                    sonicwall_config['policiesV6'][rule_num]['policyProps'] = ''
                    sonicwall_config['policiesV6'][rule_num]['policyUUID'] = ''
                    sonicwall_config['policiesV6'][rule_num]['policyName'] = "Empty"
                    sonicwall_config['policiesV6'][rule_num]['policyNum'] = ''
                    sonicwall_config['policiesV6'][rule_num]['policyUiNum'] = ''
                    sonicwall_config['policiesV6'][rule_num]['policyDstApps'] = ['']
                    if access_rule['ipv6']['action'].lower() == 'deny':
                        sonicwall_config['policiesV6'][rule_num]['policyAction'] = '0'
                    elif access_rule['ipv6']['action'].lower() in ['drop', 'discard']:
                        sonicwall_config['policiesV6'][rule_num]['policyAction'] = '1'
                    elif access_rule['ipv6']['action'].lower() == 'allow':
                        sonicwall_config['policiesV6'][rule_num]['policyAction'] = '2'
                    else:
                        log(access_rule)
                    sonicwall_config['policiesV6'][rule_num]['policySrcZone'] = [access_rule['ipv6']['from']]
                    sonicwall_config['policiesV6'][rule_num]['policyDstZone'] = [access_rule['ipv6']['to']]

                    if 'any' in access_rule['ipv6']['source']['address']:
                        sonicwall_config['policiesV6'][rule_num]['policySrcNet'] = ['']
                    elif 'name' in access_rule['ipv6']['source']['address']:
                        sonicwall_config['policiesV6'][rule_num]['policySrcNet'] = [
                            access_rule['ipv6']['source']['address']['name']]
                    elif 'group' in access_rule['ipv6']['source']['address']:
                        sonicwall_config['policiesV6'][rule_num]['policySrcNet'] = [
                            access_rule['ipv6']['source']['address']['group']]
                    else:
                        sonicwall_config['policiesV6'][rule_num]['policySrcNet'] = ['']
                        log('!-- Warning Unknown Policy policySrcNet')

                    if 'any' in access_rule['ipv6']['destination']['address']:
                        sonicwall_config['policiesV6'][rule_num]['policyDstNet'] = ['']
                    elif 'name' in access_rule['ipv6']['destination']['address']:
                        sonicwall_config['policiesV6'][rule_num]['policyDstNet'] = [
                            access_rule['ipv6']['destination']['address']['name']]
                    elif 'group' in access_rule['ipv6']['destination']['address']:
                        sonicwall_config['policiesV6'][rule_num]['policyDstNet'] = [
                            access_rule['ipv6']['destination']['address']['group']]
                    else:
                        sonicwall_config['policiesV6'][rule_num]['policyDstNet'] = ['']
                        log('!-- Warning Unknown Policy policyDstNet')

                    if 'any' in access_rule['ipv6']['service']:
                        sonicwall_config['policiesV6'][rule_num]['policyDstSvc'] = ['']
                    elif 'group' in access_rule['ipv6']['service']:
                        sonicwall_config['policiesV6'][rule_num]['policyDstSvc'] = [
                            access_rule['ipv6']['service']['group']]
                    elif 'name' in access_rule['ipv6']['service']:
                        sonicwall_config['policiesV6'][rule_num]['policyDstSvc'] = [
                            access_rule['ipv6']['service']['name']]
                    else:
                        sonicwall_config['policiesV6'][rule_num]['policyDstSvc'] = ['']
                        log('!-- Warning Unknown Policy policyDstSvc')

                    sonicwall_config['policiesV6'][rule_num]['policyComment'] = access_rule['ipv6']['comment']

                    if access_rule['ipv6']['logging']:
                        sonicwall_config['policiesV6'][rule_num]['policyLog'] = '1'
                    else:
                        sonicwall_config['policiesV6'][rule_num]['policyLog'] = '0'
                    if access_rule['ipv6']['enable']:
                        sonicwall_config['policiesV6'][rule_num]['policyEnabled'] = '1'
                    else:
                        sonicwall_config['policies'][rule_num]['policyEnabled'] = '0'
                    sonicwall_config['policiesV6'][rule_num]['policyProps'] = ''  ## unknown for sonicwall6.5 policies
                    sonicwall_config['policiesV6'][rule_num]['policyUUID'] = access_rule['ipv6']['uuid']
                    # log(json.dumps(access_rule, indent=3))
                    # log(json.dumps(sonicwall_config['policies'][rule_num], indent=3))
                    # log('-' *100)
                    rule_num_int += 1

            log('!-- Reading NAT Policy Objects')
            url = 'https://{}/api/sonicos/nat-policies/ipv4'.format(ip)
            result = session.get(url=url, data=post_data, verify=False, timeout=options.timeout_sw_api)
            nat_ipv4 = json.loads(result.text)
            # log('NATPOL: ', json.dumps(nat_ipv4['nat_policies'][28], indent=2))
            # {'ipv4': {'translated_service': {'original': True}, 'comment': 'Management NAT Policy', 'outbound': 'MGMT', 'source': {'any': True}, 'service': {'name': 'SNMP'}, 'enable': True, 'uuid': 'ed660693-3b9a-77f1-0800-c0eae46b8088', 'inbound': 'MGMT', 'name': '', 'translated_source': {'original': True}, 'translated_destination': {'original': True}, 'destination': {'name': 'MGMT IP'}}}
            # nat_props = [ 'natPolicyOrigSrc', 'natPolicyOrigDst', 'natPolicyOrigSvc', 'natPolicyTransSrc', 'natPolicyTransDst', 'natPolicyTransSvc', 'natPolicySrcIface', 'natPolicyDstIface', 'natPolicyEnabled', 'natPolicyComment', 'natPolicyProperties', 'natPolicyName' ]

            rule_num_int = 0
            for nat_rule in nat_ipv4['nat_policies']:
                rule_num = str(rule_num_int)
                # log('NAT: ', json.dumps(nat_rule, indent=4))
                sonicwall_config['nat'][rule_num] = OrderedDict()
                sonicwall_config['nat'][rule_num]['natPolicyName'] = nat_rule['ipv4']['name']
                sonicwall_config['nat'][rule_num]['natPolicyNum'] = ''
                sonicwall_config['nat'][rule_num]['natPolicyUiNum'] = ''
                if nat_rule['ipv4']['enable']:
                    sonicwall_config['nat'][rule_num]['natPolicyEnabled'] = '1'
                else:
                    sonicwall_config['nat'][rule_num]['natPolicyEnabled'] = '0'
                sonicwall_config['nat'][rule_num]['natPolicySrcIface'] = nat_rule['ipv4']['inbound']
                sonicwall_config['nat'][rule_num]['natPolicyDstIface'] = nat_rule['ipv4']['outbound']
                if 'any' in nat_rule['ipv4']['source']:
                    sonicwall_config['nat'][rule_num]['natPolicyOrigSrc'] = ['']
                elif 'name' in nat_rule['ipv4']['source']:
                    sonicwall_config['nat'][rule_num]['natPolicyOrigSrc'] = [nat_rule['ipv4']['source']['name']]
                elif 'group' in nat_rule['ipv4']['source']:
                    sonicwall_config['nat'][rule_num]['natPolicyOrigSrc'] = [nat_rule['ipv4']['source']['group']]
                else:
                    sonicwall_config['nat'][rule_num]['natPolicyOrigSrc'] = ['']
                    log('!-- Warning reading NAT OrigSrc')

                if 'any' in nat_rule['ipv4']['destination']:
                    sonicwall_config['nat'][rule_num]['natPolicyOrigDst'] = ['']
                elif 'name' in nat_rule['ipv4']['destination']:
                    sonicwall_config['nat'][rule_num]['natPolicyOrigDst'] = [nat_rule['ipv4']['destination']['name']]
                elif 'group' in nat_rule['ipv4']['destination']:
                    sonicwall_config['nat'][rule_num]['natPolicyOrigDst'] = [nat_rule['ipv4']['destination']['group']]
                else:
                    sonicwall_config['nat'][rule_num]['natPolicyOrigDst'] = ['']
                    log('!-- Warning reading NAT OrigDst')

                if 'any' in nat_rule['ipv4']['service']:
                    sonicwall_config['nat'][rule_num]['natPolicyOrigSvc'] = ['']
                elif 'name' in nat_rule['ipv4']['service']:
                    sonicwall_config['nat'][rule_num]['natPolicyOrigSvc'] = [nat_rule['ipv4']['service']['name']]
                elif 'group' in nat_rule['ipv4']['service']:
                    sonicwall_config['nat'][rule_num]['natPolicyOrigSvc'] = [nat_rule['ipv4']['service']['group']]
                else:
                    sonicwall_config['nat'][rule_num]['natPolicyOrigSvc'] = ['']
                    log('!-- Warning reading NAT TransOrigSvc')

                if 'original' in nat_rule['ipv4']['translated_source']:
                    sonicwall_config['nat'][rule_num]['natPolicyTransSrc'] = ['']
                elif 'name' in nat_rule['ipv4']['translated_source']:
                    sonicwall_config['nat'][rule_num]['natPolicyTransSrc'] = [
                        nat_rule['ipv4']['translated_source']['name']]
                elif 'group' in nat_rule['ipv4']['translated_source']:
                    sonicwall_config['nat'][rule_num]['natPolicyTransSrc'] = [
                        nat_rule['ipv4']['translated_source']['group']]
                else:
                    sonicwall_config['nat'][rule_num]['natPolicyTransSrc'] = ['']
                    log('!-- Warning reading NAT TransSrc')

                if 'original' in nat_rule['ipv4']['translated_destination']:
                    sonicwall_config['nat'][rule_num]['natPolicyTransDst'] = ['']
                elif 'name' in nat_rule['ipv4']['translated_destination']:
                    sonicwall_config['nat'][rule_num]['natPolicyTransDst'] = [
                        nat_rule['ipv4']['translated_destination']['name']]
                elif 'group' in nat_rule['ipv4']['translated_destination']:
                    sonicwall_config['nat'][rule_num]['natPolicyTransDst'] = [
                        nat_rule['ipv4']['translated_destination']['group']]
                else:
                    sonicwall_config['nat'][rule_num]['natPolicyTransDst'] = ['']
                    log('!-- Warning reading NAT TransDst')

                if 'original' in nat_rule['ipv4']['translated_service']:
                    sonicwall_config['nat'][rule_num]['natPolicyTransSvc'] = ['']
                elif 'name' in nat_rule['ipv4']['translated_service']:
                    sonicwall_config['nat'][rule_num]['natPolicyTransSvc'] = [
                        nat_rule['ipv4']['translated_service']['name']]
                elif 'group' in nat_rule['ipv4']['translated_service']:
                    sonicwall_config['nat'][rule_num]['natPolicyTransSvc'] = [
                        nat_rule['ipv4']['translated_service']['group']]
                else:
                    sonicwall_config['nat'][rule_num]['natPolicyTransSvc'] = ['']
                    log('!-- Warning reading NAT TransSvc')

                sonicwall_config['nat'][rule_num]['natPolicyProperties'] = ''
                sonicwall_config['nat'][rule_num]['natPolicyUUID'] = nat_rule['ipv4']['uuid']
                sonicwall_config['nat'][rule_num]['natPolicyComment'] = nat_rule['ipv4']['comment']

                rule_num_int += 1

            log('!-- Reading Address Objects')
            url = 'https://{}/api/sonicos/address-objects/ipv4'.format(ip)
            result = session.get(url=url, data=post_data, verify=False, timeout=options.timeout_sw_api)
            addresses_ipv4 = json.loads(result.text)
            debug('{:20.20} {:20.20} {}'.format('Length', ' Addresses', len(addresses_ipv4['address_objects'])))
            # log(addresses_ipv4['address_objects'][0])
            # {'address_objects': [{'ipv4': {'host': {'ip': '10.211.129.170'}, 'name': 'X0 IP', 'zone': 'LAN', 'uuid': 'cfeeb502-52cf-c94a-0100-c0eae46b8088'}}, {'ipv4': {'name': 'X0 Subnet', 'zone': 'LAN', 'uuid': '8d747ea4-5021-c0a5-0100-c0eae46b8088', 'network': {'mask': '255.255.255.0', 'subnet': '10.211.129.0'}}}, {'ipv4': {'host': {'ip': '97.79.140.147'}, 'name': 'X1 IP', 'zone': 'WAN', 'uuid': 'be2eb811-cb10-b105-0100-c0eae46b8088'}},
            # address_props = ['addrObjId', 'addrObjIdDisp', 'addrObjType', 'addrObjZone', 'addrObjProperties', 'addrObjIp1', 'addrObjIp2', 'addrObjComment']
            for address in addresses_ipv4['address_objects']:
                debug(address)
                address_name = address['ipv4']['name']
                sonicwall_config['addresses'][address_name] = OrderedDict()
                sonicwall_config['addresses'][address_name]['addrObjId'] = address_name
                sonicwall_config['addresses'][address_name]['addrObjIdDisp'] = address_name
                sonicwall_config['addresses'][address_name]['addrObjIp1'] = '2.2.2.2'
                sonicwall_config['addresses'][address_name]['addrObjIp2'] = '3.3.3.3'
                if 'host' in address['ipv4']:
                    if 'ip' in address['ipv4']['host']:
                        sonicwall_config['addresses'][address_name]['addrObjType'] = '1'
                        sonicwall_config['addresses'][address_name]['addrObjIp1'] = address['ipv4']['host']['ip']
                        sonicwall_config['addresses'][address_name]['addrObjIp2'] = '255.255.255.255'
                    else:
                        sonicwall_config['addresses'][address_name]['addrObjType'] = '1'  # 512
                        sonicwall_config['addresses'][address_name][
                            'addrObjIp1'] = '0.0.0.0'  # placeholder for undefined built in objects
                        sonicwall_config['addresses'][address_name][
                            'addrObjIp2'] = '255.255.255.255'  # placeholder for undefined built in objects
                if 'range' in address['ipv4']:
                    sonicwall_config['addresses'][address_name]['addrObjType'] = '2'
                    sonicwall_config['addresses'][address_name]['addrObjIp1'] = address['ipv4']['range']['begin']
                    sonicwall_config['addresses'][address_name]['addrObjIp2'] = address['ipv4']['range']['end']
                if 'network' in address['ipv4']:
                    if 'subnet' in address['ipv4']['network']:
                        sonicwall_config['addresses'][address_name]['addrObjType'] = '4'
                        sonicwall_config['addresses'][address_name]['addrObjIp1'] = address['ipv4']['network']['subnet']
                        sonicwall_config['addresses'][address_name]['addrObjIp2'] = address['ipv4']['network']['mask']
                    else:
                        sonicwall_config['addresses'][address_name]['addrObjType'] = '4'  # 2048
                        sonicwall_config['addresses'][address_name][
                            'addrObjIp1'] = '0.0.0.0'  # placeholder for undefined built in objects
                        sonicwall_config['addresses'][address_name][
                            'addrObjIp2'] = '255.255.255.255'  # placeholder for undefined built in objects
                debug(sonicwall_config['addresses'][address_name])

                if 'zone' in address['ipv4']:
                    sonicwall_config['addresses'][address_name]['addrObjZone'] = address['ipv4']['zone']
                else:
                    sonicwall_config['addresses'][address_name][
                        'addrObjZone'] = ''  # placeholder for undefined built in objects

                sonicwall_config['addresses'][address_name]['addrObjProperties'] = ''
                sonicwall_config['addresses'][address_name]['addrObjComment'] = ''
                sonicwall_config['addresses'][address_name]['addrObjColor'] = ''
                sonicwall_config['addresses'][address_name]['addrObjUUID'] = address['ipv4']['uuid']

            log('!-- Reading IPv6 Address Objects')
            url = 'https://{}/api/sonicos/address-objects/ipv6'.format(ip)
            result = session.get(url=url, data=post_data, verify=False, timeout=options.timeout_sw_api)
            addresses_ipv6 = json.loads(result.text)
            debug('{:20.20} {:20.20} {}'.format('Length', ' AddressesV6', len(addresses_ipv6['address_objects'])))
            # log(addresses_ipv4['address_objects'][0])
            # addressV6_props = ['addrObjV6Id', 'addrObjV6IdDisp', 'addrObjV6Type', 'addrObjV6Zone', 'addrObjV6Properties', 'addrObjV6Ip1', 'addrObjV6Ip2', 'addrObjV6PrefixLen']

            # {'address_objects': [{'ipv4': {'host': {'ip': '10.211.129.170'}, 'name': 'X0 IP', 'zone': 'LAN', 'uuid': 'cfeeb502-52cf-c94a-0100-c0eae46b8088'}}, {'ipv4': {'name': 'X0 Subnet', 'zone': 'LAN', 'uuid': '8d747ea4-5021-c0a5-0100-c0eae46b8088', 'network': {'mask': '255.255.255.0', 'subnet': '10.211.129.0'}}}, {'ipv4': {'host': {'ip': '97.79.140.147'}, 'name': 'X1 IP', 'zone': 'WAN', 'uuid': 'be2eb811-cb10-b105-0100-c0eae46b8088'}},
            # address_props = ['addrObjId', 'addrObjIdDisp', 'addrObjType', 'addrObjZone', 'addrObjProperties', 'addrObjIp1', 'addrObjIp2', 'addrObjComment']
            for address in addresses_ipv6['address_objects']:
                # debug('IPv6:',address)
                address_name = address['ipv6']['name']
                sonicwall_config['addressesV6'][address_name] = OrderedDict()
                sonicwall_config['addressesV6'][address_name]['addrObjId'] = address_name
                sonicwall_config['addressesV6'][address_name]['addrObjIdDisp'] = address_name
                if 'host' in address['ipv6']:
                    sonicwall_config['addressesV6'][address_name]['addrObjType'] = '1'
                    if 'ip' in address['ipv6']['host']:
                        sonicwall_config['addressesV6'][address_name]['addrObjIp1'] = address['ipv6']['host']['ip']
                        sonicwall_config['addressesV6'][address_name]['addrObjIp2'] = '/128'
                        sonicwall_config['addressesV6'][address_name]['addrObjV6PrefixLen'] = '/128'
                    else:
                        sonicwall_config['addressesV6'][address_name][
                            'addrObjIp1'] = '::'  # placeholder for undefined built in objects
                        sonicwall_config['addressesV6'][address_name][
                            'addrObjIp2'] = '::'  # placeholder for undefined built in objects
                        sonicwall_config['addressesV6'][address_name]['addrObjV6PrefixLen'] = '/128'
                if 'range' in address['ipv6']:
                    sonicwall_config['addressesV6'][address_name]['addrObjType'] = '2'
                    sonicwall_config['addressesV6'][address_name]['addrObjIp1'] = address['ipv6']['host']['ip']
                    sonicwall_config['addressesV6'][address_name]['addrObjIp2'] = address['ipv6']['host']['ip']
                    sonicwall_config['addressesV6'][address_name]['addrObjV6PrefixLen'] = ''
                if 'network' in address['ipv6']:
                    sonicwall_config['addressesV6'][address_name]['addrObjType'] = '4'
                    if 'subnet' in address['ipv6']['network']:
                        sonicwall_config['addressesV6'][address_name]['addrObjIp1'] = address['ipv6']['network'][
                            'subnet']
                        sonicwall_config['addressesV6'][address_name]['addrObjIp2'] = address['ipv6']['network']['mask']
                        sonicwall_config['addressesV6'][address_name]['addrObjV6PrefixLen'] = \
                        address['ipv6']['network']['mask']
                    else:
                        sonicwall_config['addressesV6'][address_name][
                            'addrObjIp1'] = '::'  # placeholder for undefined built in objects
                        sonicwall_config['addressesV6'][address_name][
                            'addrObjIp2'] = '::'  # placeholder for undefined built in objects
                        sonicwall_config['addressesV6'][address_name]['addrObjV6PrefixLen'] = '/64'
                debug(sonicwall_config['addressesV6'][address_name])

                if 'zone' in address['ipv6']:
                    sonicwall_config['addressesV6'][address_name]['addrObjZone'] = address['ipv6']['zone']
                else:
                    sonicwall_config['addressesV6'][address_name][
                        'addrObjZone'] = ''  # placeholder for undefined built in objects

                sonicwall_config['addressesV6'][address_name]['addrObjProperties'] = ''
                sonicwall_config['addressesV6'][address_name]['addrObjComment'] = ''
                sonicwall_config['addressesV6'][address_name]['addrObjColor'] = ''
                sonicwall_config['addressesV6'][address_name]['addrObjUUID'] = address['ipv6']['uuid']

            log('!-- Reading Address Group Objects')
            url = 'https://{}/api/sonicos/address-groups/ipv4'.format(ip)
            result = session.get(url=url, data=post_data, verify=False, timeout=options.timeout_sw_api)
            addresses_groups_ipv4 = json.loads(result.text)
            debug('{:20.20} {:20.20} {}'.format('Length', ' Address Groups',
                                                len(addresses_groups_ipv4['address_groups'])))
            for address_group in addresses_groups_ipv4['address_groups']:
                address_name = address_group['ipv4']['name']
                sonicwall_config['addresses'][address_name] = OrderedDict()
                sonicwall_config['addresses'][address_name]['addrObjId'] = address_name
                sonicwall_config['addresses'][address_name]['addrObjIdDisp'] = address_name
                sonicwall_config['addresses'][address_name]['addrObjUUID'] = address_group['ipv4']['uuid']
                sonicwall_config['addresses'][address_name]['addrObjType'] = '8'
                sonicwall_config['addresses'][address_name]['addrObjZone'] = ''
                sonicwall_config['addresses'][address_name]['addrObjProperties'] = ''
                sonicwall_config['addresses'][address_name]['addrObjIp1'] = '0.0.0.0'
                sonicwall_config['addresses'][address_name]['addrObjIp2'] = '0.0.0.0'
                sonicwall_config['addresses'][address_name]['addrObjComment'] = ''
                sonicwall_config['addresses'][address_name]['addrObjColor'] = ''

                sonicwall_config['addressmappings'][address_name] = []
                debug(address_group)
                try:
                    if 'address_object' in address_group['ipv4']:
                        for address_object in address_group['ipv4']['address_object']['ipv4']:
                            sonicwall_config['addressmappings'][address_name].append(address_object['name'])
                except:
                    pass
                try:
                    if 'address_group' in address_group['ipv4']:
                        for address_object in address_group['ipv4']['address_group']['ipv4']:
                            sonicwall_config['addressmappings'][address_name].append(address_object['name'])
                except:
                    pass
                try:
                    if 'fqdn' in address_group['ipv4']['address_object']:
                        for address_object in address_group['ipv4']['address_object']['fqdn']:
                            sonicwall_config['addressmappings'][address_name].append(address_object['name'])
                except:
                    pass

                # log(x)
                # log(addresses_groups_ipv4['address_groups'][0])
            # {'ipv4': {'address_object': {'ipv4': [{'name': 'X0 Subnet'}]}, 'uuid': '9b9b3c30-59f7-f1d4-0200-c0eae46b8088', 'name': 'LAN Subnets'}}

            sonicwall_config['addresses'] = add_IPv4Network(sonicwall_config['addresses'])

            log('!-- Reading IPv6 Address Group Objects')
            url = 'https://{}/api/sonicos/address-groups/ipv6'.format(ip)
            result = session.get(url=url, data=post_data, verify=False, timeout=options.timeout_sw_api)
            addresses_groups_ipv6 = json.loads(result.text)
            debug('{:20.20} {:20.20} {}'.format('Length', ' Address GroupsV6',
                                                len(addresses_groups_ipv4['address_groups'])))
            for address_group in addresses_groups_ipv6['address_groups']:
                debug('IPv6:', address_group)
                address_name = address_group['ipv6']['name']
                sonicwall_config['addressesV6'][address_name] = OrderedDict()
                sonicwall_config['addressesV6'][address_name]['addrObjId'] = address_name
                sonicwall_config['addressesV6'][address_name]['addrObjIdDisp'] = address_name
                sonicwall_config['addressesV6'][address_name]['addrObjUUID'] = address_group['ipv6']['uuid']
                sonicwall_config['addressesV6'][address_name]['addrObjType'] = '8'
                sonicwall_config['addressesV6'][address_name]['addrObjZone'] = ''
                sonicwall_config['addressesV6'][address_name]['addrObjProperties'] = ''
                sonicwall_config['addressesV6'][address_name]['addrObjIp1'] = '::'
                sonicwall_config['addressesV6'][address_name]['addrObjIp2'] = '::'
                sonicwall_config['addressesV6'][address_name]['addrObjComment'] = ''
                sonicwall_config['addressesV6'][address_name]['addrObjColor'] = ''

                sonicwall_config['addressmappings'][address_name] = []
                try:
                    if 'address_object' in address_group['ipv6']:
                        for address_object in address_group['ipv6']['address_object']['ipv6']:
                            sonicwall_config['addressmappings'][address_name].append(address_object['name'])
                    # for address_object in address_group['ipv4']['address_object']['ipv6']:
                except:
                    pass
                try:
                    if 'address_group' in address_group['ipv6']:
                        for address_object in address_group['ipv6']['address_group']['ipv6']:
                            # debug(address_object)
                            sonicwall_config['addressmappings'][address_name].append(address_object['name'])
                except:
                    pass
                try:
                    if 'fqdn' in address_group['ipv6']['address_object']:
                        for address_object in address_group['ipv6']['address_object']['fqdn']:
                            sonicwall_config['addressmappings'][address_name].append(address_object['name'])
                except:
                    pass

                '''
                if 'address_object' in address_group['ipv6']:
                    for address_object in address_group['ipv6']['address_object']['ipv6']:
                        #debug(address_object)
                        sonicwall_config['addressmappings'][address_name].append(address_object['name'])
                if 'address_group' in address_group['ipv6']:
                    for address_object in address_group['ipv6']['address_group']['ipv6']:
                        #debug(address_object)
                        sonicwall_config['addressmappings'][address_name].append(address_object['name'])
                '''

            log('!-- Reading Address FQDN Objects')
            url = 'https://{}/api/sonicos/address-objects/fqdn'.format(ip)
            result = session.get(url=url, data=post_data, verify=False, timeout=options.timeout_sw_api)
            # log(result.text)
            addresses_fqdn = json.loads(result.text)
            # log(addresses_fqdn['address_objects'][0])
            # {'fqdn': {'name': 'Syslog Server(0): austlrr2csdep01.us.dell.com', 'uuid': '9902ae74-9724-c051-0100-c0eae46b8088', 'domain': 'austlrr2csdep01.us.dell.com', 'dns_ttl': 0}}
            # addressfqdn_props = ['addrObjFqdnId', 'addrObjFqdnType', 'addrObjFqdnZone', 'addrObjFqdnProperties', 'addrObjFqdn']
            # log(addresses_fqdn)
            if 'address_objects' in addresses_fqdn:
                for address_fqdn in addresses_fqdn['address_objects']:
                    # log(address_fqdn)
                    try:
                        # log(address_fqdn)
                        address_name = address_fqdn['fqdn']['name']
                        sonicwall_config['addressesfqdn'][address_name] = OrderedDict()
                        sonicwall_config['addressesfqdn'][address_name]['addrObjFqdnId'] = address_fqdn['fqdn']['name']
                        sonicwall_config['addressesfqdn'][address_name]['addrObjFqdnType'] = ''  # address_fqdn['fqdn']
                        sonicwall_config['addressesfqdn'][address_name]['addrObjFqdnTTL'] = address_fqdn['fqdn'][
                            'dns_ttl']
                        sonicwall_config['addressesfqdn'][address_name]['addrObjFqdn'] = address_fqdn['fqdn']['domain']
                        sonicwall_config['addressesfqdn'][address_name]['addrObjFqdnUUID'] = address_fqdn['fqdn'][
                            'uuid']
                        if 'zone' in address_fqdn['fqdn']:
                            sonicwall_config['addressesfqdn'][address_name]['addrObjFqdnZone'] = address_fqdn['fqdn'][
                                'zone']
                        else:
                            sonicwall_config['addressesfqdn'][address_name]['addrObjFqdnZone'] = ''
                        # log('-'*180)
                        # log(sonicwall_config['addressesfqdn'][address_name])
                    except Exception as e:
                        log(e)

            log('!-- Reading Service Objects')
            url = 'https://{}/api/sonicos/service-objects'.format(ip)
            result = session.get(url=url, data=post_data, verify=False, timeout=options.timeout_sw_api)
            services = json.loads(result.text)
            debug('{:20.20} {:20.20} {}'.format('Length', ' Services', len(services['service_objects'])))
            # {'name': 'HTTP', 'uuid': 'f40b27d6-b8b9-a4fc-0300-c0eae46b8088', 'tcp': {'end': 80, 'begin': 80}}
            #   service_props = ['svcObjId', 'svcObjType', 'svcObjProperties', 'svcObjIpType', 'svcObjPort1', 'svcObjPort2', 'svcObjManagement', 'svcObjHigherPrecedence', 'svcObjComment']
            icmp_types = {'redirect': '5',
                          'echo-reply': '0',
                          'echo-request': '8',
                          'timestamp': '13',
                          'timestamp-reply': '14',
                          'alternative-host': '6'

                          }
            for service in services['service_objects']:
                debug(service)
                service_name = service['name']
                sonicwall_config['services'][service_name] = OrderedDict()
                sonicwall_config['services'][service_name]['svcObjId'] = service_name
                sonicwall_config['services'][service_name]['svcObjComment'] = ''
                sonicwall_config['services'][service_name]['svcObjHigherPrecedence'] = 'off'
                sonicwall_config['services'][service_name]['svcObjManagement'] = '0'
                sonicwall_config['services'][service_name]['svcObjProperties'] = '0'
                sonicwall_config['services'][service_name]['svcObjSrcPort'] = '0'

                if 'tcp' in service:
                    sonicwall_config['services'][service_name]['svcObjType'] = '6'
                    sonicwall_config['services'][service_name]['svcObjIpType'] = '6'
                    sonicwall_config['services'][service_name]['svcObjPort1'] = str(service['tcp']['begin'])
                    sonicwall_config['services'][service_name]['svcObjPort2'] = str(service['tcp']['end'])
                    sonicwall_config['services'][service_name]['svcObjUUID'] = service['uuid']
                elif 'udp' in service:
                    sonicwall_config['services'][service_name]['svcObjType'] = '17'
                    sonicwall_config['services'][service_name]['svcObjIpType'] = '17'
                    sonicwall_config['services'][service_name]['svcObjPort1'] = str(service['udp']['begin'])
                    sonicwall_config['services'][service_name]['svcObjPort2'] = str(service['udp']['end'])
                    sonicwall_config['services'][service_name]['svcObjUUID'] = service['uuid']
                elif 'icmp' in service:
                    sonicwall_config['services'][service_name]['svcObjType'] = '1'
                    sonicwall_config['services'][service_name]['svcObjIpType'] = '1'
                    sonicwall_config['services'][service_name]['svcObjPort1'] = service['icmp']
                    sonicwall_config['services'][service_name]['svcObjPort2'] = service['icmp']
                    sonicwall_config['services'][service_name]['svcObjUUID'] = service['uuid']
                elif 'icmpv6' in service:
                    sonicwall_config['services'][service_name]['svcObjType'] = '99'
                    sonicwall_config['services'][service_name]['svcObjIpType'] = '99'
                    sonicwall_config['services'][service_name]['svcObjPort1'] = service['icmpv6']
                    sonicwall_config['services'][service_name]['svcObjPort2'] = ''
                    sonicwall_config['services'][service_name]['svcObjUUID'] = service['uuid']
                elif 'igmp' in service:
                    sonicwall_config['services'][service_name]['svcObjType'] = '99'
                    sonicwall_config['services'][service_name]['svcObjIpType'] = '99'
                    sonicwall_config['services'][service_name]['svcObjPort1'] = service['igmp']
                    sonicwall_config['services'][service_name]['svcObjPort2'] = ''
                    sonicwall_config['services'][service_name]['svcObjUUID'] = service['uuid']
                elif 'esp' in service:
                    sonicwall_config['services'][service_name]['svcObjType'] = '99'
                    sonicwall_config['services'][service_name]['svcObjIpType'] = '99'
                    sonicwall_config['services'][service_name]['svcObjPort1'] = service['esp']
                    sonicwall_config['services'][service_name]['svcObjPort2'] = ''
                    sonicwall_config['services'][service_name]['svcObjUUID'] = service['uuid']
                elif 'gre' in service:
                    sonicwall_config['services'][service_name]['svcObjType'] = '47'
                    sonicwall_config['services'][service_name]['svcObjIpType'] = '47'
                    sonicwall_config['services'][service_name]['svcObjPort1'] = '1'  # service['gre']
                    sonicwall_config['services'][service_name]['svcObjPort2'] = '65535'
                    sonicwall_config['services'][service_name]['svcObjUUID'] = service['uuid']
                elif '6over4' in service:
                    sonicwall_config['services'][service_name]['svcObjType'] = '41'
                    sonicwall_config['services'][service_name]['svcObjIpType'] = '41'
                    sonicwall_config['services'][service_name]['svcObjPort1'] = '1'  # service['6over4']
                    sonicwall_config['services'][service_name]['svcObjPort2'] = '1'
                    sonicwall_config['services'][service_name]['svcObjUUID'] = service['uuid']
                elif 'ipcomp' in service:
                    sonicwall_config['services'][service_name]['svcObjType'] = '108'
                    sonicwall_config['services'][service_name]['svcObjIpType'] = '108'
                    sonicwall_config['services'][service_name]['svcObjPort1'] = '1'  # service['ipcomp']
                    sonicwall_config['services'][service_name]['svcObjPort2'] = '1'
                    sonicwall_config['services'][service_name]['svcObjUUID'] = service['uuid']
                else:
                    sonicwall_config['services'][service_name]['svcObjType'] = '99'
                    sonicwall_config['services'][service_name]['svcObjIpType'] = '99'
                    sonicwall_config['services'][service_name]['svcObjPort1'] = '99'
                    sonicwall_config['services'][service_name]['svcObjPort2'] = ''
                    sonicwall_config['services'][service_name]['svcObjUUID'] = service['uuid']
                    debug(service)
                    # if sonicwall_config['services'][service_name]['svcObjPort1'] == sonicwall_config['services'][service_name]['svcObjPort2']:  ## if service object type a single port or range
                sonicwall_config['services'][service_name]['svcObjType'] = '1'
                # else:
                #    sonicwall_config['services'][service_name]['svcObjType']='2'

            log('!-- Reading Service Group Objects')
            url = 'https://{}/api/sonicos/service-groups'.format(ip)
            result = session.get(url=url, data=post_data, verify=False, timeout=options.timeout_sw_api)
            service_groups = json.loads(result.text)
            # log(json.dumps(service_groups['service_groups'], indent=3))
            # {'name': 'HTTP', 'uuid': 'f40b27d6-b8b9-a4fc-0300-c0eae46b8088', 'tcp': {'end': 80, 'begin': 80}}
            #   service_props = ['svcObjId', 'svcObjType', 'svcObjProperties', 'svcObjIpType', 'svcObjPort1', 'svcObjPort2', 'svcObjManagement', 'svcObjHigherPrecedence', 'svcObjComment']
            debug('{:20.20} {:20.20} {}'.format('Length', ' Service Groups', len(service_groups['service_groups'])))
            debug(service_groups)
            for service in service_groups['service_groups']:
                # log(service)
                service_name = service['name']
                sonicwall_config['services'][service_name] = OrderedDict()
                sonicwall_config['services'][service_name]['svcObjId'] = service_name
                sonicwall_config['services'][service_name]['svcObjType'] = '2'
                sonicwall_config['services'][service_name]['svcObjIpType'] = '0'

                sonicwall_config['servicemappings'][service_name] = []
                if 'service_object' in service:
                    for service_object in service['service_object']:
                        sonicwall_config['servicemappings'][service_name].append(service_object['name'])
                        # log(service_object['name'])
                if 'service_group' in service:
                    for service_group in service['service_group']:
                        # log(service_group['name'])
                        sonicwall_config['servicemappings'][service_name].append(service_group['name'])

            log('!-- Reading Interface Objects')
            url = 'https://{}/api/sonicos/interfaces/ipv4'.format(ip)
            result = session.get(url=url, data=post_data, verify=False, timeout=options.timeout_sw_api)
            interfaces_ipv4 = json.loads(result.text)
            # log(interfaces_ipv4['interfaces'][0])
            # {'ipv4': {'routed_mode': {}, 'auto_discovery': False, 'flow_reporting': True, 'comment': 'Default LAN', 'name': 'X0', 'port': {'redundancy_aggregation': False}, 'user_login': {'https': False}, 'https_redirect': True, 'cos_8021p': False, 'ip_assignment': {'zone': 'LAN', 'mode': {'static': {'netmask': '255.255.255.0', 'ip': '10.211.129.170', 'gateway': '10.211.129.1'}}}, 'management': {'snmp': False, 'https': True, 'ping': True, 'ssh': True}, 'mtu': 1500, 'multicast': False, 'asymmetric_route': False, 'link_speed': {'auto_negotiate': True}, 'exclude_route': False, 'shutdown_port': False, 'mac': {'default': True}}}
            # interface_props = ['iface_ifnum', 'iface_type', 'iface_name', 'interface_Zone', 'iface_comment', 'iface_static_ip', 'iface_static_mask', 'iface_static_gateway', 'iface_lan_ip', 'iface_lan_mask', 'iface_lan_default_gw', 'iface_mgmt_ip', 'iface_mgmt_netmask', 'iface_mgmt_default_gw', 'iface_static_gateway', 'iface_vlan_tag', 'iface_comment', 'iface_http_mgmt',
            # 'iface_https_mgmt', 'iface_ssh_mgmt', 'iface_ping_mgmt', 'iface_snmp_mgmt', 'portShutdown']
            interface_num_int = 0
            for interface in interfaces_ipv4['interfaces']:
                interface_num = str(interface_num_int)
                debug(interface)
                sonicwall_config['interfaces'][interface_num] = OrderedDict()
                sonicwall_config['interfaces'][interface_num]['iface_name'] = interface['ipv4']['name']
                sonicwall_config['interfaces'][interface_num]['iface_ifnum'] = str(interface_num)
                sonicwall_config['interfaces'][interface_num]['portShutdown'] = '0'
                sonicwall_config['interfaces'][interface_num]['interface_Zone'] = ''
                sonicwall_config['interfaces'][interface_num]['iface_vlan_tag'] = ''
                sonicwall_config['interfaces'][interface_num]['iface_static_ip'] = '0.0.0.0'
                sonicwall_config['interfaces'][interface_num]['iface_static_mask'] = '255.255.255.0'
                sonicwall_config['interfaces'][interface_num]['iface_static_gateway'] = '255.255.255.0'
                sonicwall_config['interfaces'][interface_num]['iface_lan_ip'] = '0.0.0.0'
                sonicwall_config['interfaces'][interface_num]['iface_lan_mask'] = '255.255.255.0'
                sonicwall_config['interfaces'][interface_num]['iface_lan_default_gw'] = '255.255.255.0'
                sonicwall_config['interfaces'][interface_num]['iface_mgmt_ip'] = '0.0.0.0'
                sonicwall_config['interfaces'][interface_num]['iface_mgmt_netmask'] = '255.255.255.0'
                sonicwall_config['interfaces'][interface_num]['iface_mgmt_default_gw'] = '255.255.255.0'
                sonicwall_config['interfaces'][interface_num]['iface_static_gateway'] = ''
                sonicwall_config['interfaces'][interface_num]['iface_http_mgmt'] = '0'
                sonicwall_config['interfaces'][interface_num]['iface_https_mgmt'] = '0'
                sonicwall_config['interfaces'][interface_num]['iface_ssh_mgmt'] = '0'
                sonicwall_config['interfaces'][interface_num]['iface_ping_mgmt'] = '0'
                sonicwall_config['interfaces'][interface_num]['iface_snmp_mgmt'] = '0'

                # sonicwall_config['interfaces'][interface_num][''iface_vlan_tag'']=interface['ipv4']['']

                if 'vlan' in interface:
                    sonicwall_config['interfaces'][interface_num]['iface_vlan_tag'] = interface['vlan']
                if 'mode' in interface['ipv4']['ip_assignment']:
                    sonicwall_config['interfaces'][interface_num]['interface_Zone'] = \
                    interface['ipv4']['ip_assignment']['zone']
                    if 'static' in interface['ipv4']['ip_assignment']['mode']:
                        debug('STATIC!!!')
                        sonicwall_config['interfaces'][interface_num]['iface_static_ip'] = \
                        interface['ipv4']['ip_assignment']['mode']['static']['ip']
                        sonicwall_config['interfaces'][interface_num]['iface_static_mask'] = \
                        interface['ipv4']['ip_assignment']['mode']['static']['netmask']
                        sonicwall_config['interfaces'][interface_num]['iface_static_gateway'] = \
                        interface['ipv4']['ip_assignment']['mode']['static']['gateway']

                # sonicwall_config['interfaces'][interface_num]['iface_type']=interface['ipv4']['']
                # sonicwall_config['interfaces'][interface_num]['interface_Zone']=interface['ipv4']['']

                if 'comment' in interface['ipv4']:
                    sonicwall_config['interfaces'][interface_num]['iface_comment'] = interface['ipv4']['comment']
                else:
                    sonicwall_config['interfaces'][interface_num]['iface_comment'] = ''

                if 'management' in interface['ipv4']:
                    if 'http' in interface['ipv4']['management']:
                        if interface['ipv4']['management']['http']:
                            sonicwall_config['interfaces'][interface_num]['iface_http_mgmt'] = '1'
                    if interface['ipv4']['management']['https']:
                        sonicwall_config['interfaces'][interface_num]['iface_https_mgmt'] = '1'
                    if interface['ipv4']['management']['ssh']:
                        sonicwall_config['interfaces'][interface_num]['iface_ssh_mgmt'] = '1'
                    if interface['ipv4']['management']['ping']:
                        sonicwall_config['interfaces'][interface_num]['iface_ping_mgmt'] = '1'
                    if interface['ipv4']['management']['snmp']:
                        sonicwall_config['interfaces'][interface_num]['iface_snmp_mgmt'] = '1'

                if 'shutdown_port' in interface['ipv4']:
                    if interface['ipv4']['shutdown_port']:
                        sonicwall_config['interfaces'][interface_num]['portShutdown'] = '1'
                else:
                    sonicwall_config['interfaces'][interface_num]['portShutdown'] = '0'

                # sonicwall_config['interfaces'][interface_num]['uuid']=interface['ipv4']['uuid']  ## no uuid for interfaces

                interface_num_int += 1

            if pbrResult:
                if pbrResult.status_code == 200:
                    log('!-- Reading Routing Objects via WebUI table')
                    ## # routing_props = ['pbrObjId', 'pbrObjProperties', 'pbrObjSrc', 'pbrObjDst', 'pbrObjSvc', 'pbrObjGw', 'pbrObjIface', 'pbrObjIfaceName', 'pbrObjMetric', 'pbrObjPriority', 'pbrObjProbe', 'pbrObjComment']
                    pbrindex = 0
                    for index, entry in enumerate(json.loads(pbrResult.text)['pbrPolicies'].split('|')[1:]):
                        # log(index, entry)
                        name, properties, metric, distance, distanceAuto, priority, source, destination, service, applicationID, application, tos, tosMask, nexthopNum, \
                        gateway, gatewayVer, iface, ifName, ifaceStatus, gateway2, gatewayVer2, iface2, ifName2, ifaceStatus2, gateway3, gatewayVer3, iface3, ifName3, ifaceStatus3, \
                        gateway4, gatewayVer4, iface4, ifName4, ifaceStatus4, comment, probe, ipver, wxaGroup, uuid, rtype, psp, sdwanGroup, entryIndex = entry.split(
                            ',')
                        if ipver == '0':  ## 0 is IPv4 - do not read IPv6 routes at this time
                            # log([x for x in sonicwall_config['addresses']])
                            destination = destination.strip('"')
                            source = source.strip('"')
                            service = service.strip('"')
                            gateway = gateway.strip('"')
                            ifName = ifName.strip('"')
                            if destination == '':  destination = '0.0.0.0/0'
                            # log('"{}"'.format(destination))
                            if source in sonicwall_config['addresses']:
                                source = '{}/{}'.format(sonicwall_config['addresses'][source]['addrObjIp1'],
                                                        netmask_to_cidr(
                                                            sonicwall_config['addresses'][source]['addrObjIp2']))
                            if gateway in sonicwall_config['addresses']:
                                gateway = '{}'.format(sonicwall_config['addresses'][gateway]['addrObjIp1'])
                            if destination in sonicwall_config['addresses']:
                                # log('Destination in Address objects - expand it!')
                                # log(expand_address(sonicwall_config['addresses'], destination, sonicwall_config['addressmappings'], inc_group=False))
                                for each_dest in expand_address(sonicwall_config['addresses'], destination,
                                                                sonicwall_config['addressmappings'], inc_group=False):
                                    # log(each_dest, pbrindex)
                                    sonicwall_config['routing'][pbrindex] = OrderedDict()
                                    sonicwall_config['routing'][pbrindex]['pbrObjId'] = name
                                    sonicwall_config['routing'][pbrindex]['pbrObjProperties'] = properties
                                    sonicwall_config['routing'][pbrindex]['pbrObjSrc'] = source
                                    sonicwall_config['routing'][pbrindex]['pbrObjDst'] = '{}/{}'.format(
                                        sonicwall_config['addresses'][each_dest]['addrObjIp1'],
                                        netmask_to_cidr(sonicwall_config['addresses'][each_dest]['addrObjIp2']))
                                    sonicwall_config['routing'][pbrindex]['pbrObjSvc'] = service
                                    sonicwall_config['routing'][pbrindex]['pbrObjGw'] = gateway
                                    sonicwall_config['routing'][pbrindex]['pbrObjIface'] = iface
                                    sonicwall_config['routing'][pbrindex]['pbrObjIfaceName'] = ifName
                                    sonicwall_config['routing'][pbrindex]['pbrObjMetric'] = metric
                                    sonicwall_config['routing'][pbrindex]['pbrObjPriority'] = priority
                                    sonicwall_config['routing'][pbrindex]['pbrObjProbe'] = probe
                                    sonicwall_config['routing'][pbrindex]['pbrObjComment'] = comment
                                    sonicwall_config['routing'][pbrindex]['pbrObjUUID'] = uuid
                                    # log(sonicwall_config['routing'][index]['pbrObjDst'], ipver)
                                    pbrindex += 1

                            else:
                                # log('Destination not in Address objects - use as is!')
                                # log(destination, pbrindex)
                                sonicwall_config['routing'][pbrindex] = OrderedDict()
                                sonicwall_config['routing'][pbrindex]['pbrObjId'] = name
                                sonicwall_config['routing'][pbrindex]['pbrObjProperties'] = properties
                                sonicwall_config['routing'][pbrindex]['pbrObjSrc'] = source
                                sonicwall_config['routing'][pbrindex]['pbrObjDst'] = destination
                                sonicwall_config['routing'][pbrindex]['pbrObjSvc'] = service
                                sonicwall_config['routing'][pbrindex]['pbrObjGw'] = gateway
                                sonicwall_config['routing'][pbrindex]['pbrObjIface'] = iface
                                sonicwall_config['routing'][pbrindex]['pbrObjIfaceName'] = ifName
                                sonicwall_config['routing'][pbrindex]['pbrObjMetric'] = metric
                                sonicwall_config['routing'][pbrindex]['pbrObjPriority'] = priority
                                sonicwall_config['routing'][pbrindex]['pbrObjProbe'] = probe
                                sonicwall_config['routing'][pbrindex]['pbrObjComment'] = comment
                                sonicwall_config['routing'][pbrindex]['pbrObjUUID'] = uuid
                                pbrindex += 1
                            # log(config['sonicwall'])
                            # log(sonicwall_config['routing'][index]['pbrObjDst'], ipver)
                else:
                    pbrResult = None

            if pbrResult == None:

                ## only read using API is using WebUI failed
                log('!-- Reading Routing Objects via API')
                url = 'https://{}/api/sonicos/route-policies/ipv4'.format(ip)
                result = session.get(url=url, data=post_data, verify=False, timeout=options.timeout_sw_api)
                routing_ipv4 = json.loads(result.text)
                # log(routing_ipv4['route_policies'][0])
                # {'ipv4': {'source': {'any': True}, 'comment': '', 'interface': 'MGMT', 'name': 'ldap', 'vpn_precedence': False, 'service': {'any': True}, 'uuid': '00000000-0000-0001-0900-c0eae46b8088', 'metric': 1, 'gateway': {'name': 'MGMT Default Gateway'}, 'disable_on_interface_down': True, 'probe': '', 'destination': {'any': True}, 'wxa_group': ''}}
                # routing_props = ['pbrObjId', 'pbrObjProperties', 'pbrObjSrc', 'pbrObjDst', 'pbrObjSvc', 'pbrObjGw', 'pbrObjIface', 'pbrObjIfaceName', 'pbrObjMetric', 'pbrObjPriority', 'pbrObjProbe', 'pbrObjComment']
                ## need more details to read pbrObjSvc value

                route_num_int = 0
                for route in routing_ipv4['route_policies']:
                    route_num = str(route_num_int)
                    # debug("ROUTE", route['ipv4']['gateway'])

                    sonicwall_config['routing'][route_num] = OrderedDict()
                    sonicwall_config['routing'][route_num]['pbrObjId'] = route['ipv4']['name']
                    sonicwall_config['routing'][route_num]['pbrObjProperties'] = ''

                    if 'name' in route['ipv4']['source']:
                        sonicwall_config['routing'][route_num]['pbrObjSrc'] = route['ipv4']['source']['name']
                    else:
                        sonicwall_config['routing'][route_num]['pbrObjSrc'] = ''

                    if 'name' in route['ipv4']['destination']:
                        sonicwall_config['routing'][route_num]['pbrObjDst'] = route['ipv4']['destination']['name']
                    elif 'group' in route['ipv4']['destination']:
                        sonicwall_config['routing'][route_num]['pbrObjDst'] = route['ipv4']['destination']['group']
                    else:
                        sonicwall_config['routing'][route_num]['pbrObjDst'] = ''
                    try:
                        if 'name' in route['ipv4']['gateway']:
                            sonicwall_config['routing'][route_num]['pbrObjGw'] = route['ipv4']['gateway']['name']
                            # debug("ROUTE2", route['ipv4']['gateway'])
                        else:
                            sonicwall_config['routing'][route_num]['pbrObjGw'] = ''
                    except:
                        sonicwall_config['routing'][route_num]['pbrObjGw'] = '0.0.0.0'
                        # log(route['ipv4'])

                    sonicwall_config['routing'][route_num]['pbrObjIface'] = route['ipv4']['interface']
                    sonicwall_config['routing'][route_num]['pbrObjIfaceName'] = route['ipv4']['interface']
                    sonicwall_config['routing'][route_num]['pbrObjMetric'] = str(route['ipv4']['metric'])
                    sonicwall_config['routing'][route_num]['pbrObjPriority'] = ''
                    sonicwall_config['routing'][route_num]['pbrObjProbe'] = route['ipv4']['probe']
                    sonicwall_config['routing'][route_num]['pbrObjComment'] = route['ipv4']['comment']
                    sonicwall_config['routing'][route_num]['pbrObjUUID'] = route['ipv4']['uuid']
                    sonicwall_config['routing'][route_num]['pbrObjSvc'] = ''
                    route_num_int += 1

                ## Set default route to WAN/X1 interface
                for interface_index in sonicwall_config['interfaces']:
                    # log(interface_index, sonicwall_config['interfaces'][interface_index]['iface_name'], sonicwall_config['interfaces'][interface_index]['portShutdown'])
                    if sonicwall_config['interfaces'][interface_index]['iface_name'] == 'X1' and \
                            sonicwall_config['interfaces'][interface_index]['portShutdown'] == '0':
                        sonicwall_config['routing'][route_num] = OrderedDict()
                        sonicwall_config['routing'][route_num]['pbrObjId'] = 'Default Route'
                        sonicwall_config['routing'][route_num]['pbrObjProperties'] = ''
                        sonicwall_config['routing'][route_num]['pbrObjSrc'] = ''
                        sonicwall_config['routing'][route_num]['pbrObjDst'] = '0.0.0.0'
                        sonicwall_config['routing'][route_num]['pbrObjGw'] = \
                        sonicwall_config['interfaces'][interface_index]['iface_static_gateway']
                        sonicwall_config['routing'][route_num]['pbrObjIface'] = 'X1'
                        sonicwall_config['routing'][route_num]['pbrObjIfaceName'] = 'X1'
                        sonicwall_config['routing'][route_num]['pbrObjMetric'] = '10'
                        sonicwall_config['routing'][route_num]['pbrObjPriority'] = ''
                        sonicwall_config['routing'][route_num]['pbrObjProbe'] = ''
                        sonicwall_config['routing'][route_num]['pbrObjComment'] = 'Auto-Added Default Route'
                        sonicwall_config['routing'][route_num]['pbrObjUUID'] = ''
                        sonicwall_config['routing'][route_num]['pbrObjSvc'] = ''
                        # log(sonicwall_config['routing'][route_num])
                        break
                # log(json.dumps(sonicwall_config['routing'], indent=4))

            log('!-- Reading Zone Objects')
            url = 'https://{}/api/sonicos/zones'.format(ip)
            result = session.get(url=url, data=post_data, verify=False, timeout=options.timeout_sw_api)
            zones = json.loads(result.text)
            # log(zones['zones'][0])
            # {'create_group_vpn': False, 'intrusion_prevention': True, 'name': 'LAN', 'client': {'anti_virus': False, 'content_filtering': False}, 'auto_generate_access_rules': {'allow_from_to_equal': True, 'allow_to_lower': True, 'allow_from_higher': True, 'deny_from_lower': True}, 'dpi_ssl_client': True, 'sslvpn_access': False, 'guest_services': {}, 'interface_trust': True, 'uuid': '2ecd17a0-73de-dc8b-0a00-c0eae46b8088', 'ssl_control': False, 'gateway_anti_virus': True, 'security_type': 'trusted', 'app_control': True, 'anti_spyware': True, 'dpi_ssl_server': False}
            # zone_props = ['zoneObjId', 'zoneObjComment']
            for zone in zones['zones']:
                zone_name = zone['name']
                sonicwall_config['zones'][zone_name] = OrderedDict()
                sonicwall_config['zones'][zone_name]['zoneObjId'] = zone_name
                sonicwall_config['zones'][zone_name]['zoneObjComment'] = ''
                sonicwall_config['zones'][zone_name]['zoneObjUUID'] = zone['uuid']

            sonicwall_config['usedzones'] = []
            for interface in sonicwall_config['interfaces']:
                if sonicwall_config['interfaces'][interface]['interface_Zone'] != '':
                    sonicwall_config['usedzones'].append(sonicwall_config['interfaces'][interface]['interface_Zone'])
        else:
            log('Unable to retrieve configuration via API')
        ## Add IPset property to groups
        for addr in sonicwall_config['addresses']:
            if sonicwall_config['addresses'][addr]['addrObjType'] == '8':
                sonicwall_config['addresses'][addr]['IPSet'] = IPSet([])
                for groupmember in expand_address(sonicwall_config['addresses'], addr,
                                                  sonicwall_config['addressmappings']):
                    debug(groupmember)
                    debug(sonicwall_config['addresses'][groupmember])
                    for network in sonicwall_config['addresses'][groupmember]['IPv4Networks']:
                        sonicwall_config['addresses'][addr]['IPSet'].add(str(network))
    else:
        log('!-- API not enabled for target device {} Configuration not loaded.'.format(ip))

    sonicwall_config['config']['name'] = ''  # context  ## CHANGEME (how do I get firewall name)
    sonicwall_config['config']['version'] = ''
    sonicwall_config['config']['fw_type'] = 'sw65'
    sonicwall_config['config']['mgmtip'] = ip

    if api_enabled and revert_api:
        sw_disable_api(ip, username, password)
        api_status = sw_get_api_status(ip, username, password)
        if api_status:
            log('!-- Sonicwall API disablement failed')
        else:
            log('!-- Sonicwall API disablement successful')

    try:
        url = 'https://{}/api/sonicos/auth'.format(ip)
        session.delete(url=url, verify=False, timeout=options.timeout_sw_webui)
    except:
        pass

    return sonicwall_config


def load_sonicwall(infile, skipdisabled, memoryconfig=None):
    from collections import defaultdict
    from netaddr import IPSet

    configfilename = "config_python.txt"
    address_props = ['addrObjId', 'addrObjIdDisp', 'addrObjType', 'addrObjZone', 'addrObjProperties', 'addrObjIp1',
                     'addrObjIp2', 'addrObjComment']
    addressfqdn_props = ['addrObjFqdnId', 'addrObjFqdnType', 'addrObjFqdnZone', 'addrObjFqdnProperties', 'addrObjFqdn']
    service_props = ['svcObjId', 'svcObjType', 'svcObjProperties', 'svcObjIpType', 'svcObjPort1', 'svcObjPort2',
                     'svcObjManagement', 'svcObjHigherPrecedence', 'svcObjComment']
    zone_props = ['zoneObjId', 'zoneObjComment']
    policy_props = ['policyAction', 'policySrcZone', 'policyDstZone', 'policySrcNet', 'policyDstNet', 'policyDstSvc',
                    'policyDstApps', 'policyComment', 'policyLog', 'policyEnabled', 'policyProps']
    interface_props = ['iface_ifnum', 'iface_type', 'iface_name', 'interface_Zone', 'iface_comment', 'iface_static_ip',
                       'iface_static_mask', 'iface_static_gateway', 'iface_lan_ip', 'iface_lan_mask',
                       'iface_lan_default_gw', 'iface_mgmt_ip', 'iface_mgmt_netmask', 'iface_mgmt_default_gw',
                       'iface_static_gateway', 'iface_vlan_tag', 'iface_comment', 'iface_http_mgmt', 'iface_https_mgmt',
                       'iface_ssh_mgmt', 'iface_ping_mgmt', 'iface_snmp_mgmt', 'portShutdown']
    routing_props = ['pbrObjId', 'pbrObjProperties', 'pbrObjSrc', 'pbrObjDst', 'pbrObjSvc', 'pbrObjGw', 'pbrObjIface',
                     'pbrObjIfaceName', 'pbrObjMetric', 'pbrObjPriority', 'pbrObjProbe', 'pbrObjComment']
    nat_props = ['natPolicyOrigSrc', 'natPolicyOrigDst', 'natPolicyOrigSvc', 'natPolicyTransSrc', 'natPolicyTransDst',
                 'natPolicyTransSvc', 'natPolicySrcIface', 'natPolicyDstIface', 'natPolicyEnabled', 'natPolicyComment',
                 'natPolicyProperties', 'natPolicyName']
    addressV6_props = ['addrObjV6Id', 'addrObjV6IdDisp', 'addrObjV6Type', 'addrObjV6Zone', 'addrObjV6Properties',
                       'addrObjV6Ip1', 'addrObjV6Ip2', 'addrObjV6PrefixLen']
    policyV6_props = ['policyActionV6', 'policySrcZoneV6', 'policyDstZoneV6', 'policySrcNetV6', 'policyDstNetV6',
                      'policyDstSvcV6', 'policyCommentV6', 'policyLogV6', 'policyEnabledV6', 'policyPropsV6']

    app_props = []  # - future use for palo alto configurations
    sonicwall_config = defaultdict(dict)

    log('!-- Converting SonicWall configuration file')
    if not memoryconfig:
        if not convert_exp_file(infile, configfilename, memoryconfig):
            log('Conversion Failed')
            return False

    import re
    from urllib.parse import unquote as url_unquote
    if memoryconfig == None:
        with open(configfilename) as working_file:
            config = working_file.read()
    else:
        config = memoryconfig

    # print(config)

    sonicwall_config['config']['name'] = re.findall('firewallName=.*', config)[0].split('=')[1]
    sonicwall_config['config']['version'] = re.findall('buildNum=.*', config)[0].split('=')[1].split('-')[0]
    sonicwall_config['config']['fw_model'] = url_unquote(
        re.findall('shortProdName=.*', config)[0].split('=')[1].split('-')[0])
    # log('!-- Sonicwall version found : ' + sonicwall_config['config']['version'], level=logging.INFO)
    sonicwall_config['config']['fw_type'] = 'sonicwall'
    if options.sonicwallip:
        sonicwall_config['config']['mgmtip'] = options.sonicwallip
    else:
        sonicwall_config['config']['mgmtip'] = None
    # working_file.close()

    log('!-- Reading Group Mappings')
    # MAY NEED TO DECLARE THESE FIRST?
    sonicwall_config['addressmappings'] = generate_group_mappings(config, 'addro')
    sonicwall_config['servicemappings'] = generate_group_mappings(config, 'so')
    log('!-- Reading Address Objects')
    sonicwall_config['addresses'] = migrate('addrObj', config, address_props)
    sonicwall_config['addresses'] = add_IPv4Network(sonicwall_config['addresses'])
    for address in sonicwall_config['addresses']:  ## Add empty comment for all sonicwall address objects
        sonicwall_config['addresses'][address]['addrObjComment'] = ''
        sonicwall_config['addresses'][address]['addrObjColor'] = ''
        if sonicwall_config['addresses'][address]['addrObjType'] == '1':
            sonicwall_config['addresses'][address][
                'addrObjIp2'] = '255.255.255.255'  # Force netmask for host objects to /32, as some built in types have this set to 0.0.0.0

    sonicwall_config['addressesfqdn'] = migrate('addrObjFqdn', config, addressfqdn_props)
    sonicwall_config['addressesV6'] = migrate('addrObjV6', config, addressV6_props)

    ## Rename IPv6 keys to match IPv4 objects
    for address in sonicwall_config['addressesV6']:
        sonicwall_config['addressesV6'][address]['addrObjId'] = sonicwall_config['addressesV6'][address].pop(
            'addrObjV6Id')
        sonicwall_config['addressesV6'][address]['addrObjIdDisp'] = sonicwall_config['addressesV6'][address].pop(
            'addrObjV6IdDisp')
        sonicwall_config['addressesV6'][address]['addrObjType'] = sonicwall_config['addressesV6'][address].pop(
            'addrObjV6Type')
        sonicwall_config['addressesV6'][address]['addrObjZone'] = sonicwall_config['addressesV6'][address].pop(
            'addrObjV6Zone')
        sonicwall_config['addressesV6'][address]['addrObjProperties'] = sonicwall_config['addressesV6'][address].pop(
            'addrObjV6Properties')
        sonicwall_config['addressesV6'][address]['addrObjIp1'] = sonicwall_config['addressesV6'][address].pop(
            'addrObjV6Ip1')
        sonicwall_config['addressesV6'][address]['addrObjIp2'] = sonicwall_config['addressesV6'][address].pop(
            'addrObjV6Ip2')
        sonicwall_config['addressesV6'][address]['addrObjPrefixLen'] = sonicwall_config['addressesV6'][address].pop(
            'addrObjV6PrefixLen')

    ## Add IPset property to groups
    for addr in sonicwall_config['addresses']:
        if sonicwall_config['addresses'][addr]['addrObjType'] == '8':
            sonicwall_config['addresses'][addr]['IPSet'] = IPSet([])
            for groupmember in expand_address(sonicwall_config['addresses'], addr, sonicwall_config['addressmappings']):
                for network in sonicwall_config['addresses'][groupmember]['IPv4Networks']:
                    sonicwall_config['addresses'][addr]['IPSet'].add(str(network))

    log('!-- Reading Service Objects')
    sonicwall_config['services'] = migrate('svcObj', config, service_props)
    for service_name in sonicwall_config['services']:  ## add svcSrcPort property to all objects
        sonicwall_config['services'][service_name]['svcObjSrcPort'] = '0'

    log('!-- Reading Policy Objects')
    ## Need to used old numerically index migrate routing for policies (WHY?)
    sonicwall_config['policies'] = migrate_orig('policy', config, policy_props, skipdisabled=False)
    sonicwall_config['policies'] = policy_objects_to_list(sonicwall_config['policies'],
                                                          ['policySrcZone', 'policyDstZone', 'policySrcNet',
                                                           'policyDstNet', 'policyDstSvc'])

    log('!-- Generating IPv6 Policy Objects')
    sonicwall_config['policiesV6'] = migrate_orig('policy', config, policyV6_props, skipdisabled=skipdisabled)

    ## Rename IPv6 keys to match IPv4 objects
    for policy in sonicwall_config['policiesV6']:
        sonicwall_config['policiesV6'][policy]['policyAction'] = sonicwall_config['policiesV6'][policy].pop(
            'policyActionV6')
        sonicwall_config['policiesV6'][policy]['policySrcZone'] = sonicwall_config['policiesV6'][policy].pop(
            'policySrcZoneV6')
        sonicwall_config['policiesV6'][policy]['policyDstZone'] = sonicwall_config['policiesV6'][policy].pop(
            'policyDstZoneV6')
        sonicwall_config['policiesV6'][policy]['policySrcNet'] = sonicwall_config['policiesV6'][policy].pop(
            'policySrcNetV6')
        sonicwall_config['policiesV6'][policy]['policyDstNet'] = sonicwall_config['policiesV6'][policy].pop(
            'policyDstNetV6')
        sonicwall_config['policiesV6'][policy]['policyComment'] = sonicwall_config['policiesV6'][policy].pop(
            'policyCommentV6')
        sonicwall_config['policiesV6'][policy]['policyLog'] = sonicwall_config['policiesV6'][policy].pop('policyLogV6')
        sonicwall_config['policiesV6'][policy]['policyEnabled'] = sonicwall_config['policiesV6'][policy].pop(
            'policyEnabledV6')
        sonicwall_config['policiesV6'][policy]['policyProps'] = sonicwall_config['policiesV6'][policy].pop(
            'policyPropsV6')
        sonicwall_config['policiesV6'][policy]['policyDstSvc'] = sonicwall_config['policiesV6'][policy].pop(
            'policyDstSvcV6')

    if options.expandcheckpoint:  ## change this to an argparse option
        for policy in sonicwall_config['policies']:
            if sonicwall_config['policies'][policy]['policySrcNet'][0][0:11].lower() == 'importchkpt':
                sonicwall_config['policies'][policy]['policySrcNet'] = sonicwall_config['addressmappings'][
                    sonicwall_config['policies'][policy]['policySrcNet'][0]]
            if sonicwall_config['policies'][policy]['policyDstNet'][0][0:11].lower() == 'importchkpt':
                sonicwall_config['policies'][policy]['policyDstNet'] = sonicwall_config['addressmappings'][
                    sonicwall_config['policies'][policy]['policyDstNet'][0]]
            if sonicwall_config['policies'][policy]['policyDstSvc'][0][0:11].lower() == 'importchkpt':
                sonicwall_config['policies'][policy]['policyDstSvc'] = sonicwall_config['servicemappings'][
                    sonicwall_config['policies'][policy]['policyDstSvc'][0]]

    ## Sonicwall does not have a "Name" for policies, but need to add it as a placeholder for PA compatibility
    for policy in sonicwall_config['policies']:
        sonicwall_config['policies'][policy]['policyName'] = "Empty"
        sonicwall_config['policies'][policy]['policyNum'] = ''
        sonicwall_config['policies'][policy]['policyUiNum'] = ''

    log('!-- Reading NAT Policy Objects')
    sonicwall_config['nat'] = migrate_orig('natPolicy', config, nat_props)
    sonicwall_config['nat'] = policy_objects_to_list(sonicwall_config['nat'],
                                                     ['natPolicyOrigSrc', 'natPolicyOrigDst', 'natPolicyOrigSvc',
                                                      'natPolicyTransSrc', 'natPolicyTransDst', 'natPolicyTransSvc'])
    for policy in sonicwall_config['nat']:
        sonicwall_config['nat'][policy]['natPolicyName'] = "Empty"
        sonicwall_config['nat'][policy]['natPolicyNum'] = ''
        sonicwall_config['nat'][policy]['natPolicyUiNum'] = ''

    log('!-- Reading Zone Objects')
    sonicwall_config['zones'] = migrate('zoneObj', config, zone_props)

    log('!-- Reading Interface Objects')
    sonicwall_config['interfaces'] = migrate('iface', config, interface_props)

    log('!-- Reading Routing Objects')
    sonicwall_config['routing'] = migrate('pbrObj', config, routing_props)

    sonicwall_config['usedzones'] = []
    for interface in sonicwall_config['interfaces']:
        if sonicwall_config['interfaces'][interface]['interface_Zone'] != '':
            sonicwall_config['usedzones'].append(sonicwall_config['interfaces'][interface]['interface_Zone'])

    all_zones = []
    for zone in sonicwall_config['zones']:
        all_zones.append(sonicwall_config['zones'][zone]['zoneObjId'])

    sonicwall_config['apps'] = {}  # empty dictionary as sonicwall does not use applications in rules

    return sonicwall_config;


def get_sonicwall_exp(target):
    exp_config = get_sw_config_https(target, None, options.username, options.password)
    tmpconfig = None
    if exp_config:
        memory_config = convert_exp_file('', None, exp_config.encode())
        exp_config = None  # free up memory
        if memory_config:
            if options.logging == logging.DEBUG:
                with open('config_python_{}.txt'.format(target), 'w') as outfile:
                    outfile.write(memory_config)
            tmpconfig = load_sonicwall('', True, memory_config)
            memory_config = None  # free up memory
    config = {}
    if tmpconfig:
        if options.context != '':
            tmpcontext = options.context[0]
        else:
            tmpcontext = tmpconfig['config']['name']
        config[tmpcontext] = tmpconfig
        if not options.context:
            options.context = [tmpcontext]
        for context in options.context:
            contexts.append(context)
        tmpconfig = None  # free up memory

    return config


def get_palo_config_https(host, outfile, username='admin', password='password'):
    import urllib3
    import requests
    import re
    from requests.packages.urllib3.util.ssl_ import create_urllib3_context
    from requests.adapters import HTTPAdapter
    from urllib.parse import quote
    import base64

    class DESAdapter(HTTPAdapter):
        from requests.packages.urllib3.util.ssl_ import create_urllib3_context

        """
        A TransportAdapter that re-enables 3DES support in Requests.
        """

        def init_poolmanager(self, *args, **kwargs):
            # context = create_urllib3_context(ciphers=CIPHERS)
            context = create_urllib3_context()
            kwargs['ssl_context'] = context
            return super(DESAdapter, self).init_poolmanager(*args, **kwargs)

        def proxy_manager_for(self, *args, **kwargs):
            context = create_urllib3_context()

            kwargs['ssl_context'] = context
            return super(DESAdapter, self).proxy_manager_for(*args, **kwargs)

    log("!-- Retrieving Palo Alto/Panorama configuration file from host : " + host)
    session = requests.Session()
    session.mount(host, DESAdapter())
    urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
    # key=session.get('https://' + host + '/api/?type=keygen&user=' + username + '&password=' + quote(password), verify=False, stream=True, timeout=options.timeout_palo_api)
    # key=session.get('https://' + host + '/api/?type=keygen&user=' + username + '&password=' + quote(password), verify=False, stream=True, timeout=options.timeout_palo_api)
    # key = re.sub(r'.*<key>(.*)</key>.*',r'\1',key.text)
    # config=session.get('https://' + host + '/api/?type=export&category=configuration&key=' + key, verify=False, stream=True, timeout=options.timeout_palo_api)
    # debug(username, password)

    # config=session.get('https://' + host + '/api/?type=op&cmd=<show><config><merged></merged></config></show>&key=' + key, verify=False, stream=True, timeout=options.timeout_palo_api)

    # config=session.get('https://' + host + '/api/?type=export&category=configuration', auth=(username, quote(password)), verify=False, stream=True, timeout=options.timeout_palo_api)
    config = session.get('https://' + host + '/api/?type=export&category=configuration', headers={
        'authorization': "Basic " + base64.b64encode('{}:{}'.format(username, password).encode()).decode()},
                         verify=False, stream=True, timeout=options.timeout_palo_api)
    # outfile=open(outfile,'w', encoding='utf-8')
    # outfile.write(config.text)
    # outfile.close()
    if config.status_code != 200:
        log('!-- Retrieval of configuration failed')
        debug(config.text)
        return False
    return config.text


def get_sw_config_https(host, outfile, username='admin', password='admin'):
    import sonicwall as sw
    log("!-- Retrieving SonicWall configuration file from host : " + host)
    try:
        sw_config = sw.get_config(host, username, password)
        # log('\n',sw_config,'\n')
        if outfile:
            if sw_config:
                if outfile:
                    outfile = open(outfile, 'w')
                    # outfile.write(sw_config.text)
                    outfile.close()
        if not sw_config:
            log("!-- Error retrieving configuration file")
            return False
    except:
        return False
    return sw_config.text


def ckpt_api_call(ip_addr, port, command, json_payload, sid):
    import requests, json

    url = 'https://' + ip_addr + ':' + str(port) + '/web_api/' + command
    if sid == '':
        request_headers = {'Content-Type': 'application/json'}
    else:
        request_headers = {'Content-Type': 'application/json', 'X-chkp-sid': sid}
    r = requests.post(url, data=json.dumps(json_payload), headers=request_headers, verify=False)
    return r


def ckpt_login(ip_addr, domain, user, password):
    import requests, json

    payload = {'user': user, 'password': password, "domain": domain}
    response = ckpt_api_call(ip_addr, 443, 'login', payload, '')
    # debug(response)
    if "sid" in json.loads(response.text):
        return json.loads(response.text)["sid"], json.loads(response.text)["uid"], 'Success'
    elif "message" in response:
        return False, response["message"], None
    else:
        return False, 'Unknown', None


def ckpt_logout(ip_addr, domain, sid):
    # payload = {'user': user, 'password' : password, "domain": domain }
    response = ckpt_api_call(ip_addr, 443, 'login', {}, sid)
    # print(response)
    # if "sid" in response:
    #    return response["sid"], 'Success'
    # elif "message" in response:
    #    return False, response["message"]
    # else:
    #    return False, 'Unknown'
    return response


def load_checkpoint_api(mgmt_ip, context, username, password):  ## R80

    import requests, json
    import urllib3
    import ipaddress
    from netaddr import IPSet

    urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

    '''
    def api_call(ip_addr, port, command, json_payload, sid):
        url = 'https://' + ip_addr + ':' + str(port) + '/web_api/' + command
        if sid == '':
            request_headers = {'Content-Type' : 'application/json'}
        else:
            request_headers = {'Content-Type' : 'application/json', 'X-chkp-sid' : sid}
        r = requests.post(url,data=json.dumps(json_payload), headers=request_headers, verify=False)
        #print(r.text)
        return r.json()


    def login(ip_addr, domain, user, password):
        payload = {'user': user, 'password' : password, "domain": domain }
        response = api_call(ip_addr, 443, 'login',payload, '')
        #print(response)
        if "sid" in response:
            return response["sid"], 'Success'
        elif "message" in response:
            return False, response["message"]
        else:
            return False, 'Unknown'
            
    '''

    def get_all_objects(ip_addr, sid, item, obj_property='objects', params=None):

        limit = 30
        start_offset = 0
        all_items = []
        num_returned = -1
        while num_returned != 0:
            if item == 'show-access-rulebase':
                get_items_result = ckpt_api_call(ip_addr, 443, item,
                                                 {"limit": limit, "offset": start_offset, "details-level": "full",
                                                  "name": params, "use-object-dictionary": False}, sid)
            if item == 'show-nat-rulebase':
                get_items_result = ckpt_api_call(ip_addr, 443, item,
                                                 {"limit": limit, "offset": start_offset, "details-level": "full",
                                                  "package": params, "use-object-dictionary": False}, sid)
            elif item == 'show-groups':
                get_items_result = ckpt_api_call(ip_addr, 443, item,
                                                 {"limit": limit, "offset": start_offset, "details-level": "full",
                                                  'dereference-group-members': False, "show-membership": False}, sid)
            elif item == 'show-object':
                get_items_result = ckpt_api_call(ip_addr, 443, item, {"uid": params, "details-level": "full"}, sid)
            else:
                get_items_result = ckpt_api_call(ip_addr, 443, item,
                                                 {"limit": limit, "offset": start_offset, "details-level": "full"}, sid)
            if obj_property in get_items_result:
                if item == 'show-object':
                    all_items = get_items_result[obj_property]
                    num_returned = 0
                else:
                    all_items.extend(get_items_result[obj_property])
                    num_returned = len(get_items_result[obj_property])
            else:
                num_returned = 0
            start_offset += limit
        return all_items

    sid, uid, message = ckpt_login(mgmt_ip, context, username, password)
    if sid:
        debug("session id: " + sid)

        return_config = OrderedDict()
        return_config['config'] = OrderedDict()
        return_config['config']['policylen'] = {}

        return_addresses = OrderedDict()
        return_services = OrderedDict()
        return_service = OrderedDict()
        return_policy = OrderedDict()
        return_nat = OrderedDict()
        return_address = OrderedDict()
        addr_mappings = OrderedDict()
        svc_mappings = OrderedDict()
        uid_mappings = OrderedDict()

        log('!-- Retreiving Checkpoint Config via API')
        objects = get_all_objects(mgmt_ip, sid, 'show-gateways-and-servers')
        log('!-- Retreived Gateways and Servers objects : ', len(objects))
        for address in objects:
            return_address = OrderedDict()
            return_address['addrObjId'] = address['name']
            return_address['addrObjDisp'] = address['name']
            return_address['addrObjType'] = '1'
            return_address['addrObjZone'] = ''
            return_address['addrObjProperties'] = ''
            return_address['addrObjIp1'] = address['ipv4-address']
            return_address['addrObjIp2'] = '255.255.255.255'
            return_address['addrObjComment'] = address['comments']
            return_address['addrObjColor'] = address['color']
            return_address['addrObjUid'] = address['uid']
            return_address['IPv4Networks'] = [ipaddress.IPv4Network(address['ipv4-address'] + '/32', strict=False)]
            return_addresses[return_address['addrObjId']] = return_address
            uid_mappings[address['uid']] = address['name']

        objects = get_all_objects(mgmt_ip, sid, 'show-simple-gateways')
        log('!-- Retreived Simple Gateways objects : ', len(objects))
        for address in objects:
            return_address = OrderedDict()
            return_address['addrObjId'] = address['name']
            return_address['addrObjDisp'] = address['name']
            return_address['addrObjType'] = '1'
            return_address['addrObjZone'] = ''
            return_address['addrObjProperties'] = ''
            return_address['addrObjIp1'] = address['ipv4-address']
            return_address['addrObjIp2'] = '255.255.255.255'
            return_address['addrObjComment'] = address['comments']
            return_address['addrObjColor'] = address['color']
            return_address['addrObjUid'] = address['uid']
            return_address['IPv4Networks'] = [ipaddress.IPv4Network(address['ipv4-address'] + '/32', strict=False)]
            return_addresses[return_address['addrObjId']] = return_address
            uid_mappings[address['uid']] = address['name']

        objects = get_all_objects(mgmt_ip, sid, 'show-hosts')
        log('!-- Retreived Hosts objects : ', len(objects))
        for address in objects:
            return_address = OrderedDict()
            return_address['addrObjId'] = address['name']
            return_address['addrObjDisp'] = address['name']
            if 'ipv4-address' in address:
                return_address['addrObjType'] = '1'
                return_address['addrObjIp1'] = address['ipv4-address']
                return_address['IPv4Networks'] = [ipaddress.IPv4Network(address['ipv4-address'] + '/32', strict=False)]
                return_address['addrObjIp2'] = '255.255.255.255'
            elif 'ipv6-address' in address:
                return_address['addrObjType'] = '6'
                return_address['addrObjIp1'] = address['ipv6-address']

            return_address['addrObjZone'] = ''
            return_address['addrObjProperties'] = ''
            return_address['addrObjComment'] = address['comments']
            return_address['addrObjColor'] = address['color']
            return_address['addrObjUid'] = address['uid']
            return_addresses[return_address['addrObjId']] = return_address
            uid_mappings[address['uid']] = address['name']

        objects = get_all_objects(mgmt_ip, sid, 'show-networks')
        log('!-- Retreived Networks objects : ', len(objects))
        for address in objects:
            if 'subnet4' in address or 'subnet6' in address:
                return_address = OrderedDict()
                return_address['addrObjId'] = address['name']
                return_address['addrObjDisp'] = address['name']
                if 'subnet4' in address:
                    return_address['addrObjType'] = '4'
                    return_address['addrObjIp1'] = address['subnet4']
                    return_address['addrObjIp2'] = address['subnet-mask']
                    return_address['IPv4Networks'] = [ipaddress.IPv4Network(
                        return_address['addrObjIp1'] + '/' + str(netmask_to_cidr(return_address['addrObjIp2'])),
                        strict=False)]
                elif 'subnet6' in address:
                    return_address['addrObjType'] = '7'
                    return_address['addrObjIp1'] = address['subnet6']
                    return_address['addrObjIp2'] = address['mask-length6']
                return_address['addrObjZone'] = ''
                return_address['addrObjProperties'] = ''
                return_address['addrObjComment'] = address['comments']
                return_address['addrObjColor'] = address['color']
                return_address['addrObjUid'] = address['uid']
                return_addresses[return_address['addrObjId']] = return_address
                uid_mappings[address['uid']] = address['name']

        objects = get_all_objects(mgmt_ip, sid, 'show-address-ranges')
        log('!-- Retreived Address Ranges objects : ', len(objects))
        for address in objects:
            if 'ipv4-address-first' in address:
                return_address = OrderedDict()
                return_address['addrObjId'] = address['name']
                return_address['addrObjDisp'] = address['name']
                return_address['addrObjType'] = '2'
                return_address['addrObjZone'] = ''
                return_address['addrObjProperties'] = ''
                return_address['addrObjIp1'] = address['ipv4-address-first']
                return_address['addrObjIp2'] = address['ipv4-address-last']
                return_address['addrObjComment'] = address['comments']
                return_address['addrObjColor'] = address['color']
                return_address['addrObjUid'] = address['uid']
                return_address['IPv4Networks'] = [ipaddr for ipaddr in ipaddress.summarize_address_range(
                    ipaddress.IPv4Address(return_address['addrObjIp1']),
                    ipaddress.IPv4Address(return_address['addrObjIp2']))]
                return_addresses[return_address['addrObjId']] = return_address
                uid_mappings[address['uid']] = address['name']

        objects = get_all_objects(mgmt_ip, sid, 'show-groups')
        log('!-- Retreived Address Groups objects : ', len(objects))
        for address in objects:
            return_address = OrderedDict()
            return_address['addrObjId'] = address['name']
            return_address['addrObjDisp'] = address['name']
            return_address['addrObjType'] = '8'
            return_address['addrObjZone'] = ''
            return_address['addrObjProperties'] = ''
            return_address['addrObjIp1'] = ''
            return_address['addrObjIp2'] = ''
            return_address['addrObjComment'] = address['comments']
            return_address['addrObjColor'] = address['color']
            return_address['addrObjUid'] = address['uid']
            return_address['addrObjMembers'] = address['members']
            return_addresses[return_address['addrObjId']] = return_address
            uid_mappings[address['uid']] = address['name']

        objects = get_all_objects(mgmt_ip, sid, 'show-groups-with-exclusion')
        log('!-- Retreived Groups with exclusions objects : ', len(objects))
        for address in objects:
            return_address = OrderedDict()
            return_address['addrObjId'] = address['name']
            return_address['addrObjDisp'] = address['name']
            return_address['addrObjType'] = '8'
            return_address['addrObjZone'] = ''
            return_address['addrObjProperties'] = ''
            return_address['addrObjIp1'] = ''
            return_address['addrObjIp2'] = ''
            return_address['addrObjComment'] = address['comments']
            return_address['addrObjColor'] = address['color']
            return_address['addrObjUid'] = address['uid']
            return_address['addrObjMembers'] = address['include']
            return_address['addrObjMembers'] = []
            return_address['addrObjExclude'] = address['except']
            return_addresses[return_address['addrObjId']] = return_address
            uid_mappings[address['uid']] = address['name']

        tmp_addresses = OrderedDict()
        for address in return_addresses:
            if return_addresses[address]['addrObjType'] == '8':
                for member in return_addresses[address]['addrObjMembers']:
                    if member in uid_mappings:
                        if return_addresses[address]['addrObjId'] not in addr_mappings:
                            addr_mappings[return_addresses[address]['addrObjId']] = []
                        addr_mappings[return_addresses[address]['addrObjId']].append(uid_mappings[member])
                    else:  # look up mappings for unknown objects

                        tmp_object = get_all_objects(mgmt_ip, sid, 'show-object', 'object', member)
                        uid_mappings[member] = tmp_object['name']
                        debug('uid', member)
                        debug('address', address)
                        debug('addr_mapping', return_addresses[address]['addrObjId'])
                        debug('-' * 180)
                        if return_addresses[address]['addrObjId'] not in addr_mappings:
                            addr_mappings[return_addresses[address]['addrObjId']] = []
                        addr_mappings[return_addresses[address]['addrObjId']].append(uid_mappings[member])
                        if tmp_object['type'] == 'CpmiGatewayPlain':
                            return_address = OrderedDict()
                            return_address['addrObjId'] = tmp_object['name']
                            return_address['addrObjDisp'] = tmp_object['name']
                            return_address['addrObjType'] = '1'
                            return_address['addrObjZone'] = ''
                            return_address['addrObjProperties'] = ''
                            return_address['addrObjIp1'] = tmp_object['ipv4-address']
                            return_address['addrObjIp2'] = ''
                            return_address['addrObjComment'] = tmp_object['comments']
                            return_address['addrObjColor'] = tmp_object['color']
                            return_address['addrObjUid'] = tmp_object['uid']
                            # return_address['addrObjMembers']=tmp_object['include']
                            # eturn_address['addrObjMembers']=[]
                            # return_address['addrObjExclude']=address['except']
                            tmp_addresses[return_address['addrObjId']] = return_address
                        else:
                            debug('{} not in address dictionary - type : {} '.format(member, tmp_object['type']))
        return_addresses.update(tmp_addresses)

        # print('temp object', tmp_object['name'])
        # rint('mapping for group: {} member: {} not found'.format(return_addresses[address]['addrObjId'], member))

        objects = get_all_objects(mgmt_ip, sid, 'show-services-tcp')
        log('!-- Retreived TCP Services objects : ', len(objects))
        for service in objects:
            return_service = OrderedDict()
            return_service['svcObjId'] = service['name']
            return_service['svcObjType'] = '1'
            return_service['svcObjProperties'] = ''
            return_service['svcObjIpType'] = '6'
            return_service['svcObjPort1'] = service['port']
            return_service['svcObjPort2'] = service['port']
            return_service['svcObjManagement'] = ''
            return_service['svcObjHigherPrecedence'] = ''
            return_service['svcObjComment'] = service['comments']
            return_service['svcObjSrcPort'] = '0'
            if 'color' in service:
                return_service['svcObjColor'] = service['color']
            else:
                return_service['svcObjColor'] = 'black'  # set default color to black if none is set
            return_address['svcObjUid'] = service['uid']
            return_services[return_service['svcObjId']] = return_service
            uid_mappings[service['uid']] = service['name']

        objects = get_all_objects(mgmt_ip, sid, 'show-services-udp')
        log('!-- Retreived UDP Services objects : ', len(objects))
        for service in objects:
            try:
                return_service = OrderedDict()
                return_service['svcObjId'] = service['name']
                return_service['svcObjType'] = '1'
                return_service['svcObjProperties'] = ''
                return_service['svcObjIpType'] = '17'
                return_service['svcObjPort1'] = service['port']
                return_service['svcObjPort2'] = service['port']
                return_service['svcObjManagement'] = ''
                return_service['svcObjHigherPrecedence'] = ''
                return_service['svcObjComment'] = service['comments']
                if 'color' in service:
                    return_service['svcObjColor'] = service['color']
                else:
                    return_service['svcObjColor'] = 'black'  # set default color to black if none is set
                return_address['svcObjUid'] = service['uid']
                return_services[return_service['svcObjId']] = return_service
                uid_mappings[service['uid']] = service['name']
            except:
                debug(service)
                exit(1)

        objects = get_all_objects(mgmt_ip, sid, 'show-services-icmp')
        log('!-- Retreived ICMP Services objects : ', len(objects))
        for service in objects:
            try:
                return_service = OrderedDict()
                return_service['svcObjId'] = service['name']
                return_service['svcObjType'] = '1'
                return_service['svcObjProperties'] = ''
                return_service['svcObjIpType'] = '1'
                return_service['svcObjPort1'] = service['icmp-type']
                return_service['svcObjPort2'] = ''
                return_service['svcObjManagement'] = ''
                return_service['svcObjHigherPrecedence'] = ''
                return_service['svcObjComment'] = service['comments']
                if 'color' in service:
                    return_service['svcObjColor'] = service['color']
                else:
                    return_service['svcObjColor'] = 'black'  # set default color to black if none is set
                return_address['svcObjUid'] = service['uid']
                return_services[return_service['svcObjId']] = return_service
                uid_mappings[service['uid']] = service['name']
            except:
                debug(service)
                exit(1)

        objects = get_all_objects(mgmt_ip, sid, 'show-services-dce-rpc')
        log('!-- Retreived DCE-RPC Services objects : ', len(objects))
        for service in objects:
            try:
                return_service = OrderedDict()
                return_service['svcObjId'] = service['name']
                return_service['svcObjType'] = '1'
                return_service['svcObjProperties'] = ''
                return_service['svcObjIpType'] = '80'
                return_service['svcObjPort1'] = '0'
                return_service['svcObjPort2'] = ''
                return_service['svcObjManagement'] = ''
                return_service['svcObjHigherPrecedence'] = ''
                return_service['svcObjComment'] = service['comments']
                if 'color' in service:
                    return_service['svcObjColor'] = service['color']
                else:
                    return_service['svcObjColor'] = 'black'  # set default color to black if none is set
                return_address['svcObjUid'] = service['uid']
                return_services[return_service['svcObjId']] = return_service
                uid_mappings[service['uid']] = service['name']
            except:
                debug(service)
                exit(1)

        objects = get_all_objects(mgmt_ip, sid, 'show-services-rpc')
        log('!-- Retreived RPC Services objects : ', len(objects))
        for service in objects:
            try:
                return_service = OrderedDict()
                return_service['svcObjId'] = service['name']
                return_service['svcObjType'] = '1'
                return_service['svcObjProperties'] = ''
                return_service['svcObjIpType'] = '81'
                return_service['svcObjPort1'] = '0'
                return_service['svcObjPort2'] = ''
                return_service['svcObjManagement'] = ''
                return_service['svcObjHigherPrecedence'] = ''
                return_service['svcObjComment'] = service['comments']
                if 'color' in service:
                    return_service['svcObjColor'] = service['color']
                else:
                    return_service['svcObjColor'] = 'black'  # set default color to black if none is set
                return_address['svcObjUid'] = service['uid']
                return_services[return_service['svcObjId']] = return_service
                uid_mappings[service['uid']] = service['name']
            except:
                debug(service)
                exit(1)

        objects = get_all_objects(mgmt_ip, sid, 'show-services-icmp6')
        log('!-- Retreived ICMPv6 Services objects : ', len(objects))
        for service in objects:
            try:
                return_service = OrderedDict()
                return_service['svcObjId'] = service['name']
                return_service['svcObjType'] = '1'
                return_service['svcObjProperties'] = ''
                return_service['svcObjIpType'] = '58'
                return_service['svcObjPort1'] = service['icmp-type']
                return_service['svcObjPort2'] = ''
                return_service['svcObjManagement'] = ''
                return_service['svcObjHigherPrecedence'] = ''
                return_service['svcObjComment'] = service['comments']
                if 'color' in service:
                    return_service['svcObjColor'] = service['color']
                else:
                    return_service['svcObjColor'] = 'black'  # set default color to black if none is set
                return_address['svcObjUid'] = service['uid']
                return_services[return_service['svcObjId']] = return_service
                uid_mappings[service['uid']] = service['name']
            except:
                debug(service)
                exit(1)

        objects = get_all_objects(mgmt_ip, sid, 'show-services-other')
        log('!-- Retreived other Services objects : ', len(objects))
        for service in objects:
            try:
                return_service = OrderedDict()
                return_service['svcObjId'] = service['name']
                return_service['svcObjType'] = '1'
                return_service['svcObjProperties'] = ''
                return_service['svcObjIpType'] = '82'
                return_service['svcObjPort1'] = ''
                return_service['svcObjPort2'] = ''
                return_service['svcObjManagement'] = ''
                return_service['svcObjHigherPrecedence'] = ''
                return_service['svcObjComment'] = service['comments']
                if 'color' in service:
                    return_service['svcObjColor'] = service['color']
                else:
                    return_service['svcObjColor'] = 'black'  # set default color to black if none is set
                return_address['svcObjUid'] = service['uid']
                return_services[return_service['svcObjId']] = return_service
                uid_mappings[service['uid']] = service['name']
            except:
                debug(service)
                exit(1)

        objects = get_all_objects(mgmt_ip, sid, 'show-service-groups')
        log('!-- Retreived Service Groups objects : ', len(objects))
        for service in objects:
            return_service = OrderedDict()
            return_service['svcObjId'] = service['name']
            return_service['svcObjType'] = '2'
            return_service['svcObjProperties'] = ''
            return_service['svcObjIpType'] = ''
            return_service['svcObjPort1'] = ''
            return_service['svcObjPort2'] = ''
            return_service['svcObjManagement'] = ''
            return_service['svcObjHigherPrecedence'] = ''
            return_service['svcObjComment'] = service['comments']
            return_service['svcObjColor'] = service['color']
            return_address['svcObjUid'] = service['uid']
            return_service['svcObjMembers'] = service['members']
            return_services[return_service['svcObjId']] = return_service
            uid_mappings[service['uid']] = service['name']

        for service in return_services:
            if return_services[service]['svcObjType'] == '2':
                svc_mappings[return_services[service]['svcObjId']] = []
                for member in return_services[service]['svcObjMembers']:
                    if member in uid_mappings:
                        svc_mappings[return_services[service]['svcObjId']].append(uid_mappings[member])
                    else:  # look up mappings for unknown objects
                        tmp_object = get_all_objects(mgmt_ip, sid, 'show-object', 'object', member)
                        uid_mappings[member] = tmp_object['name']
                        svc_mappings[return_services[service]['svcObjId']].append(uid_mappings[member])
                        debug('{} not in service dictionary - type : {}'.format(member, tmp_object['type']))

        policies = get_all_objects(mgmt_ip, sid, 'show-packages', 'packages')
        log('!-- Retreived Policy Names objects : ', len(policies))

        layers = get_all_objects(mgmt_ip, sid, 'show-access-layers', 'access-layers')
        log('!-- Retreived Layers objects : ', len(objects))

        policy_index = 0
        log('!-- Retreiving Security Rules')
        for policy in policies:
            log('!-- Retrieving Security Policy {}'.format(policy['name']))
            rulesets = get_all_objects(mgmt_ip, sid, 'show-access-rulebase', 'rulebase', policy['name'] + ' Security')
            for ruleitem in rulesets:
                if 'rulebase' in ruleitem:
                    for rule in ruleset['rulebase']:
                        return_policy[policy_index] = OrderedDict()
                        return_policy[policy_index]['policySrcNegate'] = False
                        return_policy[policy_index]['policyDstNegate'] = False
                        return_policy[policy_index]['policySvcNegate'] = False
                        if rule['action']['name'].lower() == 'deny':
                            return_policy[policy_index]['policyAction'] = '0'
                        elif rule['action']['name'].lower() == 'drop':
                            return_policy[policy_index]['policyAction'] = '1'
                        elif rule['action']['name'].lower() == 'accept':
                            return_policy[policy_index]['policyAction'] = '2'
                        elif rule['action']['name'].lower() == 'client auth':
                            return_policy[policy_index]['policyAction'] = '3'
                        return_policy[policy_index]['policySrcZone'] = ''
                        return_policy[policy_index]['policyDstZone'] = ''
                        return_policy[policy_index]['policySrcNegate'] = False
                        return_policy[policy_index]['policyDstNegate'] = False
                        return_policy[policy_index]['policySvcNegate'] = False
                        return_policy[policy_index]['policySrcNet'] = [x['name'] for x in rule['source']]
                        for obj in return_policy[policy_index]['policySrcNet']:
                            if obj not in return_addresses and obj.lower() != 'any':
                                debug('{} not in address dictionary'.format(obj))
                                try:
                                    userobj, addrobj = obj.split('@')
                                    debug('Using Address object {} instead'.format(addrobj))
                                except:
                                    pass
                        return_policy[policy_index]['policyDstNet'] = [x['name'] for x in rule['destination']]
                        for obj in return_policy[policy_index]['policyDstNet']:
                            if obj not in return_addresses and obj.lower() != 'any':
                                debug('{} not in address dictionary'.format(obj))
                                try:
                                    userobj, addrobj = obj.split('@')
                                    debug('Using Address object {} instead'.format(addrobj))
                                except:
                                    pass

                        return_policy[policy_index]['policyDstSvc'] = [x['name'] for x in rule['service']]
                        for obj in return_policy[policy_index]['policyDstSvc']:
                            if obj not in return_services and obj.lower() != 'any':
                                debug('{} not in service dictionary'.format(obj))
                                try:
                                    userobj, svcobj = obj.split('@')
                                    debug('Using Service object {} instead'.format(svcobj))
                                except:
                                    pass

                        return_policy[policy_index]['policyDstApps'] = ''
                        return_policy[policy_index]['policyComment'] = rule['comments']
                        return_policy[policy_index]['policyLog'] = ''
                        if rule['enabled']:
                            return_policy[policy_index]['policyEnabled'] = '1'
                        else:
                            return_policy[policy_index]['policyEnabled'] = '0'
                        return_policy[policy_index]['policyProps'] = ''
                        return_policy[policy_index]['policyNum'] = rule['rule-number']
                        return_policy[policy_index]['policyUiNum'] = rule['rule-number']
                        return_policy[policy_index]['policyName'] = policy['name']
                        return_policy[policy_index]['policyUid'] = policy['uid']
                        policy_index += 1
                else:
                    return_policy[policy_index] = OrderedDict()
                    if ruleitem['action']['name'].lower() == 'deny':
                        return_policy[policy_index]['policyAction'] = '0'
                    elif ruleitem['action']['name'].lower() == 'drop':
                        return_policy[policy_index]['policyAction'] = '1'
                    elif ruleitem['action']['name'].lower() == 'accept':
                        return_policy[policy_index]['policyAction'] = '2'
                    elif ruleitem['action']['name'].lower() == 'client auth':
                        return_policy[policy_index]['policyAction'] = '3'
                    return_policy[policy_index]['policySrcZone'] = ''
                    return_policy[policy_index]['policyDstZone'] = ''
                    return_policy[policy_index]['policySrcNet'] = [x['name'] for x in ruleitem['source']]
                    for obj in return_policy[policy_index]['policySrcNet']:
                        if obj not in return_addresses and obj.lower() != 'any':
                            debug('{} not in address dictionary'.format(obj))
                            try:
                                userobj, addrobj = obj.split('@')
                                debug('Using Address object {} instead'.format(addrobj))
                            except:
                                pass
                    return_policy[policy_index]['policyDstNet'] = [x['name'] for x in ruleitem['destination']]
                    for obj in return_policy[policy_index]['policyDstNet']:
                        if obj not in return_addresses and obj.lower() != 'any':
                            debug('{} not in address dictionary'.format(obj))
                            try:
                                userobj, addrobj = obj.split('@')
                                debug('Using Address object {} instead'.format(addrobj))
                            except:
                                pass

                    return_policy[policy_index]['policyDstSvc'] = [x['name'] for x in ruleitem['service']]
                    for obj in return_policy[policy_index]['policyDstSvc']:
                        if obj not in return_services and obj.lower() != 'any':
                            debug('{} not in service dictionary'.format(obj))
                            try:
                                userobj, svcobj = obj.split('@')
                                debug('Using Service object {} instead'.format(svcobj))
                            except:
                                pass

                    return_policy[policy_index]['policyDstApps'] = ''
                    return_policy[policy_index]['policyComment'] = ruleitem['comments']
                    return_policy[policy_index]['policyLog'] = ''
                    if ruleitem['enabled']:
                        return_policy[policy_index]['policyEnabled'] = '1'
                    else:
                        return_policy[policy_index]['policyEnabled'] = '0'
                    return_policy[policy_index]['policyProps'] = ''
                    return_policy[policy_index]['policyNum'] = ruleitem['rule-number']
                    return_policy[policy_index]['policyUiNum'] = ruleitem['rule-number']
                    return_policy[policy_index]['policyName'] = policy['name']
                    return_policy[policy_index]['policyUid'] = policy['uid']
                    policy_index += 1
        policy_index = 0
        log('!-- Retreiving NAT Rules')
        for policy in policies:
            policy_index = 0
            log('!-- Retrieving NAT Policy {}'.format(policy['name']))
            rulesets = get_all_objects(mgmt_ip, sid, 'show-nat-rulebase', 'rulebase', policy['name'])
            for ruleitem in rulesets:
                if 'rulebase' in ruleitem:
                    for rule in ruleitem['rulebase']:
                        return_nat[policy_index] = OrderedDict()
                        # print(json.dumps(rule, indent=4))
                        return_nat[policy_index]['policyOrigSrc'] = rule['original-source']['name']
                        return_nat[policy_index]['policyTransSrc'] = rule['translated-source']['name']
                        return_nat[policy_index]['policyOrigDst'] = rule['original-destination']['name']
                        return_nat[policy_index]['policyTransDst'] = rule['translated-destination']['name']
                        return_nat[policy_index]['policyOrigSvc'] = rule['original-service']['name']
                        return_nat[policy_index]['policyTransSvc'] = rule['translated-service']['name']
                        return_nat[policy_index]['policyDstApps'] = ''
                        return_nat[policy_index]['policyComment'] = rule['comments']
                        return_nat[policy_index]['policyLog'] = ''
                        if rule['enabled']:
                            return_nat[policy_index]['policyEnabled'] = '1'
                        else:
                            return_nat[policy_index]['policyEnabled'] = '0'
                        return_nat[policy_index]['policyProps'] = ''
                        return_nat[policy_index]['policyNum'] = rule['rule-number']
                        return_nat[policy_index]['policyUiNum'] = rule['rule-number']
                        return_nat[policy_index]['policyName'] = policy['name']
                        return_nat[policy_index]['policyUid'] = policy['uid']
                        policy_index += 1
                else:
                    return_nat[policy_index] = OrderedDict()
                    return_nat[policy_index]['policyOrigSrc'] = ruleitem['original-source']['name']
                    return_nat[policy_index]['policyTransSrc'] = ruleitem['translated-source']['name']
                    return_nat[policy_index]['policyOrigDst'] = ruleitem['original-destination']['name']
                    return_nat[policy_index]['policyTransDst'] = ruleitem['translated-destination']['name']
                    return_nat[policy_index]['policyOrigSvc'] = ruleitem['original-service']['name']
                    return_nat[policy_index]['policyTransSvc'] = ruleitem['translated-service']['name']
                    return_nat[policy_index]['policyDstApps'] = ''
                    return_nat[policy_index]['policyComment'] = ruleitem['comments']
                    return_nat[policy_index]['policyLog'] = ''
                    if ruleitem['enabled']:
                        return_nat[policy_index]['policyEnabled'] = '1'
                    else:
                        return_nat[policy_index]['policyEnabled'] = '0'
                    return_nat[policy_index]['policyProps'] = ''
                    return_nat[policy_index]['policyNum'] = ruleitem['rule-number']
                    return_nat[policy_index]['policyUiNum'] = ruleitem['rule-number']
                    return_nat[policy_index]['policyName'] = policy['name']
                    return_nat[policy_index]['policyUid'] = policy['uid']
                    policy_index += 1

    else:
        log(message)
    # temp_config=None
    # print ('policy len', len(return_policy))
    # print(json.dumps(return_nat, indent=4))
    return_config['addresses'] = return_addresses
    return_config['services'] = return_services
    return_config['policies'] = return_policy  # return_policy
    return_config['nat'] = return_nat
    return_config['zones'] = {}
    return_config['interfaces'] = {}
    return_config['apps'] = {}
    return_config['routing'] = OrderedDict()
    return_config['addressmappings'] = addr_mappings
    return_config['servicemappings'] = svc_mappings
    return_config['logprofiles'] = ''
    return_config['config']['name'] = context  ## CHANGEME (how do I get firewall name)
    return_config['config']['version'] = ''
    return_config['config']['fw_type'] = 'R80'
    return_config['config']['mgmtip'] = None
    return_config['usedzones'] = []

    return return_config


def load_checkpoint_routing(routeobj):
    return_routing = OrderedDict()
    return_interface = OrderedDict()
    return_zone = OrderedDict()

    with open(routeobj, 'r') as infile:
        content = infile.read()
        infile.close()
        route_index = 0
        if_index = 1
        # log(content.split('\n'))
        try:
            for line in content.split('\n'):
                if len(line.split(',')) == 8:
                    return_routing[route_index] = {}
                    dest, gateway, destmask, flags, mss, window, irtt, interface = list(line.split(','))
                    return_routing[route_index]['pbrObjDst'] = '{}/{}'.format(dest, netmask_to_cidr(destmask))
                    if gateway != '0.0.0.0':
                        return_routing[route_index]['pbrObjGw'] = gateway
                    else:
                        return_routing[route_index]['pbrObjGw'] = dest
                    return_routing[route_index]['pbrObjIface'] = interface
                    return_routing[route_index]['pbrObjMetric'] = '0'
                    return_routing[route_index]['pbrObjSrc'] = ''

                    if interface not in return_interface:
                        zone_name = 'Zone{}'.format(str(if_index))
                        debug('INTERFACE: {} Zone: {} '.format(interface, zone_name))
                        return_interface[interface] = {}
                        return_interface[interface]['iface_ifnum'] = str(if_index)
                        return_interface[interface]['iface_name'] = interface
                        return_interface[interface]['interface_Zone'] = zone_name
                        if gateway != '0.0.0.0':
                            return_interface[interface]['iface_static_ip'] = gateway
                        else:
                            return_interface[interface]['iface_static_ip'] = dest
                        return_interface[interface]['iface_lan_ip'] = '0.0.0.0'
                        return_interface[interface]['iface_mgmt_ip'] = '0.0.0.0'
                        return_interface[interface]['iface_static_mask'] = destmask
                        return_interface[interface]['iface_lan_mask'] = '0.0.0.0'
                        return_interface[interface]['iface_mgmt_netmask'] = '0.0.0.0'
                        return_interface[interface]['iface_static_gateway'] = gateway
                        return_interface[interface]['iface_lan_default_gw'] = '0.0.0.0'
                        return_interface[interface]['iface_mgmt_default_gw'] = '0.0.0.0'
                        return_zone[zone_name] = {}
                        return_zone[zone_name]['zoneObjId'] = zone_name
                        return_zone[zone_name]['zoneObjComment'] = ''
                        if_index += 1
                    if dest == '0.0.0.0':
                        return_zone['default'] = return_interface[interface]['interface_Zone']

                    route_index += 1
        except Exception as e:
            debug('!-- Reading Route file failed')
            debug(e)
            debug(e)
            debug(e)

    return return_routing, return_interface, return_zone


def load_checkpoint(path='', netobj='network_objects.xml', secobj='Security_Policy.xml', svcobj='services.xml',
                    natobj='NAT_Policy.xml', routeobj=None):
    ## Add service mappings
    ##

    import xmltodict
    import json
    from collections import OrderedDict
    import xml.etree.ElementTree as et

    import ipaddress
    from netaddr import IPSet

    return_config = OrderedDict()
    return_config['config'] = OrderedDict()
    return_config['config']['policylen'] = {}

    return_addresses = OrderedDict()
    return_service = OrderedDict()
    return_policy = OrderedDict()
    return_nat = OrderedDict()
    return_address = OrderedDict()
    return_routing = OrderedDict()
    return_interface = OrderedDict()
    return_zone = OrderedDict()
    addr_mappings = OrderedDict()
    svc_mappings = OrderedDict()

    log('  |-- Routing Policy  \r', end=' ')
    ## ['pbrObjId', 'pbrObjProperties', 'pbrObjSrc', 'pbrObjDst', 'pbrObjSvc', 'pbrObjGw', 'pbrObjIface', 'pbrObjIfaceName', 'pbrObjMetric', 'pbrObjPriority', 'pbrObjProbe', 'pbrObjComment']
    ## interface_props = ['iface_ifnum', 'iface_type', 'iface_name', 'interface_Zone', 'iface_comment', 'iface_static_ip', 'iface_static_mask', 'iface_static_gateway', 'iface_lan_ip', 'iface_lan_mask', 'iface_lan_default_gw', 'iface_mgmt_ip', 'iface_mgmt_netmask', 'iface_mgmt_default_gw', 'iface_static_gateway', 'iface_vlan_tag', 'iface_comment', 'iface_http_mgmt', 'iface_https_mgmt', 'iface_ssh_mgmt', 'iface_ping_mgmt', 'iface_snmp_mgmt', 'portShutdown']
    ## zone_props = ['zoneObjId', 'zoneObjComment']

    if routeobj:
        return_routing, return_interface, return_zone = load_checkpoint_routing(routeobj)

    else:
        return_routing = OrderedDict()

    for index in return_routing:
        debug(return_routing[index])
    for index in return_interface:
        debug(return_interface[index])

    log('  |-- Address Objects  \r', end=' ')

    with open(netobj, 'r') as infile:
        content = infile.read()
    infile.close()
    networkdict = xmltodict.parse(content)
    classes = []

    ## load address objects

    for z in networkdict['network_objects']['network_object']:
        return_address = OrderedDict()
        current_address = z['Name']
        if z['Class_Name'].lower() == 'security_zone':
            return_address['addrObjType'] = '97'  # placeholder
        elif z['Class_Name'].lower() in ['network_object_group', 'group_with_exception', 'host_plain', 'address_range',
                                         'network', 'gateway_plain', 'cluster_member', 'dynamic_object',
                                         'gateway_cluster', 'host_ckp', 'ep_hostname', 'gateway_ckp',
                                         'vs_cluster_member', 'vs_cluster_netobj']:
            return_address['addrObjId'] = current_address
            return_address['addrObjIdDisp'] = ''
            return_address['addrObjType'] = ''
            return_address['addrObjZone'] = ''
            return_address['addrObjProperties'] = '14'
            return_address['addrObjIp1'] = ''
            return_address['addrObjIp2'] = ''
            return_address['addrObjComment'] = ''
            return_address['addrObjColor'] = ''
            return_address['IPv4Networks'] = [ipaddress.IPv4Network(u'255.255.255.255/32')]

            if z['Class_Name'].lower() == 'network_object_group':
                addr_mappings[current_address] = []
                return_address['addrObjType'] = '8'
                return_address['addrObjIdDisp'] = z['comments']
                if z['comments'] != None:
                    return_address['addrObjComment'] = z['comments']
                else:
                    return_address['addrObjComment'] = ''
                if z['members'] != None:
                    if 'Name' in z['members']['reference']:
                        addr_mappings[current_address] = [z['members']['reference']['Name']]
                    else:
                        for mem in z['members']['reference']:
                            addr_mappings[current_address].append(mem['Name'])
                if 'color' in z:
                    return_address['addrObjColor'] = z['color']


            elif z['Class_Name'].lower() in ['cluster_member', 'gateway_ckp', 'vs_cluster_member', 'vs_cluster_netobj']:
                return_address['addrObjType'] = '91'  ## Unsupported Checkpoint Type
                if z['interfaces'] != None:
                    if len(z['interfaces']['interfaces']) >= 1:
                        return_address['IPv4Networks'] == []
                        return_address['addrObjList'] = []
                elif 'ipaddr' in z:
                    return_address['IPv4Networks'] == []
                    return_address['addrObjList'] = []
                    return_address['addrObjIp1'] = z['ipaddr']
                    return_address['addrObjIp2'] = '255.255.255.255'
                    return_address['addrObjList'].append((z['ipaddr'], '255.255.255.255'))
                    return_address['IPv4Networks'].append(ipaddress.IPv4Network(z['ipaddr'] + '/32', strict=False))
                if z['comments'] != None:
                    return_address['addrObjComment'] = z['comments']
                    return_address['addrObjIdDisp'] = z['comments']
                else:
                    return_address['addrObjComment'] = ''
                    return_address['addrObjIdDisp'] = ''
                if 'color' in z: return_address['addrObjColor'] = z['color']

            elif z['Class_Name'].lower() == 'group_with_exception':
                ## A group with exceptions is simply a single group of included addresses with a single group of excluded addresses
                ## handle this as a group type, parameters are GroupName, ExcludedGroup -
                return_address['addrObjType'] = '98'
                addr_mappings[current_address] = []
                # return_address['addrObjType'] = '8'
                return_address['addrObjIdDisp'] = z['comments']
                if z['comments'] != None: return_address['addrObjComment'] = z['comments']
                if 'color' in z: return_address['addrObjColor'] = z['color']
                return_address['include'] = z['base']['Name']
                return_address['exclude'] = z['exception']['Name']
            elif z['Class_Name'].lower() == 'host_plain' and z['ipaddr'] != None:  # ipv4 support only
                return_address['addrObjType'] = '1'
                return_address['addrObjIp1'] = z['ipaddr']
                return_address['addrObjIp2'] = '255.255.255.255'
                return_address['addrObjIdDisp'] = z['comments']
                if z['comments'] != None: return_address['addrObjComment'] = z['comments']
                if 'color' in z: return_address['addrObjColor'] = z['color']
                return_address['IPv4Networks'] = [ipaddress.IPv4Network(return_address['addrObjIp1'] + '/32')]
            elif z['Class_Name'].lower() == 'address_range' and z['ipaddr_first'] != None:
                return_address['addrObjType'] = '2'
                return_address['addrObjIp1'] = z['ipaddr_first']
                return_address['addrObjIp2'] = z['ipaddr_last']
                return_address['IPv4Networks'] = [ipaddr for ipaddr in ipaddress.summarize_address_range(
                    ipaddress.IPv4Address(return_address['addrObjIp1']),
                    ipaddress.IPv4Address(return_address['addrObjIp2']))]
                return_address['addrObjIdDisp'] = z['comments']
                if z['comments'] != None: return_address['addrObjComment'] = z['comments']
                if 'color' in z: return_address['addrObjColor'] = z['color']
            elif z['Class_Name'].lower() == 'network' and z['ipaddr'] != None:
                return_address['addrObjType'] = '4'
                return_address['addrObjIdDisp'] = z['comments']
                if z['comments'] != None: return_address['addrObjComment'] = z['comments']
                return_address['addrObjIp1'] = z['ipaddr']
                return_address['addrObjIp2'] = z['netmask']
                return_address['IPv4Networks'] = [
                    ipaddress.IPv4Network(return_address['addrObjIp1'] + '/' + return_address['addrObjIp2'],
                                          strict=False)]
                if 'color' in z: return_address['addrObjColor'] = z['color']
            elif z['Class_Name'].lower() in ['gateway_plain', 'cluster_member', 'dynamic_object', 'gateway_cluster',
                                             'host_ckp', 'ep_hostname']:
                return_address['addrObjType'] = '99'  ## Unhandled address types are set to 99
                return_address['addrObjIdDisp'] = z['comments']
                if z['comments'] != None: return_address['addrObjComment'] = z['comments']
                if 'ipaddr' in z: return_address['addrObjIp1'] = z['ipaddr']
                return_address['addrObjIp2'] = '255.255.255.255'
                if 'ipaddr' in z: return_address['IPv4Networks'] = [
                    ipaddress.IPv4Network(return_address['addrObjIp1'] + '/' + return_address['addrObjIp2'],
                                          strict=False)]  #
                if 'color' in z: return_address['addrObjColor'] = z['color']
            else:
                log(z['Class_Name'].lower() + ' skipped - Unknown Address Type', level=logging.INFO)
            try:
                return_address['connection_limit'] = z['firewall_setting']['connections_limit']
                return_address['auto_calc_conns'] = z['firewall_setting']['auto_calc_concurrent_conns']
            except:
                pass

            ## The assignment below should only be done if one of the supported address types were found

            return_addresses[current_address] = OrderedDict()
            return_addresses[current_address] = return_address

    ## Add IPSet property to address groups
    for addr in return_addresses:
        if return_addresses[addr]['addrObjType'] == '8':
            return_addresses[addr]['IPSet'] = IPSet([])
            for groupmember in expand_address(return_addresses, addr, addr_mappings):
                for network in return_addresses[groupmember]['IPv4Networks']:
                    return_addresses[addr]['IPSet'].add(str(network))
    for addr in return_addresses:
        if return_addresses[addr]['addrObjType'] == '98':
            debug('address', addr)
            if return_addresses[addr]['include'].lower() in ['any', 'all']:
                included = IPSet(['0.0.0.0/0'])
            else:
                included = return_addresses[return_addresses[addr]['include']]['IPSet']
            if return_addresses[addr]['exclude'] in ['any', 'all']:
                included = IPSet(['0.0.0.0/0'])
            else:
                excluded = return_addresses[return_addresses[addr]['exclude']]['IPSet']
            debug('included', included)
            debug('excluded', excluded)
            debug('result set', included ^ excluded)
            return_addresses[addr]['IPSet'] = included ^ excluded

    ## load policies

    ## 11/26/18 - Policies need to be loaded differently.. Previously the entire XML was simply converted to an OrderedDict() via xmltodict.  This is insufficient
    ## as there may be multiple elements at the same level with the same tag (Ie: <Name> for the policy name)
    ## The new method will iterate through each element within ./fw_policies/fw_policie, change the current policy name as it encounters it, and use that for the subsequent
    ## <rule> section, which can be converted to OderedDict to keep the same routines previously used for processing rules.

    ## 12/10/18 -- new method for reading in merged policies made.  first, the policies should be combined using xmlstarlet to format the xml, and all but the first "<?xml>" line stripped.
    ## In addition all of the top level policies "<fw_policies>" must be wrapped in a new root tag.  I am using "<multi>" to do this.  This means to support a single policy, I had to
    ## artifically place a "<multi>" tag in the XML so that the structure is the same.

    log('  |-- Policy Objects         \r', end='')

    tree = et.parse(path + secobj)
    root = tree.getroot()
    if root.tag.lower() != 'multi':  # this is an individual policy package XML file, so we need to wrap the XML in a <multi> tag
        oldroot = root
        root = et.Element('multi')
        root.append(oldroot)

    classes = []
    rule_index = 0
    ui_index = 1
    policy_index = 0
    policyname = '##Standard'  # set default policy name, just in case
    skippedpolicies = []

    for multi in root:
        for policy in multi:
            for child in policy:
                if child.tag.lower() == 'name':
                    ## following two lines are to print the last rule for each policy for secureid validation
                    # print(policyname)
                    # if policy_index-1 in return_policy:
                    #    print(return_policy[policy_index-1])

                    policyname = child.text
                    section_name = ''
                    log("  |-- " + policyname)  # , level=logging.INFO)
                    rule_index = 0  # rule index is reset for each policy name, as each policy name is a seperate policy package, and therefore a seperate database table
                    ui_index = 1
                # debug(options.includepolicies)
                if policyname[2:] in options.includepolicies or options.includepolicies == ['all']:

                    if child.tag.lower() == 'rule':
                        # print('"'+ policyname + '"', rule_index)

                        ## process rules
                        policydict = xmltodict.parse(et.tostring(child))
                        # if policyname == '##Isilon-Tokyo-Lab-PreMPLS':
                        # print(policyname, end=' ')
                        # print(len(policydict['rule']['rule']))
                        if policydict['rule'] != None:
                            # print(policyname, end=' ')
                            # print(type(policydict['rule']['rule']))
                            if type(policydict['rule']['rule']) != list:
                                # print(policyname)
                                tempx = policydict  # ['rule']
                            else:
                                tempx = policydict['rule']['rule']
                        # print('-' * 180)
                        if policydict['rule'] != None:
                            # print(len(policydict['rule'['rule']]))
                            return_config['config']['policylen'][policyname] = len(tempx)
                            for x in tempx:
                                # if policyname=='##Isilon-Tokyo-Lab-PreMPLS':
                                # print(x)
                                if 'header_text' not in x:
                                    return_policy[policy_index] = OrderedDict()
                                    return_policy[policy_index]['policyName'] = policyname
                                    return_policy[policy_index]['policyProps'] = '0'
                                    return_policy[policy_index]['policyAction'] = ''
                                    return_policy[policy_index]['policySrcZone'] = []
                                    return_policy[policy_index]['policyDstZone'] = []
                                    return_policy[policy_index]['policySrcNet'] = []
                                    return_policy[policy_index]['policyDstNet'] = []
                                    return_policy[policy_index]['policySrcNegate'] = False
                                    return_policy[policy_index]['policyDstNegate'] = False
                                    return_policy[policy_index]['policySvcNegate'] = False
                                    return_policy[policy_index]['policyDstSvc'] = []
                                    return_policy[policy_index]['policyDstApps'] = []
                                    return_policy[policy_index]['policyUid'] = ''
                                    return_policy[policy_index]['policyNum'] = rule_index
                                    return_policy[policy_index]['policyUiNum'] = ui_index
                                    return_policy[policy_index]['policySection'] = section_name

                                    ui_index += 1  ## verify this is the right place to increase UI Index, and it doesnt belong in the if statement below

                                    if type(x) != str:
                                        if 'comments' in x:
                                            if x['comments'] == None:
                                                return_policy[policy_index]['policyComment'] = ''
                                            else:
                                                return_policy[policy_index]['policyComment'] = x['comments']
                                        else:
                                            return_policy[policy_index]['policyComment'] = ''
                                        return_policy[policy_index]['policyLog'] = ''
                                        return_policy[policy_index]['policyProps'] = '0'
                                        return_policy[policy_index]['policyUid'] = x['Rule_UUID']
                                        try:
                                            if x['action']['action']['Name'].lower() == 'accept':
                                                pass
                                        except:
                                            log(json.dumps(x, indent=4))
                                        if x['action']['action']['Name'].lower() == 'accept':
                                            return_policy[policy_index]['policyAction'] = '2'
                                        elif x['action']['action']['Name'].lower() == 'client auth':
                                            return_policy[policy_index]['policyAction'] = '3'
                                        else:
                                            return_policy[policy_index]['policyAction'] = '1'

                                        if x['disabled'].lower() == 'false':  # default to policy disabled
                                            return_policy[policy_index]['policyEnabled'] = '1'
                                        else:
                                            return_policy[policy_index]['policyEnabled'] = '0'
                                        if x['src']['members'] != None:
                                            if 'Name' in x['src']['members']['reference']:
                                                return_policy[policy_index]['policySrcNet'] = [
                                                    x['src']['members']['reference']['Name']]
                                            else:
                                                for mem in x['src']['members']['reference']:
                                                    return_policy[policy_index]['policySrcNet'].append(mem['Name'])
                                        else:
                                            return_policy[policy_index]['policySrcNet'] = ['any']
                                        if 'op' in x['src']:
                                            if x['src']['op'] == 'not in':
                                                return_policy[policy_index]['policySrcNegate'] = True
                                                debug('Source Objects are negated in this rule')
                                        if x['dst']['members'] != None:
                                            if 'Name' in x['dst']['members']['reference']:
                                                return_policy[policy_index]['policyDstNet'] = [
                                                    x['dst']['members']['reference']['Name']]
                                            else:
                                                for mem in x['dst']['members']['reference']:
                                                    return_policy[policy_index]['policyDstNet'].append(mem['Name'])
                                        else:
                                            return_policy[policy_index]['policyDstNet'] = ['any']
                                        if 'op' in x['dst']:
                                            if x['dst']['op'] == 'not in':
                                                return_policy[policy_index]['policyDstNegate'] = True
                                                debug('Destination Objects are negated in this rule')

                                        if x['services']['members'] != None:
                                            if 'Name' in x['services']['members']['reference']:
                                                return_policy[policy_index]['policyDstSvc'] = [
                                                    x['services']['members']['reference']['Name']]
                                            else:
                                                for mem in x['services']['members']['reference']:
                                                    return_policy[policy_index]['policyDstSvc'].append(mem['Name'])
                                        else:
                                            return_policy[policy_index]['policyDstSvc'] = ['any']
                                        if 'op' in x['services']:
                                            if x['services']['op'] == 'not in':
                                                return_policy[policy_index]['policySvcNegate'] = True
                                                debug('Service Objects are negated in this rule')
                                else:
                                    section_header = x['header_text']
                                    log('   Policy Section :', section_header)
                                policy_index += 1
                                rule_index += 1
                            '''if policydict['rule']!=None:
                                if policydict['rule']['rule']!=None:
                                    if len(return_config['config']['policylen'][policyname])!= rule_index:
                                        print(policyname, end=' ')
                        '''
                else:
                    if policyname not in skippedpolicies:
                        log('Skipping policy : ' + policyname[2:], level=logging.INFO)
                        skippedpolicies.append(policyname)
    ## load NAT policies
    log('  |-- NAT Objects             \r', end='')

    tree = et.parse(path + natobj)
    root = tree.getroot()
    if root.tag.lower() != 'multi':  # this is an individual policy package XML file, so we need to wrap the XML in a <multi> tag
        oldroot = root
        root = et.Element('multi')
        root.append(oldroot)

    import json
    import re

    classes = []
    rule_index = 0
    policy_index = 0
    ui_index = 1
    policyname = '##Standard'  # set default policy name, just in case
    for multi in root:
        for policy in multi:
            for child in policy:
                if child.tag.lower() == 'name':
                    policyname = child.text
                    log("  |-- " + policyname, level=logging.INFO)
                    rule_index = 0  # rule index is reset for each policy name, as each policy name is a seperate policy package, and therefore a seperate database table
                    ui_index = 1
                if policyname[2:] in options.includepolicies or options.includepolicies == ['all']:
                    if child.tag.lower() == 'rule_adtr':
                        ## process rules
                        policydict = xmltodict.parse(et.tostring(child))
                        if policydict['rule_adtr'] != None:
                            for x in policydict['rule_adtr']['rule_adtr']:
                                if 'Class_Name' in x and type(x) != str:
                                    if x['Class_Name'] == 'address_translation_rule':
                                        return_nat[policy_index] = OrderedDict()
                                        return_nat[policy_index]['natPolicyName'] = policyname
                                        return_nat[policy_index]['natPolicyNum'] = rule_index
                                        return_nat[policy_index]['natPolicyUiNum'] = ui_index
                                        return_nat[policy_index]['natPolicyOrigSrc'] = []
                                        return_nat[policy_index]['natPolicyOrigDst'] = []
                                        return_nat[policy_index]['natPolicyOrigSvc'] = []
                                        return_nat[policy_index]['natPolicyTransSrc'] = []
                                        return_nat[policy_index]['natPolicyTransDst'] = []
                                        return_nat[policy_index]['natPolicyTransSvc'] = []
                                        return_nat[policy_index]['natPolicySrcIface'] = []
                                        return_nat[policy_index]['natPolicyDstIface'] = []
                                        return_nat[policy_index]['natPolicyEnabled'] = ''
                                        return_nat[policy_index]['natPolicyComment'] = ''
                                        return_nat[policy_index]['natpolicyUid'] = ''
                                        return_nat[policy_index]['natPolicyProperties'] = '0'
                                        ui_index += 1
                                        if 'comments' in x:
                                            if x['comments'] != None:
                                                return_nat[policy_index]['policyComment'] = x['comments']
                                            else:
                                                return_nat[policy_index]['policyComment'] = ''
                                        else:
                                            return_nat[policy_index]['policyComment'] = ''

                                        if x['disabled'].lower() == 'false':  # default to policy disabled
                                            return_nat[policy_index]['natPolicyEnabled'] = '1'
                                        else:
                                            return_nat[policy_index]['natPolicyEnabled'] = '0'

                                        if 'src_adtr' in x:
                                            if x['src_adtr'] != None:
                                                if 'Name' in x['src_adtr']['src_adtr']:
                                                    return_nat[policy_index]['natPolicyOrigSrc'] = [
                                                        x['src_adtr']['src_adtr']['Name']]
                                                else:
                                                    return_nat[policy_index]['natPolicyOrigSrc'] = 'Any'
                                        else:
                                            return_nat[policy_index]['natPolicyOrigSrc'] = 'Any'

                                        if 'dst_adtr' in x:
                                            if x['dst_adtr'] != None:
                                                if 'Name' in x['dst_adtr']['dst_adtr']:
                                                    return_nat[policy_index]['natPolicyOrigDst'] = [
                                                        x['dst_adtr']['dst_adtr']['Name']]
                                                else:
                                                    return_nat[policy_index]['natPolicyOrigDst'] = 'Any'
                                        else:
                                            return_nat[policy_index]['natPolicyOrigDst'] = 'Any'

                                        if 'services_adtr' in x:
                                            if x['services_adtr'] != None:
                                                if 'Name' in x['services_adtr']['services_adtr']:
                                                    return_nat[policy_index]['natPolicyOrigSvc'] = [
                                                        x['services_adtr']['services_adtr']['Name']]
                                                else:
                                                    return_nat[policy_index]['natPolicyOrigSvc'] = 'Any'
                                        else:
                                            return_nat[policy_index]['natPolicyOrigSvc'] = 'Any'

                                        if x['src_adtr_translated'] != None:
                                            if 'Name' in x['src_adtr_translated']['reference']:
                                                return_nat[policy_index]['natPolicyTransSrc'] = [
                                                    x['src_adtr_translated']['reference']['Name']]
                                                if len(re.findall('method_hide',
                                                                  x['src_adtr_translated']['adtr_method'])) > 0:
                                                    return_nat[policy_index][
                                                        'natPolicyTransSrcMethod'] = 'translate_hide'
                                                else:
                                                    return_nat[policy_index][
                                                        'natPolicyTransSrcMethod'] = 'translate_static'
                                        else:
                                            return_nat[policy_index]['natPolicyTransSrc'] = 'Any'

                                        if x['dst_adtr_translated'] != None:
                                            if 'Name' in x['dst_adtr_translated']['reference']:
                                                return_nat[policy_index]['natPolicyTransDst'] = [
                                                    x['dst_adtr_translated']['reference']['Name']]
                                                if len(re.findall('method_hide',
                                                                  x['dst_adtr_translated']['adtr_method'])) > 0:
                                                    return_nat[policy_index][
                                                        'natPolicyTransDstMethod'] = 'translate_hide'
                                                else:
                                                    return_nat[policy_index][
                                                        'natPolicyTransDstMethod'] = 'translate_static'
                                        else:
                                            return_nat[policy_index]['natPolicyTransDst'] = 'Any'

                                        if x['services_adtr_translated'] != None:
                                            if 'Name' in x['services_adtr_translated']['reference']:
                                                return_nat[policy_index]['natPolicyTransSvc'] = [
                                                    x['services_adtr_translated']['reference']['Name']]
                                                return_nat[policy_index][
                                                    'natPolicyTransSvcMethod'] = 'service_translate'
                                        else:
                                            return_nat[policy_index]['natPolicyTransSvc'] = 'Any'
                                    policy_index += 1
                                    rule_index += 1

    ## load services

    if svcobj != '':
        log('  |-- Service Objects         \r', end='')
        with open(path + svcobj, 'r') as infile:
            content = infile.read()
        infile.close()
        servicedict = xmltodict.parse(content)
        classes = []

        ## need to handle 'other_service', rpc_service'

        for x in servicedict['services']['service']:
            if x['Class_Name'].lower() in ['tcp_service', 'udp_service', 'service_group', 'other_service',
                                           'rpc_service', 'icmp_service']:
                current_service = x['Name']
                return_service[current_service] = OrderedDict()
                return_service[current_service]['svcObjId'] = current_service
                return_service[current_service]['svcObjType'] = '1'
                return_service[current_service]['svcObjProperties'] = '14'
                return_service[current_service]['svcObjIpType'] = '0'
                return_service[current_service]['svcObjPort1'] = ''
                return_service[current_service]['svcObjPort2'] = ''
                return_service[current_service]['svcObjSrcPort'] = '0'
                return_service[current_service]['svcObjManagement'] = ''
                return_service[current_service]['svcObjHigherPrecedence'] = ''
                return_service[current_service]['svcObjComment'] = ''
                return_service[current_service]['svcObjColor'] = ''

                if x['comments'] != None:
                    return_service[current_service]['svcObjComment'] = x['comments']
                if x['color'] != None:
                    return_service[current_service]['svcObjColor'] = x['color']

                if x['Class_Name'] not in classes:
                    classes.append(x['Class_Name'])
                if x['Class_Name'].lower() == 'tcp_service':
                    return_service[current_service]['svcObjIpType'] = '6'
                if x['Class_Name'].lower() == 'udp_service':
                    return_service[current_service]['svcObjIpType'] = '17'
                if x['Class_Name'].lower() in ['tcp_service', 'udp_service']:
                    # return_service[current_service]['svcObjComment'] = x['comments']
                    if x['port'][0] == '>':  ## greater than port modifier
                        return_service[current_service]['svcObjPort1'] = str(int(x['port'][1:]) + 1)
                        return_service[current_service]['svcObjPort2'] = '65535'
                    elif x['port'][0] == '<':  ## greater than port modifier
                        return_service[current_service]['svcObjPort1'] = '1'
                        return_service[current_service]['svcObjPort2'] = str(int(x['port'][1:]) - 1)
                    else:
                        ports = x['port'].split('-')
                        if len(ports) == 2:
                            return_service[current_service]['svcObjPort1'], return_service[current_service][
                                'svcObjPort2'] = x['port'].split('-')
                        else:
                            return_service[current_service]['svcObjPort1'] = x['port']
                            return_service[current_service]['svcObjPort2'] = x['port']
                if x['Class_Name'].lower() == 'icmp_service':
                    return_service[current_service]['svcObjIpType'] = '1'
                    return_service[current_service]['svcObjPort1'] = x[
                        'icmp_type']  ## putting the ICMP type into the port1 field
                    # return_service[current_service]['svcObjComment'] = x['comments']
                if x['Class_Name'].lower() == 'other_service':  # placeholder for other_service type
                    return_service[current_service][
                        'svcObjType'] = '99'  # placeholder for other_type which likely uses an expression
                    # return_service[current_service]['svcObjIpType'] = x['protocol'] ## this was commented out as it was allowing get_prot_of and get_port_of to function, but returning bad results.
                    # return_service[current_service]['svcObjComment'] = x['comments']
                if x['Class_Name'].lower() == 'rpc_service':  # placeholder for rpc_service type
                    return_service[current_service]['svcObjIpType'] = '97'  ## placeholder for RPC service type
                    return_service[current_service]['svcObjPort1'] = x[
                        'port']  ## putting the RPC port into the port1 field
                    # return_service[current_service]['svcObjComment'] = x['comments']

                if x['Class_Name'].lower() == 'service_group':
                    svc_mappings[current_service] = []
                    return_service[current_service]['svcObjType'] = '2'
                    # return_service[current_service]['svcObjComment'] = x['comments']
                    if x['members'] != None:
                        if 'Name' in x['members']['reference']:
                            svc_mappings[current_service] = [x['members']['reference']['Name']]
                        else:
                            for mem in x['members']['reference']:
                                svc_mappings[current_service].append(mem['Name'])
            else:
                pass
                debug('unknown service type ' + x['Class_Name'].lower() + ' for ' + x['Name'])

    ## This loop checks that each service specified in each policy is loaded as a configuration object

    for pol in return_policy:
        for svc in return_policy[pol]['policyDstSvc']:
            if svc not in return_service and svc.lower() != 'any':
                log(svc + ' not found', level=logging.INFO)

    for pol in return_policy:
        for addr in return_policy[pol]['policySrcNet']:
            if addr not in return_addresses and addr.lower() != 'any':
                log(addr + ' not found', level=logging.INFO)
        for addr in return_policy[pol]['policyDstNet']:
            if addr not in return_addresses and addr.lower() != 'any':
                log(addr + ' not found', level=logging.INFO)

    return_config['addresses'] = return_addresses
    return_config['services'] = return_service
    return_config['policies'] = return_policy  # return_policy
    return_config['nat'] = return_nat
    return_config['zones'] = return_zone
    return_config['interfaces'] = return_interface
    return_config['apps'] = {}
    return_config['routing'] = return_routing
    return_config['addressmappings'] = addr_mappings
    return_config['servicemappings'] = svc_mappings
    return_config['logprofiles'] = ''
    return_config['config']['name'] = options.checkpointcontext  ## CHANGEME (how do I get firewall name)
    return_config['config']['version'] = ''
    return_config['config']['fw_type'] = 'checkpoint'
    return_config['config']['mgmtip'] = None
    return_config['config']['usedzones'] = []

    return return_config


def load_xml(infile, memoryconfig=None):
    ## Load Panorama configuration .xml file
    ## Loading Shared objects not fully implemented CHANGEME (load policies)
    ## DONE Detect Pano vs Palo config and load appropriately
    ## DONE Pano should have xpath /config/mgt-config/devices

    def load_addresses(address_list):

        from collections import OrderedDict

        return_address = OrderedDict()

        for address in address_list:
            current_address = address.get('name')
            return_address[current_address] = OrderedDict()
            return_address[current_address]['addrObjId'] = current_address
            return_address[current_address]['addrObjIdDisp'] = ''
            return_address[current_address]['addrObjType'] = ''
            return_address[current_address]['addrObjZone'] = ''
            return_address[current_address]['addrObjProperties'] = '14'
            return_address[current_address]['addrObjIp1'] = ''
            return_address[current_address]['addrObjIp2'] = ''
            return_address[current_address]['addrObjComment'] = ''
            return_address[current_address]['addrObjColor'] = ''
            return_address[current_address]['IPv4Networks'] = [ipaddress.IPv4Network(u'255.255.255.255/32')]

            for address_tags in address.findall('.'):

                for item in address_tags.iter():
                    if item.tag in ['ip-netmask', 'ip-range', 'description', 'fqdn']:
                        if item.tag.lower() == 'ip-netmask':
                            if re.findall('/', item.text):
                                ipaddr, mask = item.text.split('/')
                                if mask == '32':
                                    return_address[current_address]['addrObjType'] = '1'
                                    return_address[current_address]['addrObjIp1'] = ipaddr
                                    return_address[current_address]['addrObjIp2'] = '255.255.255.255'
                                elif int(mask) < 32:
                                    return_address[current_address]['addrObjType'] = '4'
                                    return_address[current_address]['addrObjIp2'] = cidr_to_netmask(mask)
                                    return_address[current_address]['addrObjIp1'] = ipaddr
                                else:
                                    return_address[current_address][
                                        'addrObjType'] = '66'  # placeholder for IPv6 Addresses
                                try:
                                    return_address[current_address]['IPv4Networks'] = [
                                        ipaddress.IPv4Network(item.text, strict=False)]
                                except:
                                    pass
                            else:
                                return_address[current_address]['addrObjIp1'] = item.text
                                return_address[current_address]['addrObjIp2'] = '255.255.255.255'
                                return_address[current_address]['addrObjType'] = '1'
                                try:
                                    return_address[current_address]['IPv4Networks'] = [
                                        ipaddress.IPv4Network(item.text + '/32', strict=False)]
                                except:
                                    pass
                        elif item.tag.lower() == 'ip-range':
                            range_start, range_end = item.text.split('-')
                            return_address[current_address]['addrObjIp1'] = range_start
                            return_address[current_address]['addrObjIp2'] = range_end
                            return_address[current_address]['addrObjType'] = '2'
                            return_address[current_address]['IPv4Networks'] = [
                                ipaddress.IPv4Network(u'255.255.255.254/32')]  ## why 255.255.255.254/32??
                            try:
                                return_address[current_address]['IPv4Networks'] = [ipaddr for ipaddr in
                                                                                   ipaddress.summarize_address_range(
                                                                                       ipaddress.IPv4Address(
                                                                                           range_start),
                                                                                       ipaddress.IPv4Address(
                                                                                           range_end))]
                            except:
                                pass
                        elif item.tag.lower() == 'fqdn':
                            return_address[current_address]['fqdn'] = item.text
                            return_address[current_address]['IPv4Networks'] = [
                                ipaddress.IPv4Network(u'255.255.255.254/32')]
                            return_address[current_address]['addrObjType'] = '89'  ## Set a type not used by sonicwall

                        elif item.tag.lower() == 'description':
                            return_address[current_address]['addrObjIdDisp'] = item.text
                            return_address[current_address]['addrObjIdComment'] = item.text

        return return_address

    def load_address_groups(address_list):

        return_address_group = OrderedDict()
        addr_mappings = OrderedDict()
        for address in address_list:
            current_address = address.get('name')
            return_address_group[current_address] = OrderedDict()
            return_address_group[current_address]['addrObjId'] = current_address
            return_address_group[current_address]['addrObjIdDisp'] = ''
            return_address_group[current_address]['addrObjType'] = '8'
            return_address_group[current_address]['addrObjZone'] = ''
            return_address_group[current_address]['addrObjProperties'] = '14'
            return_address_group[current_address]['addrObjIp1'] = ''
            return_address_group[current_address]['addrObjIp2'] = ''
            return_address_group[current_address]['addrObjComment'] = ''
            return_address_group[current_address]['IPv4Networks'] = []
            addr_mappings[current_address] = []
            if address.find('description') != None:
                return_address_group[current_address]['addrObjIdDisp'] = address.find('description').text
                return_address_group[current_address]['addrObjComment'] = address.find('description').text
            for address_group_member in address.findall('./static/member'):
                addr_mappings[current_address].append(address_group_member.text)
        return return_address_group, addr_mappings

    def load_services(service_list):

        return_service = OrderedDict()
        for service in service_list:
            current_service = service.get('name')
            return_service[current_service] = OrderedDict()
            return_service[current_service]['svcObjId'] = current_service
            return_service[current_service]['svcObjType'] = '1'
            return_service[current_service]['svcObjProperties'] = '14'
            return_service[current_service]['svcObjIpType'] = '1'
            return_service[current_service]['svcObjPort1'] = ''
            return_service[current_service]['svcObjPort2'] = ''
            return_service[current_service]['svcObj'] = '0'
            return_service[current_service]['svcObjManagement'] = ''
            return_service[current_service]['svcObjHigherPrecedence'] = ''
            return_service[current_service][
                'svcObjComment'] = ''  # root.find('./devices/entry/device-group/entry[@name=\''+current_group+'\']/service/entry[@name=\''+current_service+'\']').findtext('description')
            if service.find('description') != None:
                return_service[current_service]['svcObjComment'] = service.find('description').text
            if service.findall('./protocol/tcp'):
                return_service[current_service]['svcObjIpType'] = '6'
                port = service.find('./protocol/tcp').findtext('port')
            elif service.findall('./protocol/udp'):
                return_service[current_service]['svcObjIpType'] = '17'
                port = service.find('./protocol/udp').findtext('port')

            if re.findall(',', port):  ## list of ports
                return_service[current_service]['svcObjPort1'], return_service[current_service]['svcObjPort2'] = (
                None, None)
                return_service[current_service]['svcObjPortSet'] = port.split(',')
                debug('PORTSET: ', current_service, return_service[current_service]['svcObjPortSet'])
                return_service[current_service]['svcObjPort1'] = '0'
                return_service[current_service]['svcObjPort2'] = '0'
                return_service[current_service]['svcObjType'] = '4'
            elif re.findall('-', port):  ## Port range
                return_service[current_service]['svcObjType'] = '1'
                return_service[current_service]['svcObjPort1'], return_service[current_service][
                    'svcObjPort2'] = port.split('-')
            else:  ## Single port
                return_service[current_service]['svcObjType'] = '1'
                return_service[current_service]['svcObjPort1'] = port
                return_service[current_service]['svcObjPort2'] = port
        return return_service

    def load_service_groups(service_list):

        return_service = OrderedDict()
        svc_mappings = OrderedDict()
        for service in service_list:
            current_service = service.get('name')
            return_service[current_service] = OrderedDict()
            return_service[current_service]['svcObjId'] = current_service
            return_service[current_service]['svcObjType'] = '2'
            return_service[current_service]['svcObjProperties'] = '14'
            return_service[current_service]['svcObjIpType'] = '0'
            return_service[current_service]['svcObjPort1'] = ''
            return_service[current_service]['svcObjPort2'] = ''
            return_service[current_service]['svcObjManagement'] = ''
            return_service[current_service]['svcObjHigherPrecedence'] = ''
            return_service[current_service]['svcObjComment'] = ''
            svc_mappings[current_service] = []
            if service.find('description') != None:
                return_service[current_service]['svcObjComment'] = service.find('description').text
            for service_group_member in service.findall('./members/member'):
                svc_mappings[current_service].append(service_group_member.text)
        return return_service, svc_mappings

    def load_policies(policy_list):

        policy_index = 0
        return_policy = OrderedDict()

        for policy in policy_list:

            disabled = policy.find('.').findtext('disabled')
            if disabled:
                disabled = disabled.lower()
            if not (disabled == 'yes' and options.skip_disabled):
                current_policy = policy.get('name')
                return_policy[policy_index] = OrderedDict()
                return_policy[policy_index]['policyName'] = current_policy
                return_policy[policy_index]['policyAction'] = ''
                return_policy[policy_index]['policySrcZone'] = []
                return_policy[policy_index]['policyDstZone'] = []
                return_policy[policy_index]['policySrcNet'] = []
                return_policy[policy_index]['policyDstNet'] = []
                return_policy[policy_index]['policyDstSvc'] = []
                return_policy[policy_index]['policyDstApps'] = []
                return_policy[policy_index]['policyLog'] = ''
                return_policy[policy_index]['policyEnabled'] = '1'
                return_policy[policy_index]['policyProps'] = '0'
                return_policy[policy_index]['policyNum'] = None
                return_policy[policy_index]['policyUiNum'] = None
                return_policy[policy_index]['policySrcNegate'] = False
                return_policy[policy_index]['policyDstNegate'] = False
                return_policy[policy_index]['policySvcNegate'] = False
                return_policy[policy_index]['policyComment'] = policy.find('.').findtext('description')
                if return_policy[policy_index]['policyComment'] == None: return_policy[policy_index][
                    'policyComment'] = ''  # Set Comment to blank if not found
                return_policy[policy_index]['policyLogSetting'] = policy.find('.').findtext('log-setting')
                if return_policy[policy_index]['policyLogSetting'] == None: return_policy[policy_index][
                    'policyLogSetting'] = ''  # Set Log Setting to blank if not found
                return_policy[policy_index]['policyLogStart'] = policy.find('.').findtext('log-start')
                if return_policy[policy_index]['policyLogStart'] == None: return_policy[policy_index][
                    'policyLogStart'] = ''  # Set Log Setting to blank if not found
                return_policy[policy_index]['policyLogEnd'] = policy.find('.').findtext('log-end')
                if return_policy[policy_index]['policyLogEnd'] == None: return_policy[policy_index][
                    'policyLogEnd'] = ''  # Set Log Setting to blank if not found

                disabled = policy.find('.').findtext('disabled')
                action = policy.find('.').findtext('action')
                if disabled == 'yes':
                    return_policy[policy_index]['policyEnabled'] = '0'
                if action.lower() == 'allow':
                    return_policy[policy_index]['policyAction'] = '2'
                elif action == 'deny':
                    return_policy[policy_index]['policyAction'] = '0'
                elif action.lower() == 'drop':
                    return_policy[policy_index]['policyAction'] = '1'
                for member in policy.findall('./to/member'):
                    return_policy[policy_index]['policyDstZone'].append(member.text)
                for member in policy.findall('./from/member'):
                    return_policy[policy_index]['policySrcZone'].append(member.text)
                for member in policy.findall('./source/member'):
                    return_policy[policy_index]['policySrcNet'].append(member.text)
                for member in policy.findall('./destination/member'):
                    return_policy[policy_index]['policyDstNet'].append(member.text)
                for member in policy.findall('./service/member'):
                    return_policy[policy_index]['policyDstSvc'].append(member.text)
                for member in policy.findall('./application/member'):
                    return_policy[policy_index]['policyDstApps'].append(member.text)
                policy_index = policy_index + 1
        return return_policy

    def load_nat(policy_list, interfaces):

        policy_index = 0
        return_nat = OrderedDict()

        for policy in policy_list:
            disabled = policy.find('.').findtext('disabled')
            if disabled:
                disabled = disabled.lower()
            if not (disabled == 'yes' and options.skip_disabled):
                current_policy = policy.get('name')
                return_nat[policy_index] = OrderedDict()
                return_nat[policy_index]['natPolicyName'] = current_policy
                return_nat[policy_index]['natPolicySrcZone'] = []
                return_nat[policy_index]['natPolicyDstZone'] = []
                return_nat[policy_index]['natPolicyOrigSrc'] = []
                return_nat[policy_index]['natPolicyOrigDst'] = []
                return_nat[policy_index]['natPolicyOrigSvc'] = []
                return_nat[policy_index]['natPolicyTransSrc'] = []
                return_nat[policy_index]['natPolicyTransDst'] = []
                return_nat[policy_index]['natPolicyTransSvc'] = []
                return_nat[policy_index]['natPolicySrcIface'] = []
                return_nat[policy_index]['natPolicyDstIface'] = []
                return_nat[policy_index]['natPolicyEnabled'] = '1'
                return_nat[policy_index]['natPolicyProperties'] = '0'
                return_nat[policy_index]['natPolicyComment'] = policy.find('.').findtext('description')
                if return_nat[policy_index]['natPolicyComment'] == None: return_nat[policy_index][
                    'natPolicyComment'] = ''  # Set Comment to blank if not found
                disabled = policy.find('.').findtext('disabled')
                if disabled == 'yes':
                    return_nat[policy_index]['natPolicyEnabled'] = '0'
                for member in policy.findall('./to/member'):
                    return_nat[policy_index]['natPolicyDstZone'].append(member.text)
                for member in policy.findall('./from/member'):
                    return_nat[policy_index]['natPolicySrcZone'].append(member.text)
                for member in policy.findall('./source/member'):
                    return_nat[policy_index]['natPolicyOrigSrc'].append(member.text)
                for member in policy.findall('./destination/member'):
                    return_nat[policy_index]['natPolicyOrigDst'].append(member.text)
                for member in policy.findall('./service/member'):
                    return_nat[policy_index]['natPolicyOrigSvc'].append(member.text)

                #### Need to figure out how to determine translated values based on NAT type set in config
                if policy.find('.').findtext('source-translation'):
                    if policy.find('./source-translation').findtext('dynamic-ip-and-port'):
                        if policy.find('./source-translation/dynamic-ip-and-port').findtext('translated-address'):
                            for member in policy.findall(
                                    './source-translation/dynamic-ip-and-port/translated-address/member'):
                                return_nat[policy_index]['natPolicyTransSrc'].append(member.text)
                        if policy.find('./source-translation/dynamic-ip-and-port').findtext('interface-address'):
                            int_name = policy.find(
                                './source-translation/dynamic-ip-and-port/interface-address').findtext('interface')
                            if int_name in interfaces:
                                return_nat[policy_index]['natPolicyTransSrc'] = [
                                    interfaces[int_name]['iface_static_ip']]
                            else:
                                return_nat[policy_index]['natPolicyTransSrc'] = 'UNKNOWN'
                            if policy.find('./source-translation/dynamic-ip-and-port/interface-address').findtext('ip'):
                                return_nat[policy_index]['natPolicyTransSrc'] = [
                                    policy.find('./source-translation/dynamic-ip-and-port/interface-address/ip').text]
                    if policy.find('./source-translation').findtext('dynamic-ip'):
                        if policy.find('./source-translation/dynamic-ip').findtext('translated-address'):
                            for member in policy.findall('./source-translation/dynamic-ip/translated-address/member'):
                                return_nat[policy_index]['natPolicyTransSrc'].append(member.text)
                            if policy.find('./source-translation/dynamic-ip').findtext('fallback'):
                                log('WARNING: FALLBACK settings not supoprted in source-translation dynamic-ip ')
                    if policy.find('./source-translation').findtext('static-ip'):
                        if policy.find('./source-translation/static-ip').findtext('translated-address'):
                            return_nat[policy_index]['natPolicyTransSrc'] = [
                                policy.find('./source-translation/static-ip/translated-address').text]
                if policy.find('.').findtext('destination-translation'):
                    if policy.find('./destination-translation').findtext('translated-address'):
                        return_nat[policy_index]['natPolicyTransDst'] = [
                            policy.find('./destination-translation/translated-address').text]
                    if policy.find('./destination-translation').findtext('translated-port'):
                        return_nat[policy_index]['natPolicyTransSvc'] = [
                            policy.find('./destination-translation/translated-port').text]
                if policy.find('.').findtext('dynamic-destination-translation'):
                    log('dynamic-destination-translation set')
                    if policy.find('./dynamic-destination-translation').findtext('translated-address'):
                        return_nat[policy_index]['natPolicyTransDst'] = [
                            policy.find('./dynamic-destination-translation/translated-address').text]
                    if policy.find('./dynamic-destination-translation').findtext('translated-port'):
                        return_nat[policy_index]['natPolicyTransSvc'] = [
                            policy.find('./dynamic-destination-translation/translated-port').text]

                policy_index = policy_index + 1
        return return_nat

    def load_zones(zone_list):

        return_zones = OrderedDict()
        # if root.find(zone_base)!=None:
        # zone_props = ['zoneObjId', 'zoneObjComment']

        for zone in zone_list:
            zone_name = zone.get('name')
            return_zones[zone_name] = OrderedDict()
            return_zones[zone_name]['zoneObjId'] = zone_name
            return_zones[zone_name]['zoneObjComment'] = 'Zone Comment'
            return_zones[zone_name]['zoneObjMembers'] = []
            # print(zone.get('name'))
            for interface in zone.findall('.//member'):
                # print(interface.text)
                return_zones[zone_name]['zoneObjMembers'].append(interface.text)

        return return_zones

    def load_variables(variable_list):

        variables = {}
        for variable in variable_list:
            if variable:
                variables[variable.get('name')] = variable.find('.//ip-netmask').text
            # debug('variable_name', variable.get('name'))
            # debug('variable_def', variable.find('.//ip-netmask').text)
        return variables

    def load_interface(interface_base):

        return_interface = OrderedDict()

        index = 0
        # print(root.findall(interface_base))
        if root.find(interface_base) != None:
            for interface_type in root.find(interface_base):
                for interface_names in root.findall(interface_base + '/' + interface_type.tag + '/entry'):
                    interface_name = interface_names.get('name')
                    return_interface[interface_name] = OrderedDict()
                    return_interface[interface_name]['iface_ifnum'] = str(index)
                    return_interface[interface_name]['iface_type'] = interface_type.tag
                    return_interface[interface_name]['iface_name'] = interface_name
                    return_interface[interface_name]['interface_Zone'] = ''  # this would get set when reading zones
                    return_interface[interface_name]['iface_comment'] = ''
                    return_interface[interface_name]['iface_static_ip'] = ''
                    return_interface[interface_name]['iface_static_mask'] = ''
                    return_interface[interface_name]['iface_static_gateway'] = ''
                    return_interface[interface_name]['iface_lan_ip'] = ''
                    return_interface[interface_name]['iface_lan_mask'] = ''
                    return_interface[interface_name]['iface_lan_default_gw'] = ''
                    return_interface[interface_name]['iface_mgmt_ip'] = ''
                    return_interface[interface_name]['iface_mgmt_netmask'] = ''
                    return_interface[interface_name]['iface_mgmt_default_gw'] = ''
                    return_interface[interface_name]['iface_vlan_tag'] = ''
                    return_interface[interface_name]['portShutdown'] = ''
                    index += 1
                    comment = root.find(
                        interface_base + '/' + interface_type.tag + '/entry[@name="' + interface_name + '"]/comment')
                    if comment != None: return_interface[interface_name]['iface_comment'] = comment.text
                    for interface in root.findall(
                            interface_base + '/' + interface_type.tag + '/entry[@name="' + interface_name + '"]'):
                        for interface_attribs in interface:
                            if interface_type.tag in ['ethernet',
                                                      'aggregate-ethernet'] and interface_attribs.tag.lower() == 'layer3':
                                ip = root.find(
                                    interface_base + '/' + interface_type.tag + '/entry[@name="' + interface_name + '"]/' + interface_attribs.tag + '/ip/entry[@name]')
                                if ip != None:
                                    if ip.get('name') in return_variables:
                                        ipname = return_variables[ip.get('name')]
                                    else:
                                        ipname = ip.get('name')
                                    if re.findall('/', ipname):
                                        return_interface[interface_name]['iface_static_ip'], \
                                        return_interface[interface_name]['iface_static_mask'] = ipname.split('/')
                                        return_interface[interface_name]['iface_static_mask'] = cidr_to_netmask(
                                            return_interface[interface_name]['iface_static_mask'])
                                    else:
                                        return_interface[interface_name]['iface_static_ip'], \
                                        return_interface[interface_name]['iface_static_mask'] = '0.0.0.0', '0'
                                if interface_type.tag == 'aggregate-ethernet':  # get ip addresses for sub-interfaces
                                    for sub_interfaces in root.findall(
                                            interface_base + '/' + interface_type.tag + '/entry[@name="' + interface_name + '"]/layer3/units/entry[@name]'):
                                        sub_interface = sub_interfaces.get('name')
                                        return_interface[sub_interface] = OrderedDict()
                                        return_interface[sub_interface]['iface_ifnum'] = str(index)
                                        return_interface[sub_interface]['iface_type'] = interface_type.tag
                                        return_interface[sub_interface]['iface_name'] = sub_interface
                                        return_interface[sub_interface][
                                            'interface_Zone'] = ''  # this would get set when reading zones
                                        return_interface[sub_interface]['iface_comment'] = ''
                                        return_interface[sub_interface]['iface_static_ip'] = ''
                                        return_interface[sub_interface]['iface_static_mask'] = ''
                                        return_interface[sub_interface]['iface_static_gateway'] = ''
                                        return_interface[sub_interface]['iface_lan_ip'] = ''
                                        return_interface[sub_interface]['iface_lan_mask'] = ''
                                        return_interface[sub_interface]['iface_lan_default_gw'] = ''
                                        return_interface[sub_interface]['iface_mgmt_ip'] = ''
                                        return_interface[sub_interface]['iface_mgmt_netmask'] = ''
                                        return_interface[sub_interface]['iface_mgmt_default_gw'] = ''
                                        return_interface[sub_interface]['iface_vlan_tag'] = ''
                                        return_interface[sub_interface]['portShutdown'] = ''
                                        index += 1
                                        ip = root.find(
                                            interface_base + '/' + interface_type.tag + '/entry[@name="' + interface_name + '"]/' + interface_attribs.tag + '/units/entry[@name="' + sub_interface + '"]/ip/entry[@name]')
                                        tag = root.find(
                                            interface_base + '/' + interface_type.tag + '/entry[@name="' + interface_name + '"]/' + interface_attribs.tag + '/units/entry[@name="' + sub_interface + '"]/tag')
                                        comment = root.find(
                                            interface_base + '/' + interface_type.tag + '/entry[@name="' + interface_name + '"]/' + interface_attribs.tag + '/units/entry[@name="' + sub_interface + '"]/comment')
                                        if ip != None:
                                            if ip.get('name') in return_variables:
                                                ipname = return_variables[ip.get('name')]
                                            else:
                                                ipname = ip.get('name')
                                            if re.findall('/', ipname):
                                                return_interface[sub_interface]['iface_static_ip'], \
                                                return_interface[sub_interface]['iface_static_mask'] = ipname.split('/')
                                                return_interface[sub_interface]['iface_static_mask'] = cidr_to_netmask(
                                                    return_interface[sub_interface]['iface_static_mask'])
                                            else:
                                                return_interface[sub_interface]['iface_static_ip'], \
                                                return_interface[sub_interface]['iface_static_mask'] = '0.0.0.0', '0'
                                        if tag != None: return_interface[sub_interface]['iface_vlan_tag'] = tag.text
                                        if comment != None: return_interface[sub_interface][
                                            'iface_comment'] = comment.text

        return return_interface

    def load_interface2(interface_base):

        return_interface = OrderedDict()

        index = 0
        if root.findall(interface_base) != None:
            for interface_type in root.find(interface_base):
                print(interface_type)
                for interface_names in root.findall(interface_base + '/' + interface_type.tag + '/entry'):
                    interface_name = interface_names.get('name')
                    print(interface_name)
                    return_interface[interface_name] = OrderedDict()
                    return_interface[interface_name]['iface_ifnum'] = str(index)
                    return_interface[interface_name]['iface_type'] = interface_type.tag
                    return_interface[interface_name]['iface_name'] = interface_name
                    return_interface[interface_name]['interface_Zone'] = ''  # this would get set when reading zones
                    return_interface[interface_name]['iface_comment'] = ''
                    return_interface[interface_name]['iface_static_ip'] = ''
                    return_interface[interface_name]['iface_static_mask'] = ''
                    return_interface[interface_name]['iface_static_gateway'] = ''
                    return_interface[interface_name]['iface_lan_ip'] = ''
                    return_interface[interface_name]['iface_lan_mask'] = ''
                    return_interface[interface_name]['iface_lan_default_gw'] = ''
                    return_interface[interface_name]['iface_mgmt_ip'] = ''
                    return_interface[interface_name]['iface_mgmt_netmask'] = ''
                    return_interface[interface_name]['iface_mgmt_default_gw'] = ''
                    return_interface[interface_name]['iface_vlan_tag'] = ''
                    return_interface[interface_name]['portShutdown'] = ''
                    index += 1
                    comment = root.find(
                        interface_base + '/' + interface_type.tag + '/entry[@name="' + interface_name + '"]/comment')
                    if comment != None: return_interface[interface_name]['iface_comment'] = comment.text
                    for interface in root.findall(
                            interface_base + '/' + interface_type.tag + '/entry[@name="' + interface_name + '"]'):
                        for interface_attribs in interface:
                            if interface_type.tag in ['ethernet',
                                                      'aggregate-ethernet'] and interface_attribs.tag == 'layer3':
                                ip = root.find(
                                    interface_base + '/' + interface_type.tag + '/entry[@name="' + interface_name + '"]/' + interface_attribs.tag + '/ip/entry[@name]')
                                if ip != None:
                                    if re.findall('/', ip.get('name')):
                                        return_interface[interface_name]['iface_static_ip'], \
                                        return_interface[interface_name]['iface_static_mask'] = ip.get('name').split(
                                            '/')
                                    else:
                                        return_interface[sub_interface]['iface_static_ip'], \
                                        return_interface[sub_interface]['iface_static_mask'] = '0.0.0.0', '0'
                                if interface_type.tag == 'aggregate-ethernet':  # get ip addresses for sub-interfaces
                                    for sub_interfaces in root.findall(
                                            interface_base + '/' + interface_type.tag + '/entry[@name="' + interface_name + '"]/layer3/units/entry[@name]'):
                                        sub_interface = sub_interfaces.get('name')
                                        return_interface[sub_interface] = OrderedDict()
                                        return_interface[sub_interface]['iface_ifnum'] = str(index)
                                        return_interface[sub_interface]['iface_type'] = interface_type.tag
                                        return_interface[sub_interface]['iface_name'] = sub_interface
                                        return_interface[sub_interface][
                                            'interface_Zone'] = ''  # this would get set when reading zones
                                        return_interface[sub_interface]['iface_comment'] = ''
                                        return_interface[sub_interface]['iface_static_ip'] = ''
                                        return_interface[sub_interface]['iface_static_mask'] = ''
                                        return_interface[sub_interface]['iface_static_gateway'] = ''
                                        return_interface[sub_interface]['iface_lan_ip'] = ''
                                        return_interface[sub_interface]['iface_lan_mask'] = ''
                                        return_interface[sub_interface]['iface_lan_default_gw'] = ''
                                        return_interface[sub_interface]['iface_mgmt_ip'] = ''
                                        return_interface[sub_interface]['iface_mgmt_netmask'] = ''
                                        return_interface[sub_interface]['iface_mgmt_default_gw'] = ''
                                        return_interface[sub_interface]['iface_vlan_tag'] = ''
                                        return_interface[sub_interface]['portShutdown'] = ''
                                        index += 1
                                        ip = root.find(
                                            interface_base + '/' + interface_type.tag + '/entry[@name="' + interface_name + '"]/' + interface_attribs.tag + '/units/entry[@name="' + sub_interface + '"]/ip/entry[@name]')
                                        tag = root.find(
                                            interface_base + '/' + interface_type.tag + '/entry[@name="' + interface_name + '"]/' + interface_attribs.tag + '/units/entry[@name="' + sub_interface + '"]/tag')
                                        comment = root.find(
                                            interface_base + '/' + interface_type.tag + '/entry[@name="' + interface_name + '"]/' + interface_attribs.tag + '/units/entry[@name="' + sub_interface + '"]/comment')
                                        if ip != None:
                                            if ip.get('name') in return_addresses:
                                                return_interface[sub_interface]['iface_static_ip'], \
                                                return_interface[sub_interface]['iface_static_mask'] = \
                                                return_address[ip.get('name')]['addrObjIp1'], \
                                                return_address[ip.get('name')]['addrObjIp2']
                                            else:
                                                if re.findall('/', ip.get('name')):
                                                    return_interface[sub_interface]['iface_static_ip'], \
                                                    return_interface[sub_interface]['iface_static_mask'] = ip.get(
                                                        'name').split('/')
                                                else:
                                                    return_interface[sub_interface]['iface_static_ip'], \
                                                    return_interface[sub_interface][
                                                        'iface_static_mask'] = '0.0.0.0', '0'
                                        if tag != None: return_interface[sub_interface]['iface_vlan_tag'] = tag.text
                                        if comment != None: return_interface[sub_interface][
                                            'iface_comment'] = comment.text
        else:
            print('no interfaces found')
            print('')

        return return_interface

    def load_vrouters(vrouter_base):

        return_vrouter = OrderedDict()

        if root.find(vrouter_base) != None:
            for vrouter in root.find(vrouter_base):
                vrouter_name = vrouter.get('name')
                return_vrouter[vrouter_name] = OrderedDict()
                if root.find(vrouter_base + '/entry[@name="' + vrouter_name + '"]/routing-table/ip/static-route'):
                    for static_routes in root.find(
                            vrouter_base + '/entry[@name="' + vrouter_name + '"]/routing-table/ip/static-route'):
                        static_name = static_routes.get('name')
                        return_vrouter[vrouter_name][static_name] = OrderedDict()
                        # return_vrouter[vrouter_name][static_name]['nexthop']=''
                        return_vrouter[vrouter_name][static_name]['destination'] = ''
                        return_vrouter[vrouter_name][static_name]['metric'] = ''
                        return_vrouter[vrouter_name][static_name]['bfd'] = ''

                        for vrouter_attribs in root.find(
                                vrouter_base + '/entry[@name="' + vrouter_name + '"]/routing-table/ip/static-route/entry[@name="' + static_name + '"]'):
                            # debug(vrouter_attribs.tag)
                            if vrouter_attribs.tag.lower() == 'nexthop':
                                return_vrouter[vrouter_name][static_name]['nexthops'] = []
                                for nexthop in root.find(
                                        vrouter_base + '/entry[@name="' + vrouter_name + '"]/routing-table/ip/static-route/entry[@name="' + static_name + '"]/nexthop'):
                                    return_vrouter[vrouter_name][static_name]['nexthops'].append(nexthop.text)
                            elif vrouter_attribs.tag.lower() == 'destination':
                                return_vrouter[vrouter_name][static_name]['destination'] = vrouter_attribs.text
                            elif vrouter_attribs.tag.lower() == 'bfd':
                                return_vrouter[vrouter_name][static_name]['bfd'] = vrouter_attribs.text
                            elif vrouter_attribs.tag.lower() == 'metric':
                                return_vrouter[vrouter_name][static_name]['metric'] = vrouter_attribs.text

        return return_vrouter

    import xml.etree.ElementTree as et
    import ipaddress
    from collections import OrderedDict
    import ipaddress
    import re
    from netaddr import IPSet

    return_config = OrderedDict()

    addr_mappings = OrderedDict()
    svc_mappings = OrderedDict()

    if memoryconfig:
        root = et.fromstring(memoryconfig)
        # exit(1)
    else:
        panorama = et.parse(infile)
        root = panorama.getroot()

    if root.findall('./mgt-config/devices') != []:
        pan_config = True
        log('!-- Loading Panorama XML file')
    else:
        pan_config = False
        log('!-- Loading Palo Alto XML file')

    if pan_config == True:  # loop through all device groups for Panorama
        for templates in root.findall('./devices/entry/template/entry'):

            template = templates.get('name')

            return_config[template] = OrderedDict()
            log('!-- Reading Template : ' + template)

            ##      LOAD VARIABLES FROM XML
            log('  |-- Variable Objects             ', end='')
            variable_list = root.findall(
                './devices/entry[@name="localhost.localdomain"]/template/entry[@name=\'' + template + '\']/variable/entry')
            if variable_list:
                return_variables = load_variables(variable_list)

            ##      LOAD VROUTERS FROM XML
            log('  |-- Loading VRouters', end='')
            return_vrouters = load_vrouters(
                './devices/entry[@name="localhost.localdomain"]/template/entry[@name="' + template + '"]/config/devices/entry[@name="localhost.localdomain"]/network/virtual-router')
            # log(return_vrouters)

            ##      LOAD INTERFACES FROM XML
            log('  |-- Interface Objects             ', end='')
            return_interface = load_interface(
                './devices/entry[@name="localhost.localdomain"]/template/entry[@name=\'' + template + '\']/config/devices/entry[@name=\'localhost.localdomain\']/network/interface')
            # debug(root.findall('./devices/entry[@name="localhost.localdomain"]/template/entry[@name="' + current_group +  '"]/config/devices/entry[@name="localhost.localdomain"]/network/interface'))
            # log(return_interface)

            ##      LOAD ZONES FROM XML
            log('  |-- Zone Objects             ', end='')
            zone_list = root.findall(
                './devices/entry[@name="localhost.localdomain"]/template/entry[@name=\'' + template + '\']/config/devices/entry[@name=\'localhost.localdomain\']/vsys/entry[@name=\'vsys1\']/zone/entry')
            return_zones = load_zones(zone_list)

            ##      ASSIGN ZONES TO INTERFACES
            log('!-- Assigning Zones')
            if return_zones:
                for zone in return_zones:
                    # print('Zone: ', zone)
                    for zone_member in return_zones[zone]['zoneObjMembers']:
                        for interface in return_interface:
                            # log('return interface: ', interface)
                            if return_interface[interface]['iface_name'] == zone_member:
                                return_interface[interface]['interface_Zone'] = zone

            return_config[template]['config'] = defaultdict()
            return_config[template]['config']['name'] = template
            return_config[template]['config']['fw_type'] = 'panorama'
            return_config[template]['config']['version'] = ''
            if options.panoramaip:
                return_config[template]['config']['mgmtip'] = options.panoramaip
            else:
                return_config[template]['config']['mgmtip'] = None
            return_config[template]['interfaces'] = return_interface
            return_config[template]['zones'] = return_zones
            return_config[template]['vrouters'] = return_vrouters
            return_config[template]['addresses'] = {}

        for device_groups in root.findall('./devices/entry/device-group/entry'):

            return_addresses = OrderedDict()
            return_service = OrderedDict()
            return_policy = OrderedDict()
            return_nat = OrderedDict()

            current_group = device_groups.get('name')
            return_addresses = OrderedDict()

            addr_mappings = OrderedDict()
            svc_mappings = OrderedDict()

            log('!-- Reading Device-Group : ' + current_group)

            logprofiles = []
            for logs in root.findall(
                    './devices/entry/device-group/entry[@name=\'' + current_group + '\']/log-settings/profiles/entry'):
                logprofiles.append(logs.get('name'))

            ##      LOAD ADDRESSES FROM XML
            log('  |-- Address Objects        \r', end=' ')
            address_list = root.findall(
                './devices/entry/device-group/entry[@name=\'' + current_group + '\']/address/entry')
            return_addresses = load_addresses(address_list)

            ##      LOAD ADDRESS GROUPS FROM XML
            log('  |-- Address-Group Objects  \r', end=' ')
            address_list = root.findall(
                './devices/entry/device-group/entry[@name=\'' + current_group + '\']/address-group/entry')
            tmp_addresses = OrderedDict()
            if address_list != []:
                tmp_addresses, addr_mappings = load_address_groups(address_list)
            return_addresses.update(tmp_addresses)

            ##      LOAD SERVICES FROM XML
            log('  |-- Service Objects        \r', end=' ')
            service_list = root.findall(
                './devices/entry/device-group/entry[@name=\'' + current_group + '\']/service/entry')
            return_service = load_services(service_list)

            ##      LOAD SERVICES GROUPS FROM XML
            log('  |-- Service Group Objects  \r', end=' ')
            service_list = root.findall(
                './devices/entry/device-group/entry[@name=\'' + current_group + '\']/service-group/entry')
            tmp_services = OrderedDict()
            if service_list != []:
                tmp_services, svc_mappings = load_service_groups(service_list)
            return_service.update(tmp_services)

            ##      LOAD POLICIES FROM XML
            log('  |-- Policy Objects         \r', end='')
            policy_list = root.findall(
                './devices/entry/device-group/entry[@name=\'' + current_group + '\']/pre-rulebase/security/rules/entry')
            return_policy = load_policies(policy_list)

            ##      LOAD NAT POLICIES FROM XML
            log('  |-- NAT Objects             \r', end='')
            policy_list = root.findall(
                './devices/entry/device-group/entry[@name=\'' + current_group + '\']/rulebase/nat/rules/entry')
            return_nat = load_nat(policy_list, return_interface)

            ## Assign loaded values to return variables

            if current_group not in return_config:
                return_config[current_group] = OrderedDict()
            return_config[current_group]['config'] = defaultdict()
            return_config[current_group]['config']['name'] = current_group
            return_config[current_group]['config']['fw_type'] = 'panorama'
            return_config[current_group]['config']['version'] = ''
            if options.panoramaip:
                return_config[current_group]['config']['mgmtip'] = options.panoramaip
            else:
                return_config[current_group]['config']['mgmtip'] = None

            return_config[current_group]['addresses'] = return_addresses
            return_config[current_group]['services'] = return_service
            return_config[current_group]['policies'] = return_policy
            return_config[current_group]['nat'] = return_nat
            return_config[current_group]['apps'] = {}
            return_config[current_group]['addressmappings'] = addr_mappings
            return_config[current_group]['servicemappings'] = svc_mappings

            ## Placeholder keys for future use
            return_config[current_group]['zones'] = {}

            return_config[current_group]['routing'] = OrderedDict()
            return_config[current_group]['logprofiles'] = logprofiles

        ## READ SHARED OBJECTS (panorama only)

        ## Re-initialize variables used above

        return_addresses = OrderedDict()
        return_service = OrderedDict()
        return_policy = OrderedDict()
        addr_mappings = OrderedDict()

        log('!-- Reading Shared Objects : ')
        log('  |-- Address Objects  \r', end=' ')

        logprofiles = []

        for logs in root.findall('./shared/log-settings/profiles/entry'):
            logprofiles.append(logs.get('name'))

        ##  READ SHARED ADDRESS OBJECTS
        address_list = root.findall('./shared/address/entry')
        return_addresses = load_addresses(address_list)

        ##  LOAD SHARED ADDRESS GROUPS FROM XML
        log('  |-- Address-Group Objects  \r', end=' ')
        addr_mappings = OrderedDict()
        address_list = root.findall('./shared/address-group/entry')
        tmp_addresses = OrderedDict()

        if address_list != []:
            tmp_addresses, addr_mappings = load_address_groups(address_list)
        return_addresses.update(tmp_addresses)

        ##  LOAD SHARED SERVICE FROM XML
        log('  |-- Service Objects        \r', end=' ')
        service_list = root.findall('./shared/service/entry')
        return_service = load_services(service_list)

        ##  LOAD SHARED SERVICE GROUPS FROM XML
        log('  |-- Service Group Objects  \r', end=' ')
        svc_mappings = OrderedDict()
        service_list = root.findall('./shared/service-group/entry')
        tmp_services = OrderedDict()

        if service_list != []:
            tmp_services, svc_mappings = load_service_groups(service_list)
        return_service.update(tmp_services)

        return_config['shared'] = OrderedDict()
        return_config['shared']['config'] = defaultdict()
        return_config['shared']['config']['name'] = 'shared'
        return_config['shared']['config']['fw_type'] = 'panorama'
        return_config['shared']['config']['version'] = ''
        if options.panoramaip:
            return_config['shared']['config']['mgmtip'] = options.panoramaip
        else:
            return_config['shared']['config']['mgmtip'] = None
        # debug('return_addresses')
        return_config['shared']['addresses'] = return_addresses
        return_config['shared']['services'] = return_service
        return_config['shared']['policies'] = OrderedDict()  # return_policy
        return_config['shared']['nat'] = OrderedDict()
        return_config['shared']['apps'] = {}
        return_config['shared']['addressmappings'] = addr_mappings
        return_config['shared']['servicemappings'] = svc_mappings
        return_config['shared']['logprofiles'] = logprofiles  # move this to 'config'
        return_config['shared']['vrouters'] = {}

        ## This is a search for "temp" objects - these are IP addresses directly input into policies without referencing an address object
        '''    
        for c in return_config: # context
            for p in return_config[c]['policies']: # policy 
                for s in return_config[c]['policies'][p]['policySrcNet']:
                    if s not in return_config[c]['addresses'] and s not in return_config['shared']['addresses'] and s.lower()!='any':
                        debug(c + ':' + return_config[c]['policies'][p]['policyName'] + ':' + s + ' not found')    
                for d in return_config[c]['policies'][p]['policyDstNet']:
                    if d not in return_config[c]['addresses'] and d not in return_config['shared']['addresses'] and d.lower()!='any':
                        debug(c + ':' + return_config[c]['policies'][p]['policyName'] + ':' + d + ' not found')  
        '''

        return return_config


    else:  # load Palo Alto Config
        return_addresses = OrderedDict()
        return_service = OrderedDict()
        return_policy = OrderedDict()
        return_interface = OrderedDict()
        return_variables = []

        current_group = 'paloalto'
        return_addresses = OrderedDict()

        addr_mappings = OrderedDict()
        svc_mappings = OrderedDict()

        log('!-- Reading Device-Group : ' + current_group)
        logprofiles = []
        for logs in root.findall('./shared/log-settings/profiles/entry'):
            # log(logs.get('name'))
            logprofiles.append(logs.get('name'))

        ## interfaces
        interface_list = root.findall('./devices/entry[@name="localhost.localdomain"]/network/interface/ethernet')
        ##      LOAD VROUTERS FROM XML
        log('  |-- Loading VRouters\r', end='')
        return_vrouters = load_vrouters('./devices/entry[@name="localhost.localdomain"]/network/virtual-router')

        ##      LOAD ADDRESSES FROM XML
        log('  |-- Address Objects        \r', end=' ')
        address_list = root.findall(
            './devices/entry[@name="localhost.localdomain"]/vsys/entry[@name="vsys1"]/address/entry')
        return_addresses = load_addresses(address_list)
        # print(return_addresses)

        ##      LOAD ADDRESS GROUPS FROM XML
        log('  |-- Address-Group Objects  \r', end=' ')
        address_list = root.findall(
            './devices/entry[@name="localhost.localdomain"]/vsys/entry[@name="vsys1"]/address-group/entry')
        tmp_addresses = OrderedDict()
        if address_list != []:
            tmp_addresses, addr_mappings = load_address_groups(address_list)
        return_addresses.update(tmp_addresses)

        ##      LOAD INTERFACE OBJECTS FROM XML
        log('  |-- Interface Objects             \r', end='')
        return_interface = load_interface('./devices/entry[@name="localhost.localdomain"]/network/interface')
        # log(return_interface)

        ##      LOAD ZONES FROM XML
        log('  |-- Zone Objects             \r', end='')
        zone_list = root.findall(
            './devices/entry[@name="localhost.localdomain"]/vsys/entry[@name=\'vsys1\']/zone/entry')
        return_zones = load_zones(zone_list)

        ##      ASSIGN ZONES TO INTERFACES
        log('!-- Assigning Zones')
        if return_zones:
            for zone in return_zones:
                # print('Zone: ', zone)
                for zone_member in return_zones[zone]['zoneObjMembers']:
                    for interface in return_interface:
                        # log('return interface: ', interface)
                        if return_interface[interface]['iface_name'] == zone_member:
                            return_interface[interface]['interface_Zone'] = zone

        ##      LOAD SERVICES FROM XML
        log('  |-- Service Objects        \r', end=' ')
        service_list = root.findall(
            './devices/entry[@name="localhost.localdomain"]/vsys/entry[@name="vsys1"]/service/entry')
        return_service = load_services(service_list)

        ##      LOAD SERVICES GROUPS FROM XML
        log('  |-- Service Group Objects  \r', end=' ')
        service_list = root.findall(
            './devices/entry[@name="localhost.localdomain"]/vsys/entry[@name="vsys1"]/service-group/entry')
        tmp_services = OrderedDict()
        if service_list != []:
            tmp_services, svc_mappings = load_service_groups(service_list)
        return_service.update(tmp_services)

        ##      LOAD POLICIES FROM XML
        log('  |-- Policy Objects         \r', end='')
        policy_list = root.findall(
            './devices/entry[@name="localhost.localdomain"]/vsys/entry[@name="vsys1"]/rulebase/security/rules/entry')
        return_policy = load_policies(policy_list)

        ##      LOAD NAT POLICIES FROM XML
        log('  |-- NAT Objects             \r', end='')
        policy_list = root.findall(
            './devices/entry[@name="localhost.localdomain"]/vsys/entry[@name="vsys1"]/rulebase/nat/rules/entry')
        return_nat = load_nat(policy_list, return_interface)

        ## Assign loaded values to return variables

        return_config[current_group] = OrderedDict()
        return_config[current_group]['config'] = defaultdict()
        return_config[current_group]['config']['name'] = 'paloalto'  # get name of actual firewall from config
        return_config[current_group]['config']['fw_type'] = 'paloalto'
        return_config[current_group]['config']['version'] = ''
        if options.panoramaip:
            return_config[current_group]['config']['mgmtip'] = options.panoramaip
        else:
            return_config[current_group]['config']['mgmtip'] = None
        return_config[current_group]['addresses'] = return_addresses
        return_config[current_group]['services'] = return_service
        return_config[current_group]['policies'] = return_policy
        return_config[current_group]['nat'] = return_nat
        return_config[current_group]['apps'] = {}
        return_config[current_group]['addressmappings'] = addr_mappings
        return_config[current_group]['servicemappings'] = svc_mappings

        ## Placeholder keys for future use
        return_config[current_group]['zones'] = return_zones
        return_config[current_group]['interfaces'] = return_interface
        return_config[current_group]['vrouters'] = return_vrouters
        return_config[current_group]['routing'] = OrderedDict()
        return_config[current_group]['logprofiles'] = logprofiles

        return_config['shared'] = OrderedDict()  # set shared to empty
        return_config['shared']['config'] = defaultdict()
        return_config['shared']['config']['name'] = 'shared'
        return_config['shared']['config']['fw_type'] = 'paloalto'
        return_config['shared']['config']['version'] = ''
        return_config['shared']['config']['mgmtip'] = 'None'
        return_config['shared']['addresses'] = OrderedDict()
        return_config['shared']['services'] = OrderedDict()
        return_config['shared']['policies'] = OrderedDict()  # return_policy
        return_config['shared']['nat'] = OrderedDict()
        return_config['shared']['apps'] = OrderedDict()
        return_config['shared']['addressmappings'] = OrderedDict()
        return_config['shared']['servicemappings'] = OrderedDict()
        return_config['shared']['logprofiles'] = OrderedDict()

        return return_config


def load_interface_mappings(mapfile):
    from collections import defaultdict, OrderedDict
    import os

    mappings = OrderedDict()

    for mapping in mapfile:
        if len(os.path.basename(mapping)) > 0:
            if os.path.basename(mapping[0]) == '@':
                for line in file_to_list(mapping[1:]):
                    sw, pa = line.strip('\n').split(',')
                    mappings[sw] = pa
            else:
                sw, pa = mapping.strip('\n').split(',')
                mappings[sw] = pa

    return mappings


def load_devicegroups(infile):
    import xml.etree.ElementTree as et

    panorama = et.parse(infile)
    root = panorama.getroot()
    devicegroups = ['shared']
    for dg in root.findall('./devices/entry/device-group/entry'):
        devicegroups.append(dg.get('name'))

    return devicegroups;


def show_devicegroups(infile):
    devicegroups = load_devicegroups(infile)
    for dg in devicegroups:
        log(dg)


def load_templates(infile):
    import xml.etree.ElementTree as et

    panorama = et.parse(infile)
    root = panorama.getroot()
    templates = ['shared']
    for t in root.findall('./devices/entry/template/entry'):
        templates.append(t.get('name'))

    return templates;


def show_templates(infile):
    templates = load_templates(infile)
    for t in templates:
        log(t)


def get_creds():
    import getpass

    username = input("  Username : ")
    password = getpass.getpass("  Password : ")

    return username, password;


def search_address(search_addresses, contexts):
    ## (DONE) - Do this for specified contexts
    ## (DONE) - Now just returns a list for post-processing outside this routine -- Output for this should be better.  Perhaps printing a tree, or at least if each object is an address or group
    ## (FIXED) Return results for ranges and groups not correct

    return_list = []
    for address in search_addresses:
        for context in contexts:
            if 'addressmappings' in config[context]:
                addresses = expand_address(config[context]['addresses'], address, config[context]['addressmappings'],
                                           False)
                if addresses:
                    for item in addresses:
                        if item in config[context]['addresses']:
                            addr_obj = config[context]['addresses'][item]
                        elif item in config['shared']['addresses']:
                            addr_obj = config['shared']['addresses'][item]
                        if item in config[context]['addresses'] or item in config['shared']['addresses']:
                            if addr_obj['addrObjType'] == '1':
                                addrmask = 32
                                return_list.append(
                                    (context, address, item, str(addr_obj['addrObjIp1']) + '/' + str(addrmask)))
                            elif addr_obj['addrObjType'] == '2':
                                return_list.append((context, address, item,
                                                    str(addr_obj['addrObjIp1']) + '-' + str(addr_obj['addrObjIp2'])))
                            elif addr_obj['addrObjType'] == '8':
                                return_list.append((context, address, item, 'GROUP'))
                            elif addr_obj['addrObjType'] == '4':
                                addrmask = netmask_to_cidr(addr_obj['addrObjIp2'])
                                return_list.append(
                                    (context, address, item, str(addr_obj['addrObjIp1']) + '/' + str(addrmask)))
                            else:
                                # addrmask=netmask_to_cidr(addr_obj['addrObjIp2'])
                                # return_list.append((item,str(addr_obj['addrObjIp1']) + '/' + str(addrmask)))
                                return_list.append((context, address, item, addr_obj['addrObjType']))
    return return_list;


def search_ip(search_ips, contexts):
    import re
    import ipaddress
    from netaddr import IPSet, IPRange

    ## (DONE) - Do this for specified contexts
    ## (DONE) - Now just returns a list for post-processing outside this routine -- Output for this should be better.  Perhaps printing a tree, or at least if each object is an address or group
    ## (FIXED) Return results for ranges and groups not correct

    return_list = []
    ip_to_find = IPSet([])

    for ip in search_ips:
        log(ip)
        if len(re.findall('/', ip)) == 1:
            # network, netmask = ip.split('/')
            ip_to_find.add('{}'.format(ip))
            ipv4_to_find = ipaddress.IPv4Network(ip)
        elif len(re.findall('/', ip)) == 0:
            # network=ip
            # netmask='32'
            ip_to_find.add('{}/{}'.format(ip, '32'))
            ipv4_to_find = ipaddress.IPv4Network('{}/{}'.format(ip, '32'))
        else:
            pass
            # invalid address format

        # ipv4_to_find=ipaddress.IPv4Network(ip_to_find)
        for context in contexts:
            # log(config[context]['addresses'][1])
            log(context)
            if 'addressmappings' in config[context]:
                # addresses = expand_address(config[context]['addresses'], ip, config[context]['addressmappings'], False)
                for address in config[context]['addresses']:
                    # log(address)
                    for address_member in expand_address(config[context]['addresses'], address,
                                                         config[context]['addressmappings'], False):
                        address_ipset = IPSet([])

                        # if 'IPv4Networks' in config[context]['addresses'][address_member]:
                        if ipv4_to_find in config[context]['addresses'][address_member]['IPv4Networks']:
                            return_list.append((context, address_member, address, ip))

                        elif 'IPSet' in config[context]['addresses'][address_member]:
                            if ip_to_find & config[context]['addresses'][address_member]['IPSet']:
                                return_list.append((context, address_member, address, ip))
                                pass
                        else:
                            if config[context]['addresses'][address_member]['addrObjType'] == '1':
                                address_ipset.add(
                                    '{}/32'.format(config[context]['addresses'][address_member]['addrObjIp1']))
                                # log('Success network')
                                if ip_to_find & address_ipset:
                                    return_list.append((context, address_member, address, ip))
                            elif config[context]['addresses'][address_member]['addrObjType'] == '4':
                                address_ipset.add(
                                    '{}/{}'.format(config[context]['addresses'][address_member]['addrObjIp1'],
                                                   netmask_to_cidr(
                                                       config[context]['addresses'][address_member]['addrObjIp2'])))
                                # log('Success network')
                                if ip_to_find & address_ipset:
                                    return_list.append((context, address_member, address, ip))
                            elif config[context]['addresses'][address_member]['addrObjType'] == '2':
                                try:
                                    # log(config[context]['addresses'][address_member]['addrObjIp1'], config[context]['addresses'][address_member]['addrObjIp2'])
                                    address_ipset.add(
                                        IPRange(config[context]['addresses'][address_member]['addrObjIp1'],
                                                config[context]['addresses'][address_member]['addrObjIp2']))
                                    # log('Success range')
                                    if ip_to_find & address_ipset:
                                        return_list.append((context, address_member, address, ip))

                                except Exception as e:
                                    log('Exception {}'.format(e))
                                    pass

        for items in return_list:
            log(items)
    return return_list


def send_sw_webcmd(session, url, data, timeout=20):
    import re

    # log('Adata:', data)
    debug(data)
    response = session.post(url, verify=False, data=data, stream=True, timeout=timeout)
    status = re.findall(r'<span class="message.*', response.text)
    debug(response.text)
    if len(status) == 1:
        statusmsg = re.sub(r'.*nowrap>(.*?)&nbsp.*', r'\1', status[0])
        if 'has been updated' in statusmsg:
            # log('!-- Address object created : {}'.format(addressname))
            return True
        else:
            # log('!-- Address object creation failed : {} - {}'.format(addressname, statusmsg))
            debug(statusmsg)
            return False
    return status


def send_sw_apicmd(session, url, method, jsondata, timeout=60):
    import re

    status = True
    # log('Adata:', data)
    debug(data)
    if method.lower() == 'post':
        response = session.post(url, verify=False, data=jsondata, timeout=timeout)
    if method.lower() == 'put':
        response = session.put(url, verify=False, data=jsondata, timeout=timeout)
    if method.lower() == 'get':
        response = session.get(url, verify=False, data=jsondata, timeout=timeout)
    # status=re.findall(r'<span class="message.*', response.text)
    json_response = json.loads(response.text)
    if 'status' in json_response:
        status = json_response['status']
    debug(response.text)

    return status


def send_palo_apicmd(session, target, url, apikey, retries=1, retrydelay=10, dryrun=False):
    import re
    import time
    from urllib.parse import quote, urlencode, quote_plus
    from datetime import datetime
    import base64

    # if apikey:
    #    url+='&key={}'.format(apikey)
    # debug(url)
    success = False
    tries = 0
    debug('{} URL: {}'.format(str(datetime.now()), quote(url, safe='?=/&%')))
    if not dryrun:
        while not success and tries < (retries + 1):
            tries += 1
            if session == None:
                if apikey:
                    response = requests.get('https://{}{}&key={}'.format(target, quote(url, safe='?=/&%'), apikey),
                                            verify=False)
                else:
                    response = requests.get('https://{}{}'.format(target, quote(url, safe='?=/&%')), verify=False,
                                            headers={'authorization': "Basic " + base64.b64encode(
                                                '{}:{}'.format(options.username, options.password).encode()).decode()})
            else:
                if apikey:
                    response = session.get('https://{}{}&key={}'.format(target, quote(url, safe='?=/&%'), apikey),
                                           verify=False)
                else:
                    response = requests.get('https://{}{}'.format(target, quote(url, safe='?=/&%')), verify=False,
                                            headers={'authorization': "Basic " + base64.b64encode(
                                                '{}:{}'.format(options.username, options.password).encode()).decode()})
            if len(re.findall('success', response.text)) == 0:
                debug(url)
                debug(quote(url, safe='?=/&%'))
                debug(response.text)
                debug('API Command failed, attempt #{}. Retrying in {} seconds'.format(tries, retrydelay))
                # log('',level=logging.ERROR)
                # log(url,level=logging.ERROR)
                # log(response.text,level=logging.ERROR)
                # exit (1)
                # return response.text
            else:
                success = True
                break
            time.sleep(retrydelay)

        if not success:
            return response.text
    else:
        return True
    return success


def create_address_obj(target, session, apikey, fw_type, syntax, params, sw_objects=None):
    import urllib
    from urllib.parse import quote
    from xml.sax.saxutils import escape
    import json

    if 'members' not in params:
        params['members'] = []

    result = False
    if 'comment' in params and fw_type.lower() in ['palo', 'pano', 'paloalto'] and syntax.lower() in ['webui', 'api']:
        params['comment'] = escape(params['comment'])

    if syntax == 'cli':
        result = True
        if 'prefix' in params:
            prefix = params['prefix']
        else:
            prefix = '{}CLI:'.format(fw_type.upper())
    debug(fw_type)
    if fw_type == 'sonicwall':
        if syntax.lower() == 'cli':
            if params['addresstype'].lower() in ['1', 'host']:
                log('{}address-object ipv4 "{}" host {} zone {}'.format(prefix, params['addressname'], params['ip1'],
                                                                        params['zone']))
            elif params['addresstype'].lower() in ['2', 'range']:
                log('{}address-object ipv4 "{}" range {} {} zone {}'.format(prefix, params['addressname'],
                                                                            params['ip1'], params['ip2'],
                                                                            params['zone']))
            elif params['addresstype'].lower() in ['4', 'network']:
                log('{}address-object ipv4 "{}" network {} {} zone {}'.format(prefix, params['addressname'],
                                                                              params['ip1'], params['ip2'],
                                                                              params['zone']))
            elif params['addresstype'].lower() in ['8', 'group']:
                log('{}address-group ipv4 "{}"'.format(prefix, params['addressname']))
                for member in params['members']:
                    log('{}address-object ipv4 "{}"'.format(prefix, member))
                log('{}exit'.format(prefix))
        elif syntax.lower() in ['webui', 'api']:
            if params['addresstype'].lower() in ['8', 'group']:
                params['zone'] = ''
                params['ip1'] = '0.0.0.0'
                params['ip2'] = '0.0.0.0'
                params['addresstype'] = '8'
            if params['addresstype'].lower() == 'host':
                params['addresstype'] = '1'
            elif params['addresstype'].lower() == 'range':
                params['addresstype'] = '2'
            elif params['addresstype'].lower() == 'network':
                params['addresstype'] = '4'
            postdata = {'addrObjId_-1': params['addressname'],
                        'addrObjType_-1': params['addresstype'],
                        'addrObjZone_-1': params['zone'],
                        'addrObjProperties_-1': '14',
                        'addrObjIp1_-1': params['ip1'],
                        'addrObjIp2_-1': params['ip2']
                        }
            debug(postdata)
            url = 'https://' + target + '/main.cgi'
            result = send_sw_webcmd(session, url, postdata)
            if params['addresstype'].lower() in ['8', 'group']:
                for member in params['members']:
                    if result:
                        postdata = {'addro_atomToGrp_0': member,
                                    'addro_grpToGrp_0': params['addressname']
                                    }
                        result = send_sw_webcmd(session, url, postdata)
        # elif syntax.lower() in ['api']:

        else:
            return 'Unknown syntax "{}" specified for Sonicwall'.format(syntax)
    elif fw_type.lower() in ['sw65']:
        if syntax.lower() in ['api']:
            if params['addresstype'].lower() in ['8',
                                                 'group']:  ##CHANGE_ME - to add a group, it must have members, and member object type (address_group/address_object/fqdn/mac) needs to be known
                if 'members' not in params:
                    params['members'] == []

                url = 'https://{}/api/sonicos/address-groups/ipv4'.format(target)
                members = []
                post_data = {'address_group': {
                    'ipv4': {
                        'name': params['addressname']
                        #                                'address_object': {'ipv4': [] },
                        #                                'address_group': {'ipv4': [] },
                    }
                }
                }

                '''
                members_added=False
                for address_object in params['members']:
                    members_added=True
                    if address_object in sw_objects['address_objects']['ipv4']:  
                        if 'address_object' in post_data['address_group']['ipv4']:
                            post_data['address_group']['ipv4']['address_object']['ipv4'].append({'name': address_object})
                        else:
                            post_data['address_group']['ipv4']['address_object']={'ipv4': {'name': address_object}}
                for address_object in params['members']:
                    members_added=True
                    if address_object in sw_objects['address_groups']['ipv4']:  
                        if 'address_group' in post_data['address_group']['ipv4']:
                            post_data['address_group']['ipv4']['address_group']['ipv4'].append({'name': address_object})
                        else:
                            post_data['address_group']['ipv4']['address_group']={'ipv4': {'name': address_object}}

                '''

                members_added = False
                for address_object in params['members']:
                    members_added = True
                    if address_object in sw_objects['address_objects']['ipv4']:
                        if 'address_object' in post_data['address_group']['ipv4']:
                            post_data['address_group']['ipv4']['address_object']['ipv4'].append(
                                {'name': address_object})
                        else:
                            post_data['address_group']['ipv4']['address_object'] = {'ipv4': [{'name': address_object}]}

                for address_object in params['members']:
                    members_added = True
                    if address_object in sw_objects['address_objects']['fqdn']:
                        pass
                        if 'address_object' in post_data['address_group']['ipv4']:
                            post_data['address_group']['ipv4']['address_object']['fqdn'].append(
                                {'name': address_object})
                        else:
                            post_data['address_group']['ipv4']['address_object'] = {'fqdn': [{'name': address_object}]}

                for address_object in params['members']:
                    members_added = True
                    if address_object in sw_objects['address_groups']['ipv4']:
                        if 'address_group' in post_data['address_group']['ipv4']:
                            post_data['address_group']['ipv4']['address_group']['ipv4'].append({'name': address_object})
                        else:
                            post_data['address_group']['ipv4']['address_group'] = {'ipv4': [{'name': address_object}]}

                '''
                post_data=  {   'address_group' : {
                                    'ipv4':     {
                                        'name' : params['addressname'],
                                        'address_object': {'ipv4': [] }
                                    }
                                }
                            }   
                for address_object in sw_objects['address_objects']['ipv4']:
                    if address_object in params['members']:
                        post_data['address_group']['ipv4']['address_object']['ipv4'].append({'name': address_object})
                for address_object in sw_objects['address_groups']['ipv4']:
                    if address_object in params['members']:
                        post_data['address_group']['ipv4']['address_object']['ipv4'].append({'group': address_object})
                        #members.append({'group': address_object})    
                '''

                if members_added:  # post_data['address_group']['ipv4']['address_object']['ipv4']  != []: # members!=[]:
                    debug(post_data)
                    result = session.post(url=url, json=post_data, verify=False, timeout=options.timeout_sw_webui_post)
                    if not json.loads(result.text)['status']['success']:
                        result = False, json.loads(result.text)['status']['info'][0]['message']
                    else:
                        result = True

                else:
                    result = False, 'no valid member objects'

            elif params['addresstype'].lower() in ['host', '1']:
                url = 'https://{}/api/sonicos/address-objects/ipv4'.format(target)
                post_data = {'address_object': {
                    'ipv4': {
                        'name': params['addressname'],
                        'zone': params['zone'],
                        'host': {'ip': params['ip1']}}}}
                result = session.post(url=url, json=post_data, verify=False, timeout=options.timeout_sw_webui_post)
                if not json.loads(result.text)['status']['success']:
                    result = False, json.loads(result.text)['status']['info'][0]['message']
                else:
                    result = True
            elif params['addresstype'].lower() in ['range', '2']:
                url = 'https://{}/api/sonicos/address-objects/ipv4'.format(target)
                post_data = {'address_object': {
                    'ipv4': {
                        'name': params['addressname'],
                        'zone': params['zone'],
                        'range': {'begin': params['ip1'], 'end': params['ip2']}}}}
                result = session.post(url=url, json=post_data, verify=False, timeout=options.timeout_sw_webui_post)
                if not json.loads(result.text)['status']['success']:
                    result = False, json.loads(result.text)['status']['info'][0]['message']
                else:
                    result = True
            elif params['addresstype'].lower() in ['network', '4']:
                url = 'https://{}/api/sonicos/address-objects/ipv4'.format(target)
                post_data = {'address_object': {
                    'ipv4': {
                        'name': params['addressname'],
                        'zone': params['zone'],
                        'network': {'subnet': params['ip1'], 'mask': params['ip2']}}}}

                result = session.post(url=url, json=post_data, verify=False, timeout=options.timeout_sw_webui_post)
                if not json.loads(result.text)['status']['success']:
                    result = False, json.loads(result.text)['status']['info'][0]['message']
                else:
                    result = True
            elif params['addresstype'].lower() in ['fqdn']:
                url = 'https://{}/api/sonicos/address-objects/fqdn'.format(target)
                post_data = {'address_object': {
                    'fqdn': {
                        'name': params['addressname'],
                        'zone': params['zone'],
                        'domain': params['domain']}}}
                if 'ttl' in params:
                    post_data['address_object']['fqdn']['dns_ttl'] = int(params['ttl'])

                result = session.post(url=url, json=post_data, verify=False, timeout=options.timeout_sw_webui_post)
                if not json.loads(result.text)['status']['success']:
                    result = False, json.loads(result.text)['status']['info'][0]['message']
                else:
                    result = True
            # result=send_palo_apicmd(session, target, url, apikey)

    elif fw_type == 'checkpoint':
        if syntax.lower() == 'cli':
            if params['addresstype'].lower() in ['1', 'host']:
                log('{}create host_plain {}'.format(prefix, params['addressname']))
                log('{}update_all'.format(prefix))
                log('{}modify network_objects {} ipaddr {}'.format(prefix, params['addressname'], params['ip1']))
            if params['addresstype'].lower() in ['2', 'range']:
                log('{}create address_range {}'.format(prefix, params['addressname']))
                log('{}update_all'.format(prefix))
                log('{}modify network_objects {} ipaddr_first {}'.format(prefix, params['addressname'], params['ip1']))
                log('{}modify network_objects {} ipaddr_last {}'.format(prefix, params['addressname'], params['ip2']))
            if params['addresstype'].lower() in ['4', 'network']:
                log('{}create network {}'.format(prefix, params['addressname']))
                log('{}update_all'.format(prefix))
                log('{}modify network_objects {} ipaddr {}'.format(prefix, params['addressname'], params['ip1']))
                log('{}modify network_objects {} netmask {}'.format(prefix, params['addressname'], params['ip2']))
            # log('{}:modify network_objects'.format(addressname))
            if params['addresstype'].lower() in ['8', 'group']:
                log('{}create network_object_group {}'.format(prefix, params['addressname']))
                log('{}update_all'.format(prefix))
            log('{}modify network_objects {} comments "{}"'.format(prefix, params['addressname'], params['comment']))
            log('{}modify network_objects {} color {}'.format(prefix, params['addressname'], params['color']))
            for member in params['members']:
                log('{}addelement network_objects {} \'\' network_objects:{}'.format(prefix, params['addressname'],
                                                                                     member))
        elif syntax.lower() == 'api':
            post_data = None
            if params['addresstype'].lower() in ['1', 'host']:
                post_command = 'add-host'
                post_data = {"name": params['addressname'], "ip-address": params['ip1'], "ignore-warnings": True}
                debug('RESULT', result)
            if params['addresstype'].lower() in ['2', 'range']:
                post_command = 'add-address-range'
                post_data = {"name": params['addressname'], "ip-address-first": params['ip1'],
                             "ip-address-last": params['ip2'], "ignore-warnings": True}

            if params['addresstype'].lower() in ['4', 'network']:
                post_command = 'add-network'
                post_data = {"name": params['addressname'], "subnet": params['ip1'], "subnet-mask": params['ip2'],
                             "ignore-warnings": True}

            if params['addresstype'].lower() in ['8', 'group']:
                post_command = 'add-group'
                post_data = {"name": params['addressname'], "ignore-warnings": True}
                if 'members' in params:
                    post_data['members'] = params['members']

            if post_data != None:
                if 'tags' in params:
                    post_data['tags'] = params['tags']
                if 'comments' in params:
                    post_data['comments'] = params['comments']
                if 'color' in params:
                    post_data['color'] = params['color']

                result = ckpt_api_call(target, 443, post_command, post_data, apikey)
                debug('create addr', result)
                if result.status_code != 200:
                    debug(result.text)
                    result = False, json.loads(result.text)['message']
                else:
                    result = True
            # log('{}modify network_objects {} comments "{}"'.format(prefix, params['addressname'], params['comment']))
            # log('{}modify network_objects {} color {}'.format(prefix, params['addressname'], params['color']))
            # for member in params['members']:
            #    log('{}addelement network_objects {} \'\' network_objects:{}'.format(prefix, params['addressname'], member))

        else:
            result = False

    elif fw_type in ['palo', 'paloalto', 'pano']:
        if syntax.lower() in ['webui', 'api']:
            if fw_type in ['palo', 'paloalto']:
                object_base = "/config/devices/entry[@name='localhost.localdomain']/vsys/entry[@name='vsys1']"

            elif fw_type == 'pano':
                if params['context'] == 'shared':
                    object_base = "/config/shared"
                else:
                    object_base = "/config/devices/entry[@name='localhost.localdomain']/device-group/entry[@name='{}']".format(
                        params['context'])
            if 'comment' not in params:
                params['comment'] = ''
            if params['addresstype'].lower() in ['1', 'host']:
                url = '/api/?type=config&action=set&xpath={}/address/entry[@name=\'{}\']&element=<ip-netmask>{}/{}</ip-netmask><description>{}</description>'.format(
                    object_base, params['addressname'], params['ip1'], '32', quote(params['comment'], safe=''))
            if params['addresstype'].lower() in ['2', 'range']:
                url = '/api/?type=config&action=set&xpath={}/address/entry[@name=\'{}\']&element=<ip-range>{}-{}</ip-range><description>{}</description>'.format(
                    object_base, params['addressname'], params['ip1'], params['ip2'], quote(params['comment'], safe=''))
            if params['addresstype'].lower() in ['4', 'network']:
                url = '/api/?type=config&action=set&xpath={}/address/entry[@name=\'{}\']&element=<ip-netmask>{}/{}</ip-netmask><description>{}</description>'.format(
                    object_base, params['addressname'], params['ip1'], netmask_to_cidr(params['ip2']),
                    quote(params['comment'], safe=''))
            if params['addresstype'].lower() in ['8', 'group']:
                url = '/api/?type=config&action=set&xpath={}/address-group/entry[@name=\'{}\']&element=<static></static><description>{}</description>'.format(
                    object_base, params['addressname'], quote(params['comment']))
            result = send_palo_apicmd(session, target, url, apikey)
            debug(target, result)
            if params['addresstype'].lower() in ['8', 'group']:
                memberlist = ''
                for member in params['members']:
                    memberlist = memberlist + '<member>{}</member>'.format(member)
                if memberlist != '':
                    url = '/api/?type=config&action=set&xpath={}/address-group/entry[@name=\'{}\']/static&element={}'.format(
                        object_base, params['addressname'], memberlist)
                    result = send_palo_apicmd(session, target, url, apikey)
                    # print(result)
        elif syntax.lower() == 'cli':
            cmds = []
            if fw_type.lower() in ['palo', 'paloalto']:
                cmd_base = ''
            elif fw_type.lower() == 'pano':
                if params['context'] == 'shared':
                    cmd_base = 'shared '
                else:
                    cmd_base = 'device-group "{}" '.format(params['context'])
            if 'prefix' in params:
                prefix = params['prefix']
            else:
                prefix = '{}CLI:'.format(fw_type.upper())
            if params['addresstype'].lower() in ['1', 'host']:
                cmds.append(
                    '{}set {}address {} description "{}" ip-netmask {}'.format(prefix, cmd_base, params['addressname'],
                                                                               params['comment'], params['ip1']))
            if params['addresstype'].lower() in ['2', 'range']:
                cmds.append(
                    '{}set {}address {} description "{}" ip-range {}-{}'.format(prefix, cmd_base, params['addressname'],
                                                                                params['comment'], params['ip1'],
                                                                                params['ip2']))
            if params['addresstype'].lower() in ['4', 'network']:
                cmds.append('{}set {}address {} description "{}" ip-netmask {}/{}'.format(prefix, cmd_base,
                                                                                          params['addressname'],
                                                                                          params['comment'],
                                                                                          params['ip1'],
                                                                                          netmask_to_cidr(
                                                                                              params['ip2'])))
            if params['addresstype'].lower() in ['8', 'group']:
                cmds.append('{}set {}address-group {} description "{}"'.format(prefix, cmd_base, params['addressname'],
                                                                               params['comment']))
                for member in params[
                    'members']:  ## one member is added at a time intentionally -- unsure what would happen if all were to be added at once and one address was bad
                    cmds.append(
                        '{}set {}address-group {} static "{}"'.format(prefix, cmd_base, params['addressname'], member))
            for cmd in cmds:
                log(cmd)

            return True
        else:
            return 'Unsupported syntax type: {} specified for Palo/Pano config'.format(syntax)
    return result


def create_service_obj(target, session, apikey, fw_type, syntax, params, sw_objects=None):
    import urllib
    from urllib.parse import quote
    from xml.sax.saxutils import escape
    import json

    if 'members' not in params:
        params['members'] = []

    result = False
    if 'comment' in params and fw_type.lower() in ['palo', 'pano', 'paloalto'] and syntax.lower() in ['webui', 'api']:
        params['comment'] = escape(params['comment'])

    if syntax.lower() == 'cli':
        result = True
        if 'prefix' in params:
            prefix = params['prefix']
        else:
            prefix = '{}CLI:'.format(fw_type.upper())

    if fw_type == 'sonicwall':
        if syntax.lower() == 'cli':
            if params['servicetype'].lower() in ['1', 'service']:
                if params['protocol'].lower() in ['tcp', '6']:
                    if 'port2' in params:
                        log('{}service-object "{}" tcp {} {}'.format(prefix, params['servicename'], params['port1'],
                                                                     params['port2']))
                    else:
                        log('{}service-object "{}" tcp {} {}'.format(prefix, params['servicename'], params['port1'],
                                                                     params['port1']))
                elif params['protocol'].lower() in ['udp', '17']:
                    if 'port2' in params:
                        log('{}service-object "{}" udp {} {}'.format(prefix, params['servicename'], params['port1'],
                                                                     params['port2']))
                    else:
                        log('{}service-object "{}" udp {} {}'.format(prefix, params['servicename'], params['port1'],
                                                                     params['port1']))
            elif params['servicetype'].lower() in ['2', 'service-group', 'servicegroup', 'group']:
                log('{}service-group "{}"'.format(prefix, params['servicename']))
                for member in params['members']:
                    log('{}service-object "{}"'.format(prefix, member))
                log('{}exit'.format(prefix))
        elif syntax.lower() in ['webui', 'api']:
            postdata = {'svcObjId_-1': params['servicename'],
                        'svcObjType_-1': params['servicetype'],
                        'svcObjProperties_-1': '14',
                        }
            if params['servicetype'].lower() in ['1', 'service']:
                postdata.update({'svcObjPort1_-1': params['port1'],
                                 'svcObjManagement_-1': '0',
                                 'svcObjHigherPrecedence_-1': '0'})
                if 'port2' in params:
                    postdata.update({'svcObjPort2_-1': params['port2']})
                else:
                    postdata.update({'svcObjPort2_-1': params['port1']})
                if params['servicetype'].lower() == 'tcp':
                    postdata.update({'svcObjIpType_-1': '6'})
                elif params['servicetype'].lower() == 'udp':
                    postdata.update({'svcObjIpType_-1': '17'})

            url = 'https://' + target + '/main.cgi'
            result = send_sw_webcmd(session, url, postdata)
            if params['servicetype'].lower() in ['2', 'service-group', 'servicegroup', 'group']:
                for member in params['members']:
                    if result:
                        postdata = {'so_atomToGrp_0': member,
                                    'so_grpToGrp_0': params['servicename']
                                    }
                        result = send_sw_webcmd(session, url, postdata)
        else:
            return 'Unknown syntax "{}" specified for Sonicwall'.format(syntax)
    elif fw_type.lower() in ['sw65']:
        if syntax.lower() in ['api']:
            if params['servicetype'].lower() in ['1', 'service']:
                if params['protocol'].lower() in ['tcp', '6']:
                    if 'port2' in params:
                        post_data = {'service_object': {'name': params['servicename'],
                                                        'tcp': {'begin': int(params['port1']),
                                                                'end': int(params['port2'])}}}
                    else:
                        post_data = {'service_object': {'name': params['servicename'],
                                                        'tcp': {'begin': int(params['port1']),
                                                                'end': int(params['port1'])}}}
                elif params['protocol'].lower() in ['udp', '17']:
                    if 'port2' in params:
                        post_data = {'service_object': {'name': params['servicename'],
                                                        'udp': {'begin': int(params['port1']),
                                                                'end': int(params['port2'])}}}
                    else:
                        post_data = {'service_object': {'name': params['servicename'],
                                                        'udp': {'begin': int(params['port1']),
                                                                'end': int(params['port1'])}}}
                url = 'https://{}/api/sonicos/service-objects'.format(target)
                result = session.post(url=url, json=post_data)
                if not json.loads(result.text)['status']['success']:
                    result = False, json.loads(result.text)['status']['info'][0]['message']
                else:
                    result = True

            elif params['servicetype'].lower() in ['2', 'service-group', 'servicegroup', 'group']:
                service_objects = []
                service_groups = []
                members = []
                for service_object in params['members']:
                    if service_object in sw_objects['service_objects']:
                        members.append({'name': service_object})
                for service_object in params['members']:
                    if service_object in sw_objects['service_groups']:
                        members.append({'group': service_object})
                if members != []:
                    post_data = {'service_group': {'name': params['servicename'], 'service_object': members}}
                    url = 'https://{}/api/sonicos/service-groups'.format(target)
                    result = session.post(url=url, json=post_data)
                    if not json.loads(result.text)['status']['success']:
                        result = False, json.loads(result.text)['status']['info'][0]['message']
                    else:
                        result = True

                else:
                    result = False, 'no valid member objects'

    elif fw_type == 'checkpoint':
        if syntax.lower() == 'cli':
            if params['servicetype'].lower() in ['1', 'service']:
                if params['protocol'].lower() in ['tcp', '6']:
                    log('{}create tcp_service {}'.format(prefix, params['servicename']))
                elif params['protocol'].lower() in ['udp', '17']:
                    log('{}create udp_service {}'.format(prefix, params['servicename']))
                log('{}update_all'.format(prefix))
                log('{}modify services {} port {}'.format(prefix, params['servicename'], params['port1']))
                log('{}modify services {} color {}'.format(prefix, params['servicename'], params['color']))
            if params['servicetype'].lower() in ['2', 'service-group', 'servicegroup', 'group']:
                log('{}create service_group {}'.format(prefix, params['servicename']))
                log('{}update_all'.format(prefix))
            log('{}modify services {} comments "{}"'.format(prefix, params['servicename'], params['comment']))
            log('{}modify services {} color {}'.format(prefix, params['servicename'], params['color']))
            for member in params['members']:
                log('{}addelement services {} \'\' services:{}'.format(prefix, params['servicename'], member))
        elif syntax.lower() == 'api':
            post_data = None
            if params['servicetype'].lower() in ['1', 'service']:
                post_data = {"name": params['servicename'], "ignore-warnings": True}
                if params['protocol'].lower() in ['tcp', '6']:
                    post_command = 'add-service-tcp'
                    if 'port2' in params:
                        post_data['port'] = '{}-{}'.format(params['port1'], params['port2'])
                    else:
                        post_data['port'] = params['port1']
                elif params['protocol'].lower() in ['udp', '17']:
                    post_command = 'add-service-udp'
                    if 'port2' in params:
                        post_data['port'] = '{}-{}'.format(params['port1'], params['port2'])
                    else:
                        post_data['port'] = params['port1']
                elif params['protocol'].lower() in ['icmp', '1']:
                    post_command = 'add-service-icmp'
                    post_data['icmp-type'] = params['port1']
                    if 'port2' in params:
                        post_data['icmp-code'] = params['port2']
                elif params['protocol'].lower() in ['icmp6', 'icmpv6', '58']:
                    post_command = 'add-service-icmp6'
                    post_data['icmp-type'] = params['port1']
                    if 'port2' in params:
                        post_data['icmp-code'] = params['port2']
                elif params['protocol'].lower() in ['sctp', '132']:
                    post_command = 'add-service-sctp'
                    if 'port2' in params:
                        post_data['port'] = '{}-{}'.format(params['port1'], params['port2'])
                    else:
                        post_data['port'] = params['port1']
                elif params['protocol'].lower() in ['other', '255']:
                    post_command = 'add-service-other'
                    post_data['ip-protocol'] = params['port1']
                elif params['protocol'].lower() in ['dce-rpc']:
                    post_command = 'add-service-dce-rpc'
                elif params['protocol'].lower() in ['rpc']:
                    post_command = 'add-service-rpc'
                    post_data['program-number'] = params['port1']
                elif params['protocol'].lower() in ['gtp']:
                    post_command = 'add-service-gtp'

                elif params['protocol'].lower() in ['citrix-tcp']:
                    post_command = 'add-service-citrix-tcp'
                elif params['protocol'].lower() in ['compound-tcp']:
                    post_command = 'add-service-compound-tcp'

                # post_data={"name": params['servicename'], "ip-address": params['ip1'], "ignore-warnings": True}
                debug('RESULT', result)

            elif params['servicetype'].lower() in ['2', 'group']:
                post_command = 'add-service-group'
                post_data = {"name": params['servicename'], "ignore-warnings": True}
                if 'members' in params:
                    post_data['members'] = params['members']

            if post_data != None:
                if 'tags' in params:
                    post_data['tags'] = params['tags']
                if 'comments' in params:
                    post_data['comments'] = params['comments']
                if 'color' in params:
                    post_data['color'] = params['color']

                result = ckpt_api_call(target, 443, post_command, post_data, apikey)
                debug('create svc', result)
                if result.status_code != 200:
                    debug(result.text)
                    result = False, json.loads(result.text)['message']
                else:
                    result = True


    elif fw_type in ['palo', 'paloalto', 'pano']:

        if syntax.lower() in ['webui', 'api']:
            if fw_type in ['palo', 'paloalto']:
                object_base = "/config/devices/entry[@name='localhost.localdomain']/vsys/entry[@name='vsys1']"

            elif fw_type == 'pano':
                if params['context'] == 'shared':
                    object_base = "/config/shared"
                else:
                    object_base = "/config/devices/entry[@name='localhost.localdomain']/device-group/entry[@name='{}']".format(
                        params['context'])
            if params['servicetype'].lower() in ['1', 'service']:
                if params['protocol'].lower() in ['tcp', '6']:
                    tmp_protocol = 'tcp'
                elif params['protocol'].lower() in ['udp', '17']:
                    tmp_protocol = 'udp'
                else:
                    tmp_protocol = params['protocol']
                if 'port2' in params:
                    if params['port2'] != '' and params['port1'] != params['port2']:
                        url = '/api/?type=config&action=set&xpath={}/service/entry[@name=\'{}\']&element=<protocol><{}><port>{}-{}</port></{}></protocol><description>{}</description>'.format(
                            object_base, params['servicename'], tmp_protocol, params['port1'], params['port2'],
                            params['protocol'], quote(params['comment'], safe=''))
                    else:
                        url = '/api/?type=config&action=set&xpath={}/service/entry[@name=\'{}\']&element=<protocol><{}><port>{}</port></{}></protocol><description>{}</description>'.format(
                            object_base, params['servicename'], tmp_protocol, params['port1'], params['protocol'],
                            quote(params['comment'], safe=''))
                else:
                    url = '/api/?type=config&action=set&xpath={}/service/entry[@name=\'{}\']&element=<protocol><{}><port>{}</port></{}></protocol><description>{}</description>'.format(
                        object_base, params['servicename'], tmp_protocol, params['port1'], params['protocol'],
                        quote(params['comment'], safe=''))
            if params['servicetype'].lower() in ['2', 'service-group', 'servicegroup', 'group']:
                url = '/api/?type=config&action=set&xpath={}/service-group/entry[@name=\'{}\']&element=<members></members>'.format(
                    object_base, params['servicename'])
            result = send_palo_apicmd(session, target, url, apikey)
            if params['servicetype'].lower() in ['2', 'service-group', 'servicegroup', 'group']:
                memberlist = ''
                for member in params['members']:
                    memberlist = memberlist + '<member>{}</member>'.format(member)
                if memberlist != '':
                    url = '/api/?type=config&action=set&xpath={}/service-group/entry[@name=\'{}\']/members&element={}'.format(
                        object_base, params['servicename'], memberlist)
                    result = send_palo_apicmd(session, target, url, apikey)
                    # print(result)
        elif syntax.lower() == 'cli':
            cmds = []
            if fw_type.lower() in ['palo', 'paloalto']:
                cmd_base = ''
            elif fw_type.lower() == 'pano':
                if params['context'] == 'shared':
                    cmd_base = 'shared '
                else:
                    cmd_base = 'device-group "{}" '.format(params['context'])
            if 'prefix' in params:
                prefix = params['prefix']
            else:
                prefix = '{}CLI:'.format(fw_type.upper())
            if params['servicetype'].lower() in ['1', 'service']:
                if params['protocol'].lower() in ['tcp', '6']:
                    tmp_protocol = 'tcp'
                elif params['protocol'].lower() in ['udp', '17']:
                    tmp_protocol = 'udp'
                else:
                    tmp_protocol = params['protocol']
                if 'port2' in params:
                    cmds.append('{}set {}service {} description "{}" protocol {} port {}-{}'.format(prefix, cmd_base,
                                                                                                    params[
                                                                                                        'servicename'],
                                                                                                    params['comment'],
                                                                                                    tmp_protocol,
                                                                                                    params['port1'],
                                                                                                    params['port2']))
                else:
                    cmds.append('{}set {}service {} description "{}" protocol {} port {}'.format(prefix, cmd_base,
                                                                                                 params['servicename'],
                                                                                                 params['comment'],
                                                                                                 tmp_protocol,
                                                                                                 params['port1']))
            if params['servicetype'].lower() in ['2', 'service-group', 'servicegroup', 'group']:
                cmds.append(
                    '{}set {}service-group {}'.format(prefix, cmd_base, params['servicename'], params['comment']))
                for member in params[
                    'members']:  ## one member is added at a time intentionally -- unsure what would happen if all were to be added at once and one address was bad
                    cmds.append(
                        '{}set {}service-group {} members "{}"'.format(prefix, cmd_base, params['servicename'], member))
            for cmd in cmds:
                log(cmd)

            return True
        else:
            return 'Unsupported syntax type: {} specified for Palo/Pano config'.format(syntax)
    return result


## moved to create address (use type 8)
'''
 moved to create address (use type 8)
def create_address_group_obj(target, session, apikey, fw_type, syntax, params): 
    
    import urllib

    if fw_type=='sonicwall':
        if syntax=='cli':
            log('SWCLI:address-group ipv4 "{}"'.format(params['groupname']))
            for member in params['members']:
                log('SWCLI:address-object ipv4 "{}"'.format(member))
            log('SWCLI:exit')
        elif syntax in ['webui', 'api']:
            postdata={  'addrObjId_-1' : params['groupname'],
            'addrObjType_-1' : '8',
            'addrObjZone_-1' : '',
            'addrObjProperties_-1' : '14',
            'addrObjIp1_-1' : '0.0.0.0',
            'addrObjIp2_-1' : '0.0.0.0'
            }
            url='https://' + target + '/main.cgi'
            result=send_sw_webcmd(session, url, postdata)
            for member in params['members']:
                if result:
                    postdata={  'addro_atomToGrp_0' : member,
                                'addro_grpToGrp_0' : params['groupname']
                    }
                    result=send_sw_webcmd(session, url, postdata)
            ## what should I return here?
        else:
            return 'Unknown syntax "{}" specified for Sonicwall'.format(syntax)    

    elif fw_type=='checkpoint':
        log('DBEDIT:create network_object_group {}'.format(params['groupname']))
        log('DBEDIT:update_all')
        log('DBEDIT:modify network_objects {} comments "{}"'.format(params['groupname'], params['comment']))
        log('DBEDIT:modify network_objects {} color {}'.format(params['groupname'], params['color']))
        for member in params['members']:
            log('DBEDIT:addelement network_objects {} \'\' network_objects:{}'.format(params['groupname'], member))
    elif fw_type in ['palo', 'pano']:
        if syntax in ['webui', 'api']:
            if fw_type=='palo':
                object_base="/config/devices/entry[@name='localhost.localdomain']/vsys/entry[@name='vsys1']" 

            elif fw_type=='pano':
                if params['context']=='shared':
                    object_base="/config/shared"
                else:
                    object_base="/config/devices/entry[@name='localhost.localdomain']/device-group/entry[@name='{}']".format(params['context'])
            url='/api/?type=config&action=set&xpath={}/address-group/entry[@name=\'{}\']&element=<static></static>&key={}'.format(object_base, params['groupname'], apikey)
            result=send_palo_apicmd(session, target, url, apikey)
            memberlist=''
            for member in params['members']:
                memberlist=memberlist+'<member>{}</member>'.format(member)
            if memberlist!='':
                url='/api/?type=config&action=set&xpath={}/address-group/entry[@name=\'{}\']/static&element={}&key={}'.format(object_base, params['groupname'], memberlist, apikey)
                result=send_palo_apicmd(session, target, url, apikey)
        else:
            return 'CLI Commands not yet implemented for Palo/Pano'

    
    return
'''


def modify_address_obj(target, session, apikey, fw_type, syntax, params, sw_objects=None):
    import urllib
    from urllib.parse import quote
    from xml.sax.saxutils import escape
    import json

    result = False
    if 'comment' in params and fw_type.lower() in ['palo', 'pano', 'paloalto'] and syntax.lower() in ['webui', 'api']:
        params['comment'] = escape(params['comment'])

    if syntax.lower() == 'cli':
        result = True
        if 'prefix' in params:
            prefix = params['prefix']
        else:
            prefix = '{}CLI:'.format(fw_type.upper())
    # log('PREFIX  '+prefix)
    if fw_type == 'sonicwall':
        if syntax.lower() == 'cli':
            # for param in params:
            if params['action'].lower() == 'addmembers':
                log('{}address-group ipv4 "{}"'.format(prefix, params['addressname']))
                for member in params['members']:
                    log('{}address-object ipv4 "{}"'.format(prefix, member))
                log('{}exit'.format(prefix))
            elif params['action'].lower() == 'delmembers':
                log('{}address-group ipv4 "{}"'.format(prefix, params['addressname']))
                for member in params['members']:
                    log('{}no address-object ipv4 "{}"'.format(prefix, member))
                log('{}exit').format(prefix)
            elif params['action'].lower() == 'delete':
                if params['addresstype'] == 'group':
                    log('{}no address-group ipv4 "{}"'.format(prefix, params['addressname']))
                else:
                    log('{}no address-group ipv4 "{}"'.format(prefix, params['addressname']))
            # elif params['action'].lower()=='':
            else:
                return 'Unknown Action'
            return True
        elif syntax.lower() in ['webui', 'api']:
            # for value, action in actions:
            if params['action'].lower() == 'addmembers':
                for member in params['members']:
                    postdata = {'addro_atomToGrp_0': member,
                                'addro_grpToGrp_0': params['addressname']
                                }
                    url = 'https://' + target + '/main.cgi'
                    result = send_sw_webcmd(session, url, postdata)
            elif params['action'].lower() == 'delmembers':
                for member in params['members']:
                    postdata = {'addro_atomToGrp_-3': member,
                                'addro_grpToGrp_-3': params['addressname']
                                }
                    url = 'https://' + target + '/main.cgi'
                    result = send_sw_webcmd(session, url, postdata)
            elif params['action'].lower() == 'delete':
                postdata = {'addrObjId_-3': params['addressname']}
                url = 'https://' + target + '/main.cgi'
                result = send_sw_webcmd(session, url, postdata)
            else:
                return 'Unknown Action'
                ## return unknown action type
        else:
            return 'Unknown action "{}" specified for Sonicwall'.format(syntax)

    if fw_type == 'sw65':
        if syntax.lower() == 'api':

            post_data = {'address_group': {
                #                            'ipv4':     {
                #                                'address_object': {'ipv4': [] },
                #                                'address_group': {'ipv4': [] },
                #                            },
                #                            'ipv6': {}
            }
            }

            if params['action'].lower() == 'addmembers':
                url = 'https://{}/api/sonicos/address-groups/ipv4/name/{}'.format(target, params['addressname'])
                members = []
                members_added = False
                for address_object in params['members']:
                    members_added = True
                    if address_object in sw_objects['address_objects']['ipv4']:
                        url = 'https://{}/api/sonicos/address-groups/ipv4/name/{}'.format(target, params['addressname'])
                        if 'ipv4' not in post_data['address_group']:
                            post_data['address_group']['ipv4'] = {}
                        if 'address_object' in post_data['address_group']['ipv4']:
                            post_data['address_group']['ipv4']['address_object']['ipv4'].append(
                                {'name': address_object})
                        else:
                            post_data['address_group']['ipv4']['address_object'] = {'ipv4': [{'name': address_object}]}

                for address_object in params['members']:
                    members_added = True
                    if address_object in sw_objects['address_objects']['fqdn']:
                        url = 'https://{}/api/sonicos/address-groups/ipv6/name/{}'.format(target, params['addressname'])
                        if 'ipv6' not in post_data['address_group']:
                            post_data['address_group']['ipv6'] = {}
                        if 'address_object' in post_data['address_group']['ipv6']:
                            post_data['address_group']['ipv6']['address_object']['fqdn'].append(
                                {'name': address_object})
                        else:
                            post_data['address_group']['ipv6']['address_object'] = {'fqdn': [{'name': address_object}]}

                for address_object in params['members']:
                    members_added = True
                    if address_object in sw_objects['address_groups']['ipv4']:
                        url = 'https://{}/api/sonicos/address-groups/ipv4/name/{}'.format(target, params['addressname'])
                        if 'ipv4' not in post_data['address_group']:
                            post_data['address_group']['ipv4'] = {}
                        if 'address_group' in post_data['address_group']['ipv4']:
                            post_data['address_group']['ipv4']['address_group']['ipv4'].append({'name': address_object})
                        else:
                            post_data['address_group']['ipv4']['address_group'] = {'ipv4': [{'name': address_object}]}

                        # post_data['address_group']['ipv4']['address_group']['ipv4'].append({'name': address_object}) #.append({'name': address_object})
                # if post_data['address_group']['ipv4']['address_object']['ipv4'] != [] or post_data['address_group']['ipv4']['address_group']['ipv4'] != []:
                # if post_data['address_group']['ipv4']['address_group']['ipv4'] != []:
                if members_added == True:
                    # post_data['address_group']['ipv4']['address_object']['ipv4']=members
                    result = session.put(url=url, json=post_data, verify=False, timeout=options.timeout_sw_webui_post)
                    debug(url)
                    debug(post_data)
                    debug(result.text)
                    if not json.loads(result.text)['status']['success']:
                        result = False, json.loads(result.text)['status']['info'][0]['message']
                    else:
                        result = True
            elif params['action'].lower() == 'rename':
                url = 'https://{}/api/sonicos/address-groups/ipv4/name/{}'.format(target, params['addressname'])
                post_data['address_group'] = {'ipv4': {'name': params['newaddressname']}}
                result = session.put(url=url, json=post_data, verify=False, timeout=options.timeout_sw_webui_post)
                debug(result)
                debug(result.text)
                if not json.loads(result.text)['status']['success']:
                    result = False, json.loads(result.text)['status']['info'][0]['message']
                else:
                    result = True
            elif params['action'].lower() == 'delmembers':
                url = 'https://{}/api/sonicos/address-groups/ipv4/name/{}'.format(target, params['addressname'])
                members = []
                members_added = False
                for address_object in params['members']:
                    members_added = True
                    if address_object in sw_objects['address_objects']['ipv4']:
                        if 'address_object' in post_data['address_group']['ipv4']:
                            post_data['address_group']['ipv4']['address_object']['ipv4'].append(
                                {'name': address_object})
                        else:
                            post_data['address_group']['ipv4']['address_object'] = [{'ipv4': {'name': address_object}}]
                for address_object in params['members']:
                    members_added = True
                    if address_object in sw_objects['address_groups']['ipv4']:
                        if 'address_group' in post_data['address_group']['ipv4']:
                            post_data['address_group']['ipv4']['address_group']['ipv4'].append({'name': address_object})
                        else:
                            post_data['address_group']['ipv4']['address_group'] = [{'ipv4': {'name': address_object}}]

                        # post_data['address_group']['ipv4']['address_group']['ipv4'].append({'name': address_object}) #.append({'name': address_object})
                # if post_data['address_group']['ipv4']['address_object']['ipv4'] != [] or post_data['address_group']['ipv4']['address_group']['ipv4'] != []:
                # if post_data['address_group']['ipv4']['address_group']['ipv4'] != []:

                '''
                for address_object in params['members']:
                    if address_object in sw_objects['address_objects']['ipv4']:  
                        members.append({'name': address_object})
                for address_object in params['members']:
                    if address_object in sw_objects['address_groups']['ipv4']:  
                        members.append({'group': address_object})
                if members != [] :
                    post_data['address_group']['ipv4']['address_object']['ipv4']=members
                    debug(url)
                    debug(post_data)
                '''

                if members_added == True:
                    result = session.delete(url=url, json=post_data, verify=False)
                    debug(post_data)
                    debug(result.text)
                    if not json.loads(result.text)['status']['success']:
                        result = False, json.loads(result.text)['status']['info'][0]['message']
                    else:
                        result = True
            elif params['action'].lower() == 'delete':
                if params['addresstype'] in ['group', '8']:
                    url = 'https://{}/api/sonicos/address-groups/ipv4/name/{}'.format(target, params['addressname'])
                else:
                    url = 'https://{}/api/sonicos/address-objects/ipv4/name/{}'.format(target, params['addressname'])
                debug(url)
                result = session.delete(url=url, json=None, verify=False)
                debug(result.text)
                if not json.loads(result.text)['status']['success']:
                    result = False, json.loads(result.text)['status']['info'][0]['message']
                else:
                    result = True
            else:
                return 'Unknown Action'

    elif fw_type == 'checkpoint':
        if syntax.lower() == 'cli':
            # for value, action in actions:
            if params['action'].lower() == 'addmembers':
                for member in params['members']:
                    log('{}addelement network_objects {} \'\' network_objects:{}'.format(prefix, params['addressname'],
                                                                                         member))
            elif params['action'].lower() == 'delmembers':
                for member in params['members']:
                    log('{}rmelement network_objects {} \'\' network_objects:{}'.format(prefix, params['addressname'],
                                                                                        member))
            elif params['action'].lower() == 'color':
                log('{}modify network_objects {} color {}'.format(prefix, params['addressname'], params['color']))
            elif params['action'].lower() == 'comment':
                log('{}modify network_objects {} comments "{}"'.format(prefix, params['addressname'],
                                                                       params['comments']))
            elif params['action'].lower() == 'delete':
                log('{}delete network_objects {}'.format(prefix, params['addressname']))
            else:
                return 'Unknown Action'
                ## return unknown action type
        if syntax.lower() == 'api':
            debug('modify ckpt addr via api')
            post_data = None
            if 'addressname' in params:
                post_data = {'name': params['addressname']}
            if 'uuid' in params:
                post_data = {'uuid': params['uuid']}

            if post_data:
                if params['action'].lower == 'delete':
                    if params['addresstype'].lower() in ['1', 'host']:
                        post_command = 'delete-host'
                    if params['addresstype'].lower() in ['2', 'range']:
                        post_command = 'delete-address-range'
                    if params['addresstype'].lower() in ['4', 'network']:
                        post_command = 'delete-network'
                    if params['addresstype'].lower() in ['8', 'group']:
                        post_command = 'delete-group'
                else:
                    if params['addresstype'].lower() in ['1', 'host']:
                        post_command = 'set-host'
                        if 'ip1' in params:
                            post_data['ip-address'] = params['ip1']
                    if params['addresstype'].lower() in ['2', 'range']:
                        post_command = 'set-address-range'
                        if 'ip1' in params and 'ip2' in params:
                            post_data['ip-address-first'] = params['ip1']
                            post_data['ip-address-last'] = params['ip2']
                    if params['addresstype'].lower() in ['4', 'network']:
                        post_command = 'set-network'
                        if 'ip1' in params and 'ip2' in params:
                            post_data['subnet'] = params['ip1']
                            post_data['subnet-mask'] = params['ip2']
                    if params['addresstype'].lower() in ['8', 'group']:
                        post_command = 'set-group'
                        if params['action'] == 'delmembers' and 'members' in params:
                            post_data['members'] = {'remove': params['members']}
                        if params['action'] == 'addmembers' and 'members' in params:
                            post_data['members'] = {'add': params['members']}
                    if 'tags' in params:
                        post_data['tags'] = params['tags']
                    if 'comments' in params:
                        post_data['comments'] = params['comments']
                    if 'comment' in params:
                        post_data['comments'] = params['comment']
                    if 'color' in params:
                        post_data['color'] = params['color']
                    if 'rename' in params:
                        post_data['new-name'] = params['rename']

                result = ckpt_api_call(target, 443, post_command, post_data, apikey)
                debug('modify addr', result)
                if result.status_code != 200:
                    debug(result.text)
                    result = False, json.loads(result.text)['message']
                else:
                    result = True
    elif fw_type in ['palo', 'pano', 'paloalto']:
        if syntax.lower() in ['webui', 'api']:
            url = None
            if fw_type in ['palo', 'paloalto']:
                object_base = "/config/devices/entry[@name='localhost.localdomain']/vsys/entry[@name='vsys1']"
            elif fw_type == 'pano':
                if params['context'] == 'shared':
                    object_base = "/config/shared"
                else:
                    object_base = "/config/devices/entry[@name='localhost.localdomain']/device-group/entry[@name='{}']".format(
                        params['context'])

            if params['action'].lower() == 'addmembers':
                if params['addresstype'] in ['8', 'group', 'addressgroup']:
                    memberlist = ''
                    for member in params['members']:
                        memberlist = memberlist + '<member>{}</member>'.format(member)
                    if memberlist != '':
                        url = '/api/?type=config&action=set&xpath={}/address-group/entry[@name=\'{}\']/static&element={}'.format(
                            object_base, params['addressname'], memberlist)
                        result = send_palo_apicmd(session, target, url, apikey)
            elif params['action'].lower() == 'delmembers':
                if params['addresstype'] in ['8', 'group', 'addressgroup']:
                    memberlist = ''
                    for member in params['members']:
                        # memberlist=memberlist+'<member>{}</member>'.format(member)
                        # if memberlist!='':
                        url = '/api/?type=config&action=delete&xpath={}/address-group/entry[@name=\'{}\']/static/member[text()="{}"]'.format(
                            object_base, params['addressname'], member)
                        result = send_palo_apicmd(session, target, url, apikey)
            elif params['action'].lower() == 'comment':
                if params['addresstype'] in ['8', 'group', 'addressgroup']:
                    url = '/api/?type=config&action=set&xpath={}/address-group/entry[@name=\'{}\']&element=<description>{}</description>'.format(
                        object_base, params['addressname'], quote(params['comment'], safe=''))
                    result = send_palo_apicmd(session, target, url, apikey)
                else:
                    url = '/api/?type=config&action=set&xpath={}/address/entry[@name=\'{}\']&element=<description>{}</description>'.format(
                        object_base, params['addressname'], quote(params['comment'], safe=''))
                    result = send_palo_apicmd(session, target, url, apikey)
            elif params['action'].lower() == 'tags':
                if params['addresstype'] in ['8', 'group', 'addressgroup']:
                    for tag in params['tags']:
                        url = '/api/?type=config&action=set&xpath={}/address-group/entry[@name=\'{}\']/tag&element=<member>{}</member>'.format(
                            object_base, params['addressname'], tag)
                        result = send_palo_apicmd(session, target, url, apikey)
                else:
                    for tag in params['tags']:
                        url = '/api/?type=config&action=set&xpath={}/address/entry[@name=\'{}\']/tag&element=<member>{}</member>'.format(
                            object_base, params['addressname'], tag)
                        result = send_palo_apicmd(session, target, url, apikey)
            elif params['action'].lower() == 'delete':
                if params['addresstype'] in ['8', 'group']:
                    url = '/api/?type=config&action=delete&xpath={}/address-group/entry[@name=\'{}\']'.format(
                        object_base, params['addressname'])
                    result = send_palo_apicmd(session, target, url, apikey)
                else:  # if params['addresstype'] in ['1', '2', '4', 'host', 'range', 'network']:
                    url = '/api/?type=config&action=delete&xpath={}/address/entry[@name=\'{}\']'.format(object_base,
                                                                                                        params[
                                                                                                            'addressname'])
                    result = send_palo_apicmd(session, target, url, apikey)
        elif syntax.lower() == 'cli':
            cmds = []
            if fw_type.lower() in ['palo', 'paloalto']:
                cmd_base = ''
            elif fw_type.lower() == 'pano':
                if params['context'] == 'shared':
                    cmd_base = 'shared '
                else:
                    cmd_base = 'device-group "{}"'.format(params['context'])
            if params['action'].lower() == 'addmembers':
                for member in params['members']:
                    cmds.append(
                        '{}set {}address-group {} static "{}"'.format(prefix, cmd_base, params['addressname'], member))
            elif params['action'].lower() == 'delmembers':
                for member in params['members']:
                    if params['addresstype'] in ['1', 'host']:
                        cmds.append(
                            '{}delete {}address-group {} static "{}"'.format(prefix, cmd_base, params['addressname'],
                                                                             member))
                    else:
                        cmds.append(
                            '{}delete {}address-group {} static "{}"'.format(prefix, cmd_base, params['addressname'],
                                                                             member))
            elif params['action'].lower() == 'comment':
                if params['addresstype'] in ['1', '2', '4', 'host', 'range', 'network']:
                    cmds.append('{}set {}address {} description "{}"'.format(prefix, cmd_base, params['addressname'],
                                                                             params['comment']))
                else:
                    cmds.append(
                        '{}set {}address-group {} description "{}"'.format(prefix, cmd_base, params['addressname'],
                                                                           params['comment']))
            elif params['action'].lower() == 'tag':
                tags = '[ '
                for tag in params['tags']:
                    tags += tag + " "
                tags += ']'
                if params['addresstype'] in ['1', '2', '4', 'host', 'range', 'network']:
                    cmds.append('{}set {}address {} tag {}'.format(prefix, cmd_base, params['addressname'], tags))
                else:
                    cmds.append('{}set {}address-group {} tag {}'.format(prefix, cmd_base, params['addressname'], tags))
            elif params['action'].lower() == 'delete':
                if params['addresstype'] in ['1', '2', '4', 'host', 'range', 'network']:
                    cmds.append('{}delete {}address {}'.format(prefix, cmd_base, params['addressname']))
                elif params['addresstype'] in ['8', 'group']:
                    cmds.append('{}delete {}address-group {}'.format(prefix, cmd_base, params['addressname']))
            for cmd in cmds:
                log(cmd)
            return True
        else:
            return 'Unsupported syntax type: {} specified for Palo/Pano config'.format(syntax)
    else:
        pass
        ##return unknown firewall type
    return result


def modify_service_obj(target, session, apikey, fw_type, syntax, params, sw_objects=None):
    import urllib
    from urllib.parse import quote
    from xml.sax.saxutils import escape
    import json

    result = False
    if 'comment' in params and fw_type.lower() in ['palo', 'pano', 'paloalto'] and syntax.lower() in ['webui', 'api']:
        params['comment'] = escape(params['comment'])

    if syntax.lower() == 'cli':
        result = True
        if 'prefix' in params:
            prefix = params['prefix']
        else:
            prefix = '{}CLI:'.format(fw_type.upper())

    if fw_type == 'sonicwall':
        if syntax.lower() == 'cli':
            # for param in params:
            if params['action'].lower() == 'addmembers':
                log('{}service-group "{}"'.format(prefix, params['servicename']))
                for member in params['members']:
                    log('{}service-object"{}"'.format(prefix, member))
                log('{}exit').format(prefix)
            elif params['action'].lower() == 'delmembers':
                log('{}service-group "{}"'.format(prefix, params['servicename']))
                for member in params['members']:
                    log('{}no service-object "{}"'.format(prefix, member))
                log('{}exit').format(prefix)
            elif params['action'].lower() == 'delete':
                if params['servicetype'] == 'group':
                    log('{}no service-group "{}"'.format(prefix, params['servicename']))
                else:
                    log('{}no service-object "{}"'.format(prefix, params['servicename']))
            # elif params['action'].lower()=='':
            else:
                return 'Unknown Action'
            return True
        elif syntax.lower() in ['webui', 'api']:
            # for value, action in actions:
            if params['action'].lower() == 'addmembers':
                for member in params['members']:
                    postdata = {'so_atomToGrp_0': member,
                                'so_grpToGrp_0': params['servicename']
                                }
                    url = 'https://' + target + '/main.cgi'
                    result = send_sw_webcmd(session, url, postdata)
            elif params['action'].lower() == 'delmembers':
                for member in params['members']:
                    postdata = {'so_atomToGrp_-3': member,
                                'so_grpToGrp_-3': params['servicename']
                                }
                    url = 'https://' + target + '/main.cgi'
                    result = send_sw_webcmd(session, url, postdata)
            elif params['action'].lower() == 'delete':
                postdata = {'svcObjId_-3': params['servicename']}
                url = 'https://' + target + '/main.cgi'
                result = send_sw_webcmd(session, url, postdata)
            else:
                return 'Unknown Action'
                ## return unknown action type
        else:
            return 'Unknown action "{}" specified for Sonicwall'.format(syntax)
    if fw_type == 'sw65':
        if syntax.lower() == 'api':
            if params['action'].lower() == 'addmembers':
                url = 'https://{}/api/sonicos/service-groups/name/{}'.format(target, params['servicename'])
                object_members = []
                group_members = []
                members = []
                post_data = {'service_group': {'name': params['servicename'], 'service_object': members}}
                for service_object in params['members']:
                    if service_object in sw_objects['service_objects']:
                        members.append({'name': service_object})
                for service_object in params['members']:
                    if service_object in sw_objects['service_groups']:
                        members.append({'group': service_object})
                # if object_members != [] or group_members != [] or members != []:
                #        #post_data={'service_groups': [{ 'service_object': object_members] }}
                if members != []:
                    post_data['service_group']['service_object'] = members  # ['service_object']=object_members
                    # if group_members != []:
                    #    post_data['service_group']['service_group']=group_members #['service_object']=object_members
                    result = session.put(url=url, json=post_data)
                    debug(url)
                    debug(post_data)
                    debug(result.text)
                    if not json.loads(result.text)['status']['success']:
                        result = False, json.loads(result.text)['status']['info'][0]['message']
                    else:
                        result = True
                else:
                    result = False, 'no valid member objects'
            elif params['action'].lower() == 'delmembers':
                url = 'https://{}/api/sonicos/service-groups/name/{}'.format(target, params['servicename'])
                object_members = []
                group_members = []
                members = []
                post_data = {'service_group': {'name': params['servicename'], 'service_object': members}}
                for service_object in params['members']:
                    if service_object in sw_objects['service_objects']:
                        members.append({'name': service_object})
                for service_object in params['members']:
                    if service_object in sw_objects['service_groups']:
                        members.append({'group': service_object})
                # if object_members != [] or group_members != []:
                if members != []:
                    post_data['service_group']['service_object'] = members  # ['service_object']=object_members
                    # if group_members != []:
                    #    post_data['service_group']['service_group']=members #['service_object']=object_members
                    debug(url)
                    debug(post_data)
                    result = session.delete(url=url, json=post_data)
                    debug(result.text)
                    if not json.loads(result.text)['status']['success']:
                        result = False, json.loads(result.text)['status']['info'][0]['message']
                    else:
                        result = True
                else:
                    result = False, 'no valid member objects'

            elif params['action'].lower() == 'delete':
                if params['servicetype'] in ['group', '2']:
                    url = 'https://{}/api/sonicos/service-groups/name/{}'.format(target, params['servicename'])
                else:
                    url = 'https://{}/api/sonicos/service-objects/name/{}'.format(target, params['servicename'])
                debug(url)
                result = session.delete(url=url, json=None)
                debug(result.text)
                if not json.loads(result.text)['status']['success']:
                    result = False, json.loads(result.text)['status']['info'][0]['message']
                else:
                    result = True
            else:
                return 'Unknown Action'

    elif fw_type == 'checkpoint':
        if syntax.lower() == 'cli':
            # for value, action in actions:
            if params['action'].lower() == 'addmembers':
                for member in params['members']:
                    log('{}addelement services {} \'\' services:{}'.format(prefix, params['servicename'], member))
            elif params['action'].lower() == 'delmembers':
                for member in params['members']:
                    log('{}rmelement services {} \'\' services:{}'.format(prefix, params['servicename'], member))
            elif params['action'].lower() == 'color':
                log('{}modify services {} color {}'.format(prefix, params['servicename'], params['color']))
            elif params['action'].lower() == 'comment':
                log('{}modify netwoservicesrk_objects {} comments "{}"'.format(prefix, params['servicename'],
                                                                               params['comments']))
            elif params['action'].lower() == 'delete':
                log('{}delete services {}'.format(prefix, params['servicename']))
            else:
                return 'Unknown Action'
                ## return unknown action type
        if syntax.lower() == 'api':
            debug('modify ckpt svc via api')
            post_data = None
            if 'servicename' in params:
                post_data = {'name': params['servicename']}
            if 'uuid' in params:
                post_data = {'uuid': params['uuid']}
            if post_data:
                if params['action'].lower() == 'delete':
                    if params['servicetype'].lower() in ['1',
                                                         'service']:  ## need to know what kind of service object to delete
                        if 'protocol' in params:
                            if params['protocol'].lower() in ['tcp', '6']:
                                post_command = 'delete-service-tcp'
                            elif params['protocol'].lower() in ['udp', '17']:
                                post_command = 'delete-service-udp'
                            elif params['protocol'].lower() in ['icmp', '1']:
                                post_command = 'delete-service-icmp'
                            elif params['protocol'].lower() in ['icmp6', 'icmpv6', '58']:
                                post_command = 'delete-service-icmp6'
                            elif params['protocol'].lower() in ['sctp', '132']:
                                post_command = 'delete-service-sctp'
                            elif params['protocol'].lower() in ['other', '255']:
                                post_command = 'delete-service-other'
                                post_data['ip-protocol'] = params['port1']
                            elif params['protocol'].lower() in ['dce-rpc']:
                                post_command = 'delete-service-dce-rpc'
                            elif params['protocol'].lower() in ['rpc']:
                                post_command = 'delete-service-rpc'
                            elif params['protocol'].lower() in ['gtp']:
                                post_command = 'delete-service-gtp'
                            elif params['protocol'].lower() in ['citrix-tcp']:
                                post_command = 'delete-service-citrix-tcp'
                            elif params['protocol'].lower() in ['compound-tcp']:
                                post_command = 'delete-service-compound-tcp'
                    elif params['servicetype'].lower() in ['2', 'group']:
                        post_command = 'delete-service-group'
                elif params['action'] == 'delmembers' and 'members' in params:
                    post_command = 'set-service-group'
                    post_data['members'] = {'remove': params['members']}
                elif params['action'] == 'addmembers' and 'members' in params:
                    post_command = 'set-service-group'
                    post_data['members'] = {'add': params['members']}
                else:
                    if 'protocol' in params:
                        if params['protocol'].lower() in ['tcp', '17']:
                            post_command = 'set-service-tcp'
                        if params['protocol'].lower() in ['udp', '6']:
                            post_command = 'set-service-udp'
                    if 'port1' and 'port2' in params:
                        post_data['port'] = '{}-{}'.format(params['port1'], params['port2'])
                    elif 'port1' in params:
                        post_data['port'] = params['port1']
                    if 'tags' in params:
                        post_data['tags'] = params['tags']
                    if 'comments' in params:
                        post_data['comments'] = params['comments']
                    if 'comment' in params:
                        post_data['comments'] = params['comment']
                    if 'color' in params:
                        post_data['color'] = params['color']
                    if 'rename' in params:
                        post_data['new-name'] = params['rename']

                result = ckpt_api_call(target, 443, post_command, post_data, apikey)
                debug('modify addr', result)
                if result.status_code != 200:
                    debug(result.text)
                    result = False, json.loads(result.text)['message']
                else:
                    result = True
    elif fw_type in ['palo', 'pano', 'paloalto']:
        if syntax.lower() in ['webui', 'api']:
            if fw_type in ['palo', 'paloalto']:
                object_base = "/config/devices/entry[@name='localhost.localdomain']/vsys/entry[@name='vsys1']"
            elif fw_type == 'pano':
                if params['context'] == 'shared':
                    object_base = "/config/shared"
                else:
                    object_base = "/config/devices/entry[@name='localhost.localdomain']/device-group/entry[@name='{}']".format(
                        params['context'])
            if params['action'].lower() == 'addmembers':
                if params['servicetype'] in ['2', 'group']:
                    memberlist = ''
                    for member in params['members']:
                        memberlist = memberlist + '<member>{}</member>'.format(member)
                    if memberlist != '':
                        url = '/api/?type=config&action=set&xpath={}/service-group/entry[@name=\'{}\']/members&element={}'.format(
                            object_base, params['servicename'], memberlist)
                        result = send_palo_apicmd(session, target, url, apikey)
            elif params['action'].lower() == 'delmembers':
                # memberlist=''
                for member in params['members']:
                    # memberlist=memberlist+'<member>{}</member>'.format(member)
                    # if memberlist!='':
                    url = '/api/?type=config&action=delete&xpath={}/service-group/entry[@name=\'{}\']/members/member[text()="{}"]'.format(
                        object_base, params['servicename'], member)
                    result = send_palo_apicmd(session, target, url, apikey)
            elif params['action'].lower() == 'comment':  # comments not supported for svc groups
                if params['servicetype'] in ['2', 'group']:
                    url = '/api/?type=config&action=set&xpath={}/service-group/entry[@name=\'{}\']&element=<description>{}</description>'.format(
                        object_base, params['servicename'], quote(params['comment'], safe=''))
                    result = send_palo_apicmd(session, target, url, apikey)
                else:
                    url = '/api/?type=config&action=set&xpath={}/service/entry[@name=\'{}\']&element=<description>{}</description>'.format(
                        object_base, params['servicename'], quote(params['comment'], safe=''))
                    result = send_palo_apicmd(session, target, url, apikey)
            elif params['action'].lower() == 'addtags':
                for tag in params['tags']:
                    if params['servicetype'] in ['1', 'service']:
                        url = '/api/?type=config&action=set&xpath={}/service/entry[@name=\'{}\']/tag&element=<member>{}</member>'.format(
                            object_base, params['servicename'], tag)
                        result = send_palo_apicmd(session, target, url, apikey)
                    elif params['servicetype'] in ['2', 'group']:
                        url = '/api/?type=config&action=set&xpath={}/service-group/entry[@name=\'{}\']/tag&element=<member>{}</member>'.format(
                            object_base, params['servicename'], tag)
                        result = send_palo_apicmd(session, target, url, apikey)
            elif params['action'].lower() == 'delete':
                if params['servicetype'] in ['2', 'group']:
                    url = '/api/?type=config&action=delete&xpath={}/service-group/entry[@name=\'{}\']'.format(
                        object_base, params['servicename'])
                    result = send_palo_apicmd(session, target, url, apikey)
                else:  # if params['servicetype'] in ['1', '2', '4', 'host', 'range', 'network']:
                    url = '/api/?type=config&action=delete&xpath={}/service/entry[@name=\'{}\']'.format(object_base,
                                                                                                        params[
                                                                                                            'servicename'])
                    result = send_palo_apicmd(session, target, url, apikey)
        elif syntax.lower() == 'cli':
            cmds = []
            if fw_type.lower() in ['palo', 'paloalto']:
                cmd_base = ''
            elif fw_type.lower() == 'pano':
                if params['context'] == 'shared':
                    cmd_base = 'shared '
                else:
                    cmd_base = 'device-group "{}"'.format(params['context'])
            if params['action'].lower() == 'addmembers':
                for member in params['members']:
                    cmds.append(
                        '{}set {}service-group {} static "{}"'.format(prefix, cmd_base, params['servicename'], member))
            elif params['action'].lower() == 'delmembers':
                for member in params['members']:
                    if params['servicetype'] in ['1', 'host']:
                        cmds.append(
                            '{}delete {}service-group {} static "{}"'.format(prefix, cmd_base, params['servicename'],
                                                                             member))
                    else:
                        cmds.append(
                            '{}delete {}service-group {} static "{}"'.format(prefix, cmd_base, params['servicename'],
                                                                             member))
            elif params['action'].lower() == 'comment':
                if params['servicetype'] in ['1', 'service']:
                    cmds.append('{}set {}service {} description "{}"'.format(prefix, cmd_base, params['servicename'],
                                                                             quote(params['comment'], safe='')))
                # else: # not supported for svc groups
                #    cmds.append('{}set {}service-group {} description "{}"'.format(prefix, cmd_base, params['servicename'], quote(params['comment'], safe='')))
            elif params['action'].lower() == 'tag':
                tags = '[ '
                for tag in params['tags']:
                    tags += tag + " "
                tags += ']'
                if params['servicetype'] in ['1', 'service']:
                    cmds.append('{}set {}service {} tag {}'.format(prefix, cmd_base, params['servicename'], tags))
                else:
                    cmds.append('{}set {}service-group {} tag {}'.format(prefix, cmd_base, params['servicename'], tags))
            elif params['action'].lower() == 'delete':
                if params['servicetype'] in ['1', 'service']:
                    cmds.append('{}delete {}service {}'.format(prefix, cmd_base, params['servicename']))
                elif params['servicetype'] in ['2', 'group']:
                    cmds.append('{}delete {}service-group {}'.format(prefix, cmd_base, params['servicename']))
            for cmd in cmds:
                log(cmd)
            return True
        else:
            return 'Unsupported syntax type: {} specified for Palo/Pano config'.format(syntax)
    else:
        pass
        ##return unknown firewall type
    return result


def create_rule_obj(target, session, apikey, fw_type, syntax, params, sw_objects=None):
    import urllib
    from urllib.parse import quote
    from xml.sax.saxutils import escape
    import json

    result = False
    if 'comment' in params and fw_type.lower() in ['palo', 'pano', 'paloalto'] and syntax.lower() in ['webui', 'api']:
        params['comment'] = escape(params['comment'])

    if syntax.lower() == 'cli':
        result = True
        if 'prefix' in params:
            prefix = params['prefix']
        else:
            prefix = '{}CLI:'.format(fw_type.upper())
    if fw_type == 'sonicwall':
        if syntax.lower() == 'cli':
            if params['polaction'] in ['1', 'drop', 'discard']:
                action = 'discard'
            elif params['polaction'] in ['2', 'allow', 'pass', 'accept']:
                action = 'allow'
            elif params['polaction'] in ['0', 'deny']:
                action = 'deny'
            log('{}access-rule from "{srczone}" to "{dstzone}" action "{action}" source address name {source} service {service} destination address name {destination}'.format(
                prefix, srczone=params['srczones'][0], dstzone=params['dstzones'][0], action=action,
                source=params['sources'][0], destination=params['dests'][0], service=params['services'][0]))
        elif syntax.lower() in ['webui', 'api']:
            if params['services'][0].lower() == 'any':
                service = ''
            else:
                service = params['services'][0]
            if params['srczones'][0].lower() == 'any':
                srczone = ''
            else:
                srczone = params['srczones'][0]
            if params['dstzones'][0].lower() == 'any':
                dstzone = ''
            else:
                dstzone = params['dstzones'][0]
            if params['sources'][0].lower() == 'any':
                source = ''
            else:
                source = params['sources'][0]
            if params['dests'][0].lower() == 'any':
                dest = ''
            else:
                dest = params['dests'][0]

            postdata = {'policyAction_-1': params['polaction'],
                        'policyEnabled_-1': '1',
                        'policySrcIf_-1': '4294967295',
                        'policyDstIf_-1': '4294967295',
                        'policySrcSvc_-1': '',
                        'policyDstSvc_-1': service,
                        'policySrcZone_-1': srczone,
                        'policyDstZone_-1': dstzone,
                        'policySrcNet_-1': source,
                        'policyDstNet_-1': dest,
                        'policyTime_-1': '',
                        'policyConnPercent_-1': '100',
                        'policyConnLmtSrcEnb_-1': '0',
                        'policyConnLmtDstEnb_-1': '0',
                        'policyConnLmtSrcThrhld_-1': '128',
                        'policyConnLmtDstThrhld_-1': '128',
                        'policyQosDscpAction_-1': '0',
                        'policyQosDscpTagValue_-1': '0',
                        'policyQosDscp8021pOverride_-1': '0',
                        'policyQos8021pAction_-1': '0',
                        'policyQos8021pTagValue_-1': '0',
                        'policyDefaultRule_-1': '1',
                        'policyInactivity_-1': '15',
                        'policyInactivityUdp_-1': '30',
                        'policyFrag_-1': '1',
                        'policyNetflow_-1': '0',
                        'policyGeoIpBlock_-1': '0',
                        'policyBotnetBlock_-1': '0',
                        'policyPktCap_-1': '0',
                        'policyNoSSO_-1': '0',
                        'policyNoSSOTrafficBlk_-1': '0',
                        'policyWhom_-1': '0',
                        'policyWhomExcl_-1': '0',
                        'policyComment_-1': params['comment'],
                        'policyLog_-1': '1',
                        'policyPriType_-1': '0',
                        'policyProps_-1': '0',
                        'policyManagement_-1': '0',
                        'policyBypassDpi_-1': '0',
                        'policyBwEnabled_-1': '0',
                        'policyBwPri_-1': '0',
                        'policyIbwEnabled_-1': '0',
                        'policyIbwPri_-1': '0',
                        'policyBwmDirectStyle_-1': '0',
                        'policyBwmEgrsEnable_-1': '0',
                        'policyBwmEgrsObj_-1': '',
                        'policyBwmIgrsEnable_-1': '0',
                        'policyBwmIgrsObj_-1': '',
                        'policyBwmTrackBw_-1': '0'
                        }
            url = 'https://' + target + '/main.cgi'
            result = send_sw_webcmd(session, url, postdata)
        else:
            return 'Unknown syntax "{}" specified for Sonicwall'.format(syntax)

    elif fw_type == 'sw65':
        if syntax.lower() == 'api':
            post_data = {'access_rule': {'ipv4': {
                # 'comment': '',
                # 'connection_limit': {'source': {}, 'destination': {}},
                # 'users': {'included': {'all': True}, 'excluded': {'none': True}},
                # 'logging': True,
                # 'botnet_filter': False,
                # 'udp': {'timeout': 30},
                'to': 'LAN',
                # 'h323': False,
                'destination': {},
                # 'uuid': 'b768308a-ff0f-9898-0700-c0eae4904a98',
                # 'priority': {'manual': 1},
                # 'sip': False,
                # 'tcp': {'urgent': False, 'timeout': 15},
                # 'geo_ip_filter': False,
                # 'schedule': {'always_on': True},
                # 'max_connections': 100,
                'action': 'drop',
                # 'dpi': True,
                # 'packet_monitoring': False,
                # 'management': True,
                # 'flow_reporting': False,
                'name': '',
                # 'quality_of_service': {'dscp': {'preserve': True}, 'class_of_service': {}},
                # 'fragments': True,
                'from': 'LAN',
                'enable': False,
                'source': {},
                # 'port': {'any': True}},
                # 'service': {'any': True},
                # 'dpi_ssl': {'server': True, 'client': True}
            }}}
            post_data['access_rule']['ipv4']['name'] = params['rulename']

            if params['polaction'].lower() in ['1', 'drop', 'discard']:
                post_data['access_rule']['ipv4']['action'] = 'discard'
            elif params['polaction'].lower() in ['2', 'allow', 'pass', 'accept']:
                post_data['access_rule']['ipv4']['action'] = 'allow'
            elif params['polaction'].lower() in ['0', 'deny']:
                post_data['access_rule']['ipv4']['action'] = 'deny'

            if params['enabled'].lower() in ['1', 'enable', 'enabled', True]:
                post_data['access_rule']['ipv4']['enable'] = True

            # log (params['services'])

            if params['services'][0].lower() in ['any', ['any']]:
                post_data['access_rule']['ipv4']['service'] = {'any': True}
            elif params['services'][0] in sw_objects['service_objects']:
                post_data['access_rule']['ipv4']['service'] = {'name': params['services'][0]}
            elif params['services'][0] in sw_objects['service_groups']:
                post_data['access_rule']['ipv4']['service'] = {'group': params['services'][0]}

            else:
                return (False, 'Bad Service specified')

            # log(post_data['access_rule']['ipv4']['service'])

            if params['srczones'][0].lower() in ['any', ['any']]:
                post_data['access_rule']['ipv4']['from'] = 'any'  # {'any': True}
            else:
                post_data['access_rule']['ipv4']['from'] = params['srczones'][0]

            if params['dstzones'][0].lower() in ['any', ['any']]:
                post_data['access_rule']['ipv4']['to'] = 'any'  # {'any': True}
            else:
                post_data['access_rule']['ipv4']['to'] = params['dstzones'][0]

            if params['sources'][0].lower() in ['any', ['any']]:
                post_data['access_rule']['ipv4']['source'] = {'address': {'any': True}}
            elif params['sources'][0] in sw_objects['address_objects']['ipv4']:
                post_data['access_rule']['ipv4']['source']['address'] = {'name': params['sources'][0]}
            elif params['sources'][0] in sw_objects['address_objects']['fqdn']:
                post_data['access_rule']['ipv4']['source']['address'] = {'fqdn': params['sources'][0]}
            elif params['sources'][0] in sw_objects['address_groups']['ipv4']:
                post_data['access_rule']['ipv4']['source']['address'] = {'group': params['sources'][0]}

            else:
                return (False, 'Bad Source(s) specified : {}'.format(params['sources'][0]))

            # 'destination': {'address': {'group': 'All Interface IPv6 Addresses'}}
            # 'destination': {'group': 'test_group'}
            if params['dests'][0].lower() in ['any', ['any']]:
                post_data['access_rule']['ipv4']['destination'] = {'address': {'any': True}}
            elif params['dests'][0] in sw_objects['address_objects']['ipv4']:
                post_data['access_rule']['ipv4']['destination']['address'] = {'name': params['dests'][0]}
            elif params['dests'][0] in sw_objects['address_objects']['fqdn']:
                post_data['access_rule']['ipv4']['destination']['address'] = {'fqdn': params['dests'][0]}
            elif params['dests'][0] in sw_objects['address_groups']['ipv4']:
                post_data['access_rule']['ipv4']['destination']['address'] = {'group': params['dests'][0]}
            elif params['dests'][0] in sw_objects['address_groups']['ipv6']:
                post_data['access_rule']['ipv4']['destination']['address'] = {'group': params['dests'][0]}
            else:
                log(sw_objects['address_objects']['fqdn'])
                return (False, 'Bad Destination(s) specified')

            if 'comment' in params:
                post_data['access_rule']['ipv4']['comment'] = params['comment']
            url = 'https://{}/api/sonicos/access-rules/ipv4'.format(target)
            debug(post_data)
            result = session.post(url=url, json=post_data)
            debug(result.text)
            if not json.loads(result.text)['status']['success']:
                result = False, json.loads(result.text)['status']['info'][0]['message']
            else:
                result = True

    elif fw_type == 'checkpoint':

        import numpy, copy

        if syntax.lower() == 'cli':
            lastindex = None
            for context in contexts:
                if config[context]['config']['fw_type'] == 'checkpoint':
                    if params['policyname'] in config[context]['config']['policylen']:
                        lastindex = copy.deepcopy(config[context]['config']['policylen'][params['policyname']])
                        config[context]['config']['policylen'][params['policyname']] = \
                        config[context]['config']['policylen'][params['policyname']] + 1
                        debug('lastindex', lastindex)
                        break
                    else:
                        debug('Policy not found')
                        return False
            if lastindex:
                log('{}addelement fw_policies {} rule security_rule'.format(prefix, params['policyname']))
                if 'comment' not in params: params['comment'] = ''
                log('{}modify fw_policies {} rule:{}:comments "{}"'.format(prefix, params['policyname'], lastindex,
                                                                           params['comment']))
                if 'disabled' in params:
                    disabled = 'true'
                else:
                    disabled = 'false'
                log('{}modify fw_policies {} rule:{}:disabled {}'.format(prefix, params['policyname'], lastindex,
                                                                         disabled))
                if params['polaction'].lower() in ['allow', 'pass', 'accept', '2']:
                    polaction == 'accept_action:accept'
                elif params['polaction'].lower() in ['deny', '0']:
                    polaction = 'drop_action:deny'
                elif params['polaction'].lower() in ['drop', 'discard', '1']:
                    polaction = 'drop_action:drop'
                log('{}addelement fw_policies {} rule:{}:action {}'.format(prefix, params['policyname'], lastindex,
                                                                           polaction))
                for member in params['sources']:
                    if member.lower() == 'any':
                        table = 'globals'
                        member = 'Any'
                    else:
                        table = 'network_objects'
                    log("{}addelement fw_policies {} rule:{}:src:'' {}:{}".format(prefix, params['policyname'],
                                                                                  lastindex, table, member))
                for member in params['dests']:
                    if member.lower() == 'any':
                        table = 'globals'
                        member = 'Any'
                    else:
                        table = 'network_objects'
                    log("{}addelement fw_policies {} rule:{}:dst:'' {}:{}".format(prefix, params['policyname'],
                                                                                  lastindex, table, member))
                for member in params['services']:
                    if member.lower() == 'any':
                        table = 'globals'
                        member = 'Any'
                    else:
                        table = 'services'
                    log("{}addelement fw_policies {} rule:{}:services:'' {}:{}".format(prefix, params['policyname'],
                                                                                       lastindex, table, member))
            else:
                debug('No checkpoint configuration found')
                return False
    elif fw_type in ['palo', 'pano', 'paloalto']:
        if syntax.lower() in ['webui', 'api']:
            if fw_type in ['palo', 'paloalto']:
                object_base = "/config/devices/entry[@name='localhost.localdomain']/vsys/entry[@name='vsys1']/rulebase/security/rules"
            elif fw_type == 'pano':
                if params['context'] == 'shared':
                    object_base = "/config/shared/pre-rulebase/security/rules"
                else:
                    object_base = "/config/devices/entry[@name='localhost.localdomain']/device-group/entry[@name='{}']/pre-rulebase/security/rules".format(
                        params['context'])
            srczones = ''
            dstzones = ''
            srcaddr = ''
            dstaddr = ''
            services = ''
            tags = ''
            disabled = 'no'
            description = ''
            action = 'drop'
            applications = ''
            negate_source = 'no'
            negate_destination = 'no'
            profile_setting = ''  ## this has to be set with keyword included
            log_setting = ''  ## this has to be set with keyword included
            log_start = 'no'
            log_end = 'yes'
            if 'srczones' in params:
                for member in params['srczones']:
                    if member.lower() == 'any':
                        srczones += '<member>any</member>'
                        break
                    else:
                        srczones += '<member>{}</member>'.format(member)
            if 'dstzones' in params:
                for member in params['dstzones']:
                    if member.lower() == 'any':
                        dstzones += '<member>any</member>'
                        break
                    else:
                        dstzones += '<member>{}</member>'.format(member)
            if 'sources' in params:
                for member in params['sources']:
                    if member.lower() == 'any':
                        srcaddr += '<member>any</member>'
                        break
                    else:
                        srcaddr += '<member>{}</member>'.format(member)
            if 'dests' in params:
                for member in params['dests']:
                    if member.lower() == 'any':
                        dstaddr += '<member>any</member>'
                        break
                    else:
                        dstaddr += '<member>{}</member>'.format(member)
            if 'services' in params:
                for member in params['services']:
                    if member.lower() == 'any':
                        services += '<member>any</member>'
                        break
                    else:
                        services += '<member>{}</member>'.format(member)
            if 'tags' in params:
                for member in params['tags']:
                    tags += '<member>{}</member>'.format(member)
            if 'applications' in params:
                for member in params['applications']:
                    if member.lower() == 'any':
                        applications += '<member>any</member>'
                        break
                    else:
                        applications += '<member>{}</member>'.format(member)
            if 'comment' in params:
                description = params['comment']
            elif 'description' in params:
                description = params['description']

            if 'polaction' in params:
                if params['polaction'].lower() in ['allow', 'deny', 'drop', 'reset-both', 'reset-client',
                                                   'reset-server']:
                    action = params['polaction'].lower()
                elif params['polaction'].lower() in ['deny', '0']:
                    action = 'deny'
                elif params['polaction'].lower() in ['drop', 'discard', '1']:
                    action = 'drop'
                elif params['polaction'].lower() in ['allow', 'pass', 'accept', '2']:
                    action = 'allow'

            if 'log_end' in params:
                if str(params['log_end']).lower() in ['', 'true', 'yes', 'on', 'enabled', 'enable']:
                    log_end = 'yes'
                else:
                    log_end = 'no'
            if 'log_start' in params:
                if str(params['log_start']).lower() in ['', 'true', 'yes', 'on', 'enabled', 'enable']:
                    log_start = 'yes'
                else:
                    log_start = 'no'
            if 'negate_source' in params:
                if str(params['negate_source']).lower() in ['', 'true', 'yes', 'on', 'enabled', 'enable']:
                    negate_source = 'yes'
                else:
                    negate_source = 'no'
            if 'negate_destination' in params:
                if str(params['negate_destination']).lower() in ['', 'true', 'yes', 'on', 'enabled', 'enable']:
                    negate_destination = 'yes'
                else:
                    negate_destination = 'no'

            if 'disabled' in params:
                if str(params['disabled']).lower() in ['', 'true', 'yes', 'on', 'enabled', 'enable']:
                    disabled = 'yes'
                else:
                    disabled = 'no'
            if 'enabled' in params:
                if str(params['enabled']).lower() in ['', 'true', 'yes', 'on', 'enabled', 'enable']:
                    disabled = 'no'
                else:
                    disabled = 'yes'
            if 'profile_setting' in params:
                profile_setting = ' profile-setting {}'.format(params['profile-setting'])
            if 'log_setting' in params:
                profile_setting = ' log-setting {}'.format(params['log-setting'])

            url = '/api/?type=config&action=set&xpath={}&element=<entry name=\'{}\'><source>{}</source><destination>{}</destination><service>{}</service><application>{}</application><action>{}</action><log-end>{}</log-end><log-start>{}</log-start><from>{}</from><to>{}</to><disabled>{}</disabled><description>{}</description></entry>'.format(
                object_base, params['rulename'], srcaddr, dstaddr, services, applications, action, log_end, log_start,
                srczones, dstzones, disabled, description)
            # url='/api/?type=config&action=set&xpath={}&element=<entry name=\'{}\'><source>{}</source><destination>{}</destination><service>{}</service><application>{}</application><action>{}</action><log-end>{}</log-end><log-start>{}</log-start><from>{}</from><to>{}</to></entry>'.format(object_base, params['rulename'], srcaddr, dstaddr, services, applications, action, log_end, log_start, srczones, dstzones)
            result = send_palo_apicmd(session, target, url, apikey)

        elif syntax.lower() == 'cli':
            if fw_type.lower() in ['palo', 'paloalto']:
                cmd_base = 'rulebase'
            elif fw_type.lower() == 'pano':
                if params['context'] == 'shared':
                    cmd_base = 'shared pre-rulebase'
                else:
                    cmd_base = 'device-group "{}" pre-rulebase'.format(params['context'])
            ## set default values
            srczones = '['
            dstzones = '['
            srcaddr = '['
            dstaddr = '['
            services = '['
            tags = '['
            disabled = 'no'
            description = ''
            action = 'drop'
            applications = '[ any'
            negate_source = 'no'
            negate_destination = 'no'
            profile_setting = ''  ## this has to be set with keyword included
            log_setting = ''  ## this has to be set with keyword included
            log_start = 'no'
            log_end = 'yes'

            if 'srczones' in params:
                for member in params['srczones']:
                    if member.lower() == 'any':
                        srczones += ' any'
                        break
                    else:
                        srczones += ' {}'.format(member)
            srczones += ' ]'
            if 'dstzones' in params:
                for member in params['dstzones']:
                    if member.lower() == 'any':
                        dstzones += ' any'
                        break
                    else:
                        dstzones += ' {}'.format(member)
            dstzones += ' ]'

            if 'sources' in params:
                for member in params['sources']:
                    if member.lower() == 'any':
                        srcaddr += ' any'
                        break
                    else:
                        srcaddr += ' {}'.format(member)
            srcaddr += ' ]'
            if 'dests' in params:
                for member in params['dests']:
                    if member.lower() == 'any':
                        dstaddr += ' any'
                        break
                    else:
                        dstaddr += ' {}'.format(member)
            dstaddr += ' ]'
            if 'services' in params:
                for member in params['services']:
                    if member.lower() == 'any':
                        services += ' any'
                        break
                    else:
                        services += ' {}'.format(member)
            services += ' ]'
            if 'tags' in params:
                for member in params['tags']:
                    if member.lower() == 'any':
                        tags += ' any'
                        break
                    else:
                        tags += ' {}'.format(member)
            tags += ' ]'
            if 'applications' in params:
                applications = '['
                for member in params['applications']:
                    if member.lower() == 'any':
                        applications += ' any'
                        break
                    else:
                        applications += ' {}'.format(member)
            applications += ' ]'
            if 'polaction' in params:
                if params['polaction'].lower() in ['allow', 'deny', 'drop', 'reset-both', 'reset-client',
                                                   'reset-server']:
                    action = params['polaction'].lower()
                elif params['polaction'].lower() in ['deny', '0']:
                    action = 'deny'
                elif params['polaction'].lower() in ['drop', 'discard', '1']:
                    action = 'drop'
                elif params['polaction'].lower() in ['allow', 'pass', 'accept', '2']:
                    action = 'allow'

            if 'log_end' in params:
                if str(params['log_end']).lower() in ['', 'true', 'yes', 'on', 'enabled', 'enable']:
                    log_end = 'yes'
                else:
                    log_end = 'no'
            if 'log_start' in params:
                if str(params['log_start']).lower() in ['', 'true', 'yes', 'on', 'enabled', 'enable']:
                    log_start = 'yes'
                else:
                    log_start = 'no'
            if 'negate_source' in params:
                if str(params['negate_source']).lower() in ['', 'true', 'yes', 'on', 'enabled', 'enable']:
                    negate_source = 'yes'
                else:
                    negate_source = 'no'
            if 'negate_destination' in params:
                if str(params['negate_destination']).lower() in ['', 'true', 'yes', 'on', 'enabled', 'enable']:
                    negate_destination = 'yes'
                else:
                    negate_destination = 'no'

            if 'disabled' in params:
                if str(params['disabled']).lower() in ['', 'true', 'yes', 'on', 'enabled', 'enable']:
                    disabled = 'yes'
                else:
                    disabled = 'no'
            if 'enabled' in params:
                if str(params['enabled']).lower() in ['', 'true', 'yes', 'on', 'enabled', 'enable']:
                    disabled = 'no'
                else:
                    disabled = 'yes'
            if 'profile_setting' in params:
                profile_setting = ' profile-setting {}'.format(params['profile-setting'])
            if 'log_setting' in params:
                profile_setting = ' log-setting {}'.format(params['log-setting'])

            cmd = '{}set {} security rules "{}" from {} to {} action {} source {} destination {} log-end {} log-start {} service {} application {} tag {} description "{}" disabled {} negate-source {} negate-destination {} {} {}'.format(
                prefix, cmd_base, params['rulename'], srczones, dstzones, action, srcaddr, dstaddr, log_end, log_start,
                services, applications, tags, description, disabled, negate_source, negate_destination, log_setting,
                profile_setting)
            log(cmd)
    return result


def modify_rule_obj(target, session, apikey, fw_type, syntax, params, sw_objects=None):
    import urllib
    from collections import defaultdict, OrderedDict
    from urllib.parse import quote
    from xml.sax.saxutils import escape
    import json

    result = False

    if 'comment' in params and fw_type.lower() in ['palo', 'pano', 'paloalto'] and syntax.lower() in ['webui', 'api']:
        debug(params['comment'])
        params['comment'] = escape(params['comment'])
        debug(params['comment'])

    if syntax.lower() == 'cli':
        result = True
        if 'prefix' in params:
            prefix = params['prefix']
        else:
            prefix = '{}CLI:'.format(fw_type.upper())

    ## actions is a set of action, value

    if fw_type == 'sonicwall':
        if syntax.lower() == 'cli':
            # rule_cmd=
            ## source, dest, comment, action, priority
            if params['action'].lower() == 'comment':
                log('{}access-rule from "{srczone}" to "{dstzone}" action "{action}" source address {source} service {service} destination address {destination}'.format(
                    prefix, srczone=params['srczones'][0], dstzone=params['dstzones'][0], action=params['polaction'],
                    source=params['sources'][0], destination=params['dests'][0], service=params['services'][0]))
                log('{}comment "{}"'.format(prefix, params['comment']))
                log('{}exit'.format(prefix))
            elif params['action'].lower() == 'delete':
                log('{}no access-rule from "{srczone}" to "{dstzone}" action "{action}" source address {source} service {service} destination address {destination}'.format(
                    prefix, srczone=params['srczones'][0], dstzone=params['dstzones'][0], action=params['polaction'],
                    source=params['sources'][0], destination=params['dests'][0], service=params['services'][0]))
            elif params['action'].lower() == 'enable':
                log('{}access-rule from "{srczone}" to "{dstzone}" action "{action}" source address {source} service {service} destination address {destination}'.format(
                    prefix, srczone=params['srczones'][0], dstzone=params['dstzones'][0], action=params['polaction'],
                    source=params['sources'][0], destination=params['dests'][0], service=params['services'][0]))
                log('{}enable'.format(prefix))
                log('{}exit'.format(prefix))
            elif params['action'].lower() == 'disable':
                log('{}access-rule from "{srczone}" to "{dstzone}" action "{action}" source address {source} service {service} destination address {destination}'.format(
                    prefix, srczone=params['srczones'][0], dstzone=params['dstzones'][0], action=params['polaction'],
                    source=params['sources'][0], destination=params['dests'][0], service=params['services'][0]))
                log('{}no enable'.format(prefix))
                log('{}exit'.format(prefix))
        elif syntax.lower() in ['webui', 'api']:
            if params['action'].lower() == 'delmembers':
                pass  # not supported
            elif params['action'].lower() == 'addmembers':
                pass  # not supported
            elif params['action'].lower() == 'comment':
                '''
                from bs4 import BeautifulSoup
                response=session.get('https://' + target + '/ruleTable_1_2.html')
                print(response.text)
                soup = BeautifulSoup(response.text, 'lxml')
                csrftoken = soup.find('input', dict(name='csrfToken'))['value']
                print(csrftoken)

                postdata=OrderedDict({  
                            'csrfToken': csrftoken,
                            'cgiaction': '',
                            'iSTStartItem': '1',
                            'enableRule_0_0': 'on',
                            'enableRule_0_1': 'on',
                            'error_page': 'ruleTable_1_2.html',
                            'refresh_page': 'ruleTable_1_2.html',
                            'policyAction_-2': params['polaction'],
                            'policyEnabled_-2': '1',                            
                            'policySrcIf_-2': '4294967295',
                            'policyDstIf_-2': '4294967295',
                            'policySrcSvc_-2': '',
                            'policyDstSvc_-2': params['service'],
                            'policySrcZone_-2': params['srczone'],
                            'policyDstZone_-2': params['dstzone'],
                            'policySrcNet_-2': params['source'],
                            'policyDstNet_-2': params['dest'],
                            'policyTime_-2': '',
                            'policyConnPercent_-2': '100',
                            'policyConnLmtSrcEnb_-2': '0',
                            'policyConnLmtDstEnb_-2': '0',
                            'policyConnLmtSrcThrhld_-2': '128',
                            'policyConnLmtDstThrhld_-2': '128',
                            'policyQosDscpAction_-2': '0',
                            'policyQosDscpTagValue_-2': '0',
                            'policyQosDscp8021pOverride_-2': '0',
                            'policyQos8021pAction_-2': '0',
                            'policyQos8021pTagValue_-2': '0',
                            'policyDefaultRule_-2': '1',
                            'policyInactivity_-2': '15',
                            'policyInactivityUdp_-2': '30',
                            'policyFrag_-2': '1',
                            'policyNetflow_-2': '0',
                            'policyGeoIpBlock_-2': '0',
                            'policyBotnetBlock_-2': '0',
                            'policyPktCap_-2': '0',
                            'policyNoSSO_-2': '0',
                            'policyNoSSOTrafficBlk_-2': '0',
                            'policyWhom_-2': '0',
                            'policyWhomExcl_-2': '0',
                            'policyComment_-2': 'meow2',
                            'policyLog_-2': '1',
                            'policyPriType_-2': '0',
                            'policyProps_-2': '0',
                            'policyManagement_-2': '0',
                            'policyBypassDpi_-2': '0',
                            'policyBwEnabled_-2': '0',
                            'policyBwPri_-2': '0',
                            'policyIbwEnabled_-2': '0',
                            'policyIbwPri_-2': '0',
                            'policyBwmDirectStyle_-2': '0',
                            'policyBwmEgrsEnable_-2': '0',
                            'policyBwmEgrsObj_-2': '',
                            'policyBwmIgrsEnable_-2': '0',
                            'policyBwmIgrsObj_-2': '',
                            'policyBwmTrackBw_-2': '0',

                            'policyAction_1': params['polaction'],
                            'policyEnabled_1': '1',                            
                            'policySrcIf_1': '4294967295',
                            'policyDstIf_1': '4294967295',
                            'policySrcSvc_1': '',
                            'policyDstSvc_1': params['service'],
                            'policySrcZone_1': params['srczone'],
                            'policyDstZone_1': params['dstzone'],
                            'policySrcNet_1': params['source'],
                            'policyDstNet_1': params['dest'],
                            'policyComment_1': params['comment'],
                            'policyTime_1': '',
                            'policyConnPercent_1': '100',
                            'policyConnLmtSrcEnb_1': '0',
                            'policyConnLmtDstEnb_1': '0',
                            'policyConnLmtSrcThrhld_1': '128',
                            'policyConnLmtDstThrhld_1': '128',
                            'policyQosDscpAction_1': '0',
                            'policyQosDscpTagValue_1': '0',
                            'policyQosDscp8021pOverride_1': '0',
                            'policyQos8021pAction_1': '0',
                            'policyQos8021pTagValue_1': '0',
                            'policyDefaultRule_1': '1',
                            'policyInactivity_1': '15',
                            'policyInactivityUdp_1': '30',
                            'policyFrag_1': '1',
                            'policyNetflow_1': '0',
                            'policyGeoIpBlock_1': '0',
                            'policyBotnetBlock_1': '0',
                            'policyPktCap_1': '0',
                            'policyNoSSO_1': '0',
                            'policyNoSSOTrafficBlk_1': '0',
                            'policyWhom_1': '0',
                            'policyWhomExcl_1': '0',
                            'policyLog_1': '1',
                            'policyPriType_1': '0',
                            'policyProps_1': '0',
                            'policyManagement_1': '0',
                            'policyBypassDpi_1': '0',
                            'policyBwEnabled_1': '0',
                            'policyBwPri_1': '0',
                            'policyIbwEnabled_1': '0',
                            'policyIbwPri_1': '0',
                            'policyBwmDirectStyle_1': '0',
                            'policyBwmEgrsEnable_1': '0',
                            'policyBwmEgrsObj_1': '',
                            'policyBwmIgrsEnable_1': '0',
                            'policyBwmIgrsObj_1': '',
                            'policyBwmTrackBw_1': '0'
                        })
                for data in postdata:
                    debug ('{} : {}'.format(data,postdata[data]))
                response=session.get('https://' + target + '/wait2.html')
                url='https://' + target + '/main.cgi'
                result=send_sw_webcmd(session, url, postdata)
                print(session.headers)
                dir(session)
                '''
            elif params['action'].lower() == 'enable':
                pass  # have not been unable to get this to work properly
            elif params['action'].lower() == 'disable':
                # pass # have not been unable to get this to work properly

                '''
                ## -2 old values
                ## 1 new values
                from bs4 import BeautifulSoup
                session.get('https://' + target + '/ruleTable.html')
                session.get('https://' + target + '/rulesMatrixView.html')
                session.get('https://' + target + '/ruleTable_SRC1_DST2_IPVER0.html')
                response=session.get('https://10.215.16.60/ruleTable_1_2.html?sortCol=3&sortInverted=0')
                print(response.text)
                soup = BeautifulSoup(response.text, 'lxml')
                csrftoken = soup.find('input', dict(name='csrfToken'))['value']
                print(csrftoken)

                postdata=OrderedDict({
                            'csrfToken': csrftoken,
                            'cgiaction': 'none',
                            'enableRule_0_0': 'on',
                            'enableRule_0_1': 'on',
                            'policyAction_-2': params['polaction'],
                            'policySrcIf_-2': '4294967295',
                            'policyDstIf_-2': '4294967295',
                            'policySrcSvc_-2': '',
                            'policyDstSvc_-2': params['service'],
                            'policySrcZone_-2': params['srczone'],
                            'policyDstZone_-2': params['dstzone'],
                            'policySrcNet_-2': params['source'],
                            'policyDstNet_-2': params['dest'],

                            'policyAction_1': params['polaction'],
                            'policySrcIf_1': '4294967295',
                            'policyDstIf_1': '4294967295',
                            'policySrcSvc_1': '',
                            'policyDstSvc_1': params['service'],
                            'policySrcZone_1': params['srczone'],
                            'policyDstZone_1': params['dstzone'],
                            'policySrcNet_1': params['source'],
                            'policyDstNet_1': params['dest'],
                            'policyEnabled_1': '1',  
                        })        
                for data in postdata:
                    debug ('{} : {}'.format(data,postdata[data]))
                session.get('https://' + target + '/ruleTable.html')
                session.get('https://' + target + '/rulesMatrixView.html')
                session.get('https://' + target + '/ruleTable_SRC1_DST2_IPVER0.html')
                session.get('https://10.215.16.60/ruleTable_1_2.html?sortCol=3&sortInverted=0')

                url='https://' + target + '/main.cgi'
                result=send_sw_webcmd(session, url, postdata)
                print(session.headers)
                i=session.cookies
                for cookie in i.items():
                    print(cookie)
                #dir(session)
                '''

            elif params['action'].lower() == 'delete':
                if params['services'][0].lower() in ['any', ['any']]:
                    service = ''
                else:
                    service = params['services'][0]
                if params['srczones'][0].lower() in ['any', ['any']]:
                    srczone = ''
                else:
                    srczone = params['srczones'][0]
                if params['dstzones'][0].lower() in ['any', ['any']]:
                    dstzone = ''
                else:
                    dstzone = params['dstzones'][0]
                if params['sources'][0].lower() in ['any', ['any']]:
                    source = ''
                else:
                    source = params['sources'][0]
                if params['dests'][0].lower() in ['any', ['any']]:
                    dest = ''
                else:
                    dest = params['dests'][0]
                postdata = {'policyAction_-3': params['polaction'],
                            'policySrcIf_-3': '4294967295',
                            'policyDstIf_-3': '4294967295',
                            'policySrcSvc_-3': '',
                            'policyDstSvc_-3': service,
                            'policySrcZone_-3': srczone,
                            'policyDstZone_-3': dstzone,
                            'policySrcNet_-3': source,
                            'policyDstNet_-3': dest
                            }
                url = 'https://' + target + '/main.cgi'
                result = send_sw_webcmd(session, url, postdata)
        else:
            return 'Unknown syntax "{}" specified for Sonicwall'.format(syntax)

    elif fw_type == 'sw65':
        debug(params)
        if syntax.lower() == 'api':
            if 'uuid' in params:
                post_data = {'access_rule': {'ipv4': {}}}
            else:
                post_data = {'access_rule': {'ipv4': {
                    # 'comment': 'API Added default comment',
                    # 'connection_limit': {'source': {}, 'destination': {}},
                    # 'users': {'included': {'all': True}, 'excluded': {'none': True}},
                    # 'logging': True,
                    # 'botnet_filter': False,
                    # 'udp': {'timeout': 30},
                    ###     'to': 'LAN',
                    # 'h323': False,
                    ###     'destination': {'address': {'any': True}},
                    # 'uuid': 'b768308a-ff0f-9898-0700-c0eae4904a98',
                    # 'priority': {'manual': 1},
                    # 'sip': False,
                    # 'tcp': {'urgent': False, 'timeout': 15},
                    # 'geo_ip_filter': False,
                    # 'schedule': {'always_on': True},
                    # 'max_connections': 100,
                    # 'action': 'drop',
                    # 'dpi': True,
                    # 'packet_monitoring': False,
                    # 'management': True,
                    # 'flow_reporting': False,
                    # 'name': '',
                    # 'quality_of_service': {'dscp': {'preserve': True}, 'class_of_service': {}},
                    # 'fragments': True,
                    ###     'from': 'LAN',
                    # 'enable': False,
                    ###     'source': {'address': {'any': True}},
                    # 'port': {'any': True}},
                    ###     'service': {'any': True},
                    # 'dpi_ssl': {'server': True, 'client': True}
                }}}

            ## if modifying rule without UUID, only a few params can be changed - comment, tcp urgent, logging, enabled
            if params['action'].lower() == 'comment':
                post_data['access_rule']['ipv4']['comment'] = "'{}'".format(params['comment'])

            elif params['action'].lower() == 'logging':
                if str(params['logging']).lower() in ['1', 'yes', 'enable', 'enabled', 'true']:
                    post_data['access_rule']['ipv4']['logging'] = True
                else:
                    post_data['access_rule']['ipv4']['logging'] = False

            elif params['action'].lower() in ['enable']:
                post_data['access_rule']['ipv4']['enable'] = True
            elif params['action'].lower() in ['disable']:
                post_data['access_rule']['ipv4']['enable'] = False

            if params['action'].lower() in ['delete', 'comment', 'logging', 'enable',
                                            'disable'] and 'uuid' not in params:
                if params['services'][0].lower() in ['any', ['any']]:
                    post_data['access_rule']['ipv4']['service'] = {'any': True}
                else:
                    if params['services'][0] in sw_objects['service_objects']['ipv4']:
                        post_data['access_rule']['ipv4']['service'] = {'name': params['services'][0]}
                    elif params['services'][0] in sw_objects['service_groups']['ipv4']:
                        post_data['access_rule']['ipv4']['service'] = {'group': params['services'][0]}

                if params['srczones'][0].lower() in ['any', ['any']]:
                    post_data['access_rule']['ipv4']['from'] = 'any'  # {'address': {'any': True}}
                else:
                    post_data['access_rule']['ipv4']['from'] = params['srczones'][0]

                if params['dstzones'][0].lower() in ['any', ['any']]:
                    post_data['access_rule']['ipv4']['to'] = 'any'  # {'address': {'any': True}}
                else:
                    post_data['access_rule']['ipv4']['to'] = params['dstzones'][0]

                if params['sources'][0].lower() in ['any', ['any']]:
                    post_data['access_rule']['ipv4']['source'] = {'address': {'any': True}}
                else:
                    if params['sources'][0] in sw_objects['address_objects']['ipv4']:
                        post_data['access_rule']['ipv4']['source'] = {'address': {'name': params['sources'][0]}}
                    elif params['sources'][0] in sw_objects['address_groups']['ipv4']:
                        post_data['access_rule']['ipv4']['source'] = {'address': {'group': params['sources'][0]}}

                if params['dests'][0].lower() in ['any', ['any']]:
                    post_data['access_rule']['ipv4']['destination'] = {'address': {'any': True}}
                else:
                    if params['dests'][0] in sw_objects['address_objects']['ipv4']:
                        post_data['access_rule']['ipv4']['destination'] = {'address': {'name': params['dests'][0]}}
                    elif params['dests'][0] in sw_objects['address_groups']['ipv4']:
                        post_data['access_rule']['ipv4']['destination'] = {'address': {'group': params['dests'][0]}}

                if params['polaction'].lower() in ['1', 'drop', 'discard']:
                    post_data['access_rule']['ipv4']['action'] = 'discard'
                elif params['polaction'].lower() in ['2', 'allow', 'pass', 'accept']:
                    post_data['access_rule']['ipv4']['action'] = 'allow'
                elif params['polaction'].lower() in ['0', 'deny']:
                    post_data['access_rule']['ipv4']['action'] = 'deny'

            if 'uuid' in params:

                if params['action'].lower() == 'enable':
                    post_data['access_rule']['ipv4']['enable'] = True
                elif params['action'].lower() == 'disable':
                    post_data['access_rule']['ipv4']['enable'] = False

                if 'polaction' in params:
                    if params['polaction'].lower() in ['1', 'drop', 'discard']:
                        post_data['access_rule']['ipv4']['action'] = 'discard'
                    elif params['polaction'].lower() in ['2', 'allow', 'pass', 'accept']:
                        post_data['access_rule']['ipv4']['action'] = 'allow'
                    elif params['polaction'].lower() in ['0', 'deny']:
                        post_data['access_rule']['ipv4']['action'] = 'deny'

                # if 'enabled' in params:
                #    if params['enabled'].lower() in ['1', 'enable', 'enabled', True]:
                #        post_data['access_rule']['ipv4']['enable'] = True

                if 'services' in params:
                    if params['services'][0].lower() in ['any', ['any']]:
                        post_data['access_rule']['ipv4']['service'] = {'any': True}
                    elif params['services'][0] in sw_objects['service_objects']:
                        post_data['access_rule']['ipv4']['service'] = {'name': params['services'][0]}
                    elif params['services'][0] in sw_objects['service_groups']:
                        post_data['access_rule']['ipv4']['service'] = {'group': params['services'][0]}

                if 'srczones' in params:
                    if params['srczones'][0].lower() in ['any', ['any']]:
                        post_data['access_rule']['ipv4']['from'] = 'any'  # {'any': True}
                    else:
                        post_data['access_rule']['ipv4']['from'] = params['srczones'][0]

                if 'dstzones' in params:
                    if params['dstzones'][0].lower() in ['any', ['any']]:
                        post_data['access_rule']['ipv4']['to'] = 'any'  # {'any': True}
                    else:
                        post_data['access_rule']['ipv4']['to'] = params['dstzones'][0]

                if 'sources' in params:
                    if params['sources'][0].lower() in ['any', ['any']]:
                        post_data['access_rule']['ipv4']['source'] = {}
                        post_data['access_rule']['ipv4']['source'] = {'address': {'any': True}}
                    elif params['sources'][0] in sw_objects['address_objects']['ipv4']:
                        post_data['access_rule']['ipv4']['source'] = {}
                        post_data['access_rule']['ipv4']['source'] = {}['address'] = {'name': params['sources'][0]}
                    elif params['sources'][0] in sw_objects['address_groups']['ipv4']:
                        post_data['access_rule']['ipv4']['source'] = {}
                        post_data['access_rule']['ipv4']['source']['address'] = {'group': params['sources'][0]}

                if 'dests' in params:
                    # 'destination': {'address': {'group': 'All Interface IPv6 Addresses'}}
                    # 'destination': {'group': 'test_group'}
                    if params['dests'][0].lower() in ['any', ['any']]:
                        post_data['access_rule']['ipv4']['destination'] = {}
                        post_data['access_rule']['ipv4']['destination'] = {'address': {'any': True}}
                    elif params['dests'][0] in sw_objects['address_objects']['ipv4']:
                        post_data['access_rule']['ipv4']['destination'] = {}
                        post_data['access_rule']['ipv4']['destination']['address'] = {'name': params['dests'][0]}
                    elif params['dests'][0] in sw_objects['address_groups']['ipv4']:
                        post_data['access_rule']['ipv4']['destination'] = {}
                        post_data['access_rule']['ipv4']['destination']['address'] = {'group': params['dests'][0]}
            if 'uuid' in params:
                url = 'https://{}/api/sonicos/access-rules/ipv4/uuid/{}'.format(target, params['uuid'])
            else:
                url = 'https://{}/api/sonicos/access-rules/ipv4'.format(target)
            debug(url, post_data)
            if params['action'].lower() in ['delete', 'delmembers']:
                result = session.delete(url=url, json=post_data)
            else:
                result = session.put(url=url, json=post_data)

            debug(result.text)
            if not json.loads(result.text)['status']['success']:
                result = False, json.loads(result.text)['status']['info'][0]['message']
            else:
                result = True

    elif fw_type == 'checkpoint':
        # for source, action in source_actions:
        # for action, value, param in actions:

        if syntax.lower() == 'cli':
            if params['action'].lower() == 'delmembers':
                command = 'rmelement'
            elif params['action'].lower() == 'addmembers':
                command = 'addelement'
            elif params['action'].lower() == 'comment':
                command = 'modify'
            elif params['action'].lower() == 'enable':
                command = 'modify'
                value = 'false'
            elif params['action'].lower() == 'disable':
                command = 'modify'
                value = 'true'
            if params['action'].lower() in ['delmembers', 'addmembers']:
                if 'sources' in params:
                    for member in params['sources']:
                        if member.lower() == 'any':
                            table = 'globals'
                            member = 'Any'
                        else:
                            table = 'network_objects'
                        log('{}{} fw_policies {} rule:{}:{}:\'\' {}:{}'.format(prefix, command, params['policyname'],
                                                                               params['policynum'], 'src', table,
                                                                               member))
                if 'dests' in params:
                    for member in params['dests']:
                        if member.lower() == 'any':
                            table = 'globals'
                            member = 'Any'
                        else:
                            table = 'network_objects'
                        log('{}{} fw_policies {} rule:{}:{}:\'\' {}:{}'.format(prefix, command, params['policyname'],
                                                                               params['policynum'], 'dst', table,
                                                                               member))
            elif params['action'].lower() == 'comment':
                log('{}{} fw_policies {} rule:{}:comments "{}"'.format(prefix, command, params['policyname'],
                                                                       params['policynum'], params['comment']))
            elif params['action'].lower() in ['enable', 'disable']:
                log('{}modify fw_policies {} rule:{}:disabled {}'.format(prefix, params['policyname'],
                                                                         params['policynum'], value))
            elif params['action'].lower() in ['delete']:
                log('{}rmbyindex fw_policies {} rule {}'.format(prefix, params['policyname'], params['policynum']))
            else:
                return 'Unknown Action'

            '''
            for service, action in service_actions:
                if service.lower()=='Any':
                    serviceprefix='globals'
                else:
                    serviceprefix='network_objects'
                if action.lower()=='add':
                    log('DBEDIT:addelement fw_policies ##{} rule:{}:services:'' {}:{}'.format(context, rulenum, serviceprefix, service))
                elif action.lower() == 'del':
                    log('DBEDIT:rmelement fw_policies ##{} rule:{}:services:'' {}:{}'.format(context, rulenum, serviceprefix, service))
                else:
                    return 'Unknown Action'
                    ## return unknown action type
            '''
        if syntax.lower() == 'api':
            pass
            '''
            if params['action'].lower()=='delmembers':
                command='rmelement'
            elif params['action'].lower()=='addmembers':
                command='addelement'
            elif params['action'].lower() == 'comment':
                command='modify'
            elif params['action'].lower() == 'enable':   
                command='modify'
                value='false'
            elif params['action'].lower() == 'disable':   
                command='modify'
                value='true'
            if params['action'].lower() in ['delmembers', 'addmembers']:
                if 'sources' in params:
                    for member in params['sources']:
                        if member.lower()=='any':
                            table='globals'
                            member='Any'
                        else:
                            table='network_objects'
                        log('{}{} fw_policies {} rule:{}:{}:\'\' {}:{}'.format(prefix, command, params['policyname'], params['policynum'], 'src', table, member))
                if 'dests' in params:
                    for member in params['dests']:
                        if member.lower()=='any':
                            table='globals'
                            member='Any'
                        else:
                            table='network_objects'
                        log('{}{} fw_policies {} rule:{}:{}:\'\' {}:{}'.format(prefix, command, params['policyname'], params['policynum'], 'dst', table, member))
            elif params['action'].lower() == 'comment':
                log('{}{} fw_policies {} rule:{}:comments "{}"'.format(prefix, command, params['policyname'], params['policynum'], table, params['comment']))
            elif params['action'].lower() in ['enable', 'disable']:
                log('{}modify fw_policies {} rule:{}:disabled {}'.format(prefix, params['policyname'], params['policynum'], value)) 
            elif params['action'].lower() in ['delete']:
                log('{}rmbyindex fw_policies {} rule {}'.format(prefix, params['policyname'], params['policynum']))
            else:
                return 'Unknown Action'
            '''
    elif fw_type in ['palo', 'pano', 'paloalto']:
        if syntax.lower() == 'cli':
            if fw_type.lower() in ['palo', 'paloalto']:
                cmd_base = 'rulebase'
            elif fw_type.lower() == 'pano':
                if params['context'] == 'shared':
                    cmd_base = 'shared pre-rulebase'
                else:
                    cmd_base = 'device-group "{}" pre-rulebase'.format(params['context'])
            if params['action'].lower() == 'delmembers':
                if 'sources' in params:
                    members = ' '
                    for member in params['sources']:
                        members += member + ' '
                    log('{}delete {} security rules "{}" source [{}]'.format(prefix, cmd_base, params['policyname'],
                                                                             members))
                if 'dests' in params:
                    members = ' '
                    for member in params['dests']:
                        members += member + ' '
                    log('{}delete {} security rules "{}" destination [{}]'.format(prefix, cmd_base,
                                                                                  params['policyname'], members))
            elif params['action'].lower() == 'addmembers':
                if 'sources' in params:
                    members = ' '
                    for member in params['sources']:
                        members += member + ' '
                    log('{}set {} security rules "{}" source [{}]'.format(prefix, cmd_base, params['policyname'],
                                                                          members))
                if 'dests' in params:
                    members = ' '
                    for member in params['dests']:
                        members += member + ' '
                    log('{}set {} security rules "{}" destination [{}]'.format(prefix, cmd_base, params['policyname'],
                                                                               members))
            elif params['action'].lower() == 'comment':
                log('{}set {} security rules "{}" description "{}'.format(prefix, cmd_base, params['policyname'],
                                                                          params['comment']))
            elif params['action'].lower() == 'enable':
                log('{}set {} security rules "{}" disable no'.format(prefix, cmd_base, params['policyname'],
                                                                     params['comment']))
            elif params['action'].lower() == 'disable':
                log('{}set {} security rules "{}" disable yes'.format(prefix, cmd_base, params['policyname'],
                                                                      params['comment']))
            elif params['action'].lower() == 'delete':
                log('{}delete {} security rules "{}"'.format(prefix, cmd_base, params['policyname']))
            else:
                return 'Unknown Action'
        elif syntax.lower() in ['webui', 'api']:
            url = None
            if fw_type in ['palo', 'paloalto']:
                object_base = "/config/devices/entry[@name='localhost.localdomain']/vsys/entry[@name='vsys1']/rulebase/security/rules"
            elif fw_type == 'pano':
                if params['context'] == 'shared':
                    object_base = "/config/shared/pre-rulebase/security/rules"
                else:
                    object_base = "/config/devices/entry[@name='localhost.localdomain']/device-group/entry[@name='{}']/pre-rulebase/security/rules".format(
                        params['context'])

            if params['action'].lower() == 'setmembers':
                if 'dstzones' in params:
                    members = ''
                    for member in params['dstzones']:
                        members += '<member>{}</member>'.format(member)
                    # url='/api/?type=config&action=delete&xpath={}/&element=<entry name=\'{}\'><to>{}</to></entry>'.format(object_base, params['policyname'], members)
                    # url='/api/?type=config&action=edit&xpath={}/entry[@name=\'{}\']<to>{}</to></entry>'.format(object_base, params['policyname'], members)
                    url = '/api/?type=config&action=edit&xpath={}/entry[@name=\'{}\']/to&element=<to>{}</to>'.format(
                        object_base, params['policyname'], members)
                if 'srczones' in params:
                    members = ''
                    for member in params['srczones']:
                        members += '<member>{}</member>'.format(member)
                    # url='/api/?type=config&action=delete&xpath={}/&element=<entry name=\'{}\'><from>{}</from></entry>'.format(object_base, params['policyname'], members)
                    # url='/api/?type=config&action=edit&xpath={}/entry[@name=\'{}\']<to>{}</to></entry>'.format(object_base, params['policyname'], members)
                    url = '/api/?type=config&action=edit&xpath={}/entry[@name=\'{}\']/from&element=<from>{}</from>'.format(
                        object_base, params['policyname'], members)
                    #

            elif params['action'].lower() == 'delmembers':
                if 'sources' in params:
                    for member in params['sources']:
                        url = '/api/?type=config&action=delete&xpath={}/entry[@name=\'{}\']/source/member[text()="{}"]'.format(
                            object_base, params['policyname'], member)
                        result = send_palo_apicmd(session, target, url, apikey)
                    # members=' '
                    # for member in params['sources']:
                    #    members+=member+'<member>{}</member>'.format(member)
                    # url='/api/?type=config&action=delete&xpath={}&key={}&element=<entry name=\'{}\'><source>{}</source></entry>'.format(object_base, apikey, params['policyname'], members)
                if 'dests' in params:
                    for member in params['dests']:
                        url = '/api/?type=config&action=delete&xpath={}/entry[@name=\'{}\']/destination/member[text()="{}"]'.format(
                            object_base, params['policyname'], member)
                        result = send_palo_apicmd(session, target, url, apikey)
                    # members=' '
                    # for member in params['dests']:
                    #    members+=member+'<member>{}</member>'.format(member)
                    # url='/api/?type=config&action=delete&xpath={}&key={}&element=<entry name=\'{}\'><destination>{}</destination></entry>'.format(object_base, apikey, params['policyname'], members)
                if 'services' in params:
                    for member in params['services']:
                        url = '/api/?type=config&action=delete&xpath={}/entry[@name=\'{}\']/service/member[text()="{}"]'.format(
                            object_base, params['policyname'], member)
                        result = send_palo_apicmd(session, target, url, apikey)
                    # members=''
                    # for member in params['services']:
                    #    members+=member+'<member>{}</member>'.format(member)
                    # url='/api/?type=config&action=delete&xpath={}&key={}&element=<entry name=\'{}\'><service>{}</service></entry>'.format(object_base, apikey, params['policyname'], members)
                if 'tags' in params:
                    for member in params['tags']:
                        url = '/api/?type=config&action=delete&xpath={}/entry[@name=\'{}\']/tag/member[text()="{}"]'.format(
                            object_base, params['policyname'], member)
                        result = send_palo_apicmd(session, target, url, apikey)
                    # members=''
                    # for member in params['tags']:
                    #    members+='<member>{}</member>'.format(member)
                    # url='/api/?type=config&action=delete&xpath={}&key={}&element=<entry name=\'{}\'><tag>{}</tag></entry>'.format(object_base, apikey, params['policyname'], members)
                if 'dstzones' in params:
                    members = ''
                    for member in params['dstzones']:
                        members += '<member>{}</member>'.format(member)
                    # url='/api/?type=config&action=delete&xpath={}&element=<entry name=\'{}\'><to>{}</to></entry>'.format(object_base, params['policyname'], members)
                    url = '/api/?type=config&action=delete&xpath={}/entry[@name=\'{}\'><to>{}</to></entry>'.format(
                        object_base, params['policyname'], members)
                if 'srczones' in params:
                    members = ''
                    for member in params['srczones']:
                        members += '<member>{}</member>'.format(member)
                    # url='/api/?type=config&action=delete&xpath={}&element=<entry name=\'{}\'><from>{}</from></entry>'.format(object_base, params['policyname'], members)
                    url = '/api/?type=config&action=delete&xpath={}/entry[@name=\'{}\'><to>{}</to></entry>'.format(
                        object_base, params['policyname'], members)

                    # url=None
            elif params['action'].lower() == 'addmembers':
                if 'sources' in params:
                    members = ''
                    for member in params['sources']:
                        members += '<member>{}</member>'.format(member)
                    url = '/api/?type=config&action=set&xpath={}/entry[@name=\'{}\']/source&element={}'.format(
                        object_base, params['policyname'], members)
                    url = '/api/?type=config&action=set&xpath={}&element=<entry name=\'{}\'><source>{}</source></entry>'.format(
                        object_base, params['policyname'], members)
                if 'dests' in params:
                    members = ''
                    for member in params['dests']:
                        members += '<member>{}</member>'.format(member)
                    url = '/api/?type=config&action=set&xpath={}&element=<entry name=\'{}\'><destination>{}</destination></entry>'.format(
                        object_base, params['policyname'], members)
                if 'services' in params:
                    members = ''
                    for member in params['services']:
                        members += '<member>{}</member>'.format(member)
                    url = '/api/?type=config&action=set&xpath={}&element=<entry name=\'{}\'><service>{}</service></entry>'.format(
                        object_base, params['policyname'], members)
                if 'tags' in params:
                    members = ''
                    for member in params['tags']:
                        members += '<member>{}</member>'.format(member)
                    url = '/api/?type=config&action=set&xpath={}&element=<entry name=\'{}\'><tag>{}</tag></entry>'.format(
                        object_base, params['policyname'], members)
                if 'dstzones' in params:
                    members = ''
                    for member in params['dstzones']:
                        members += '<member>{}</member>'.format(member)
                    url = '/api/?type=config&action=set&xpath={}&element=<entry name=\'{}\'><to>{}</to></entry>'.format(
                        object_base, params['policyname'], members)
                if 'srczones' in params:
                    members = ''
                    for member in params['srczones']:
                        members += '<member>{}</member>'.format(member)
                    url = '/api/?type=config&action=set&xpath={}&element=<entry name=\'{}\'><from>{}</from></entry>'.format(
                        object_base, params['policyname'], members)
            elif params['action'].lower() == 'comment':
                url = '/api/?type=config&action=set&xpath={}&element=<entry name=\'{}\'><description>{}</description></entry>'.format(
                    object_base, params['policyname'], quote(params['comment'], safe=''))
                # url='/api/?type=config&action=set&xpath={}/service-group/entry[@name=\'{}\']&element=<description>{}</description>&key={}'.format(target, object_base, params['servicename'], params['comment'], apikey)
            elif params['action'].lower() == 'log-setting':
                log(params)
                url = '/api/?type=config&action=set&xpath={}&element=<entry name=\'{}\'><log-setting>{}</log-setting></entry>'.format(
                    object_base, params['policyname'], params['log-setting'])
            elif params['action'].lower() == 'log-start':
                url = '/api/?type=config&action=set&xpath={}&element=<entry name=\'{}\'><log-start>{}</log-start></entry>'.format(
                    object_base, params['policyname'], params['log-start'])
            elif params['action'].lower() == 'log-end':
                url = '/api/?type=config&action=set&xpath={}&element=<entry name=\'{}\'><log-end>{}</log-end></entry>'.format(
                    object_base, params['policyname'], params['log-end'])

            elif params['action'].lower() == 'enable':
                url = '/api/?type=config&action=set&xpath={}&element=<entry name=\'{}\'><disabled>no</disabled></entry>'.format(
                    object_base, params['policyname'])
            elif params['action'].lower() == 'disable':
                url = '/api/?type=config&action=set&xpath={}&element=<entry name=\'{}\'><disabled>yes</disabled></entry>'.format(
                    object_base, params['policyname'])
            elif params['action'].lower() == 'delete':
                url = '/api/?type=config&action=delete&xpath={}&element=<entry name=\'{}\'>'.format(object_base, params[
                    'policyname'])
            else:
                return 'Unknown Action'
            if url:
                # print(url)
                result = send_palo_apicmd(session, target, url, apikey)
                debug('SEND_CMD_RESULT', result)
            # url='/api/?type=config&action=set&xpath={}&key={}&element=<entry name=\'{}\'><source>{}</source><destination>{}</destination><service>{}</service><application>{}</application><action>{}</action><log-end>{}</log-end><log-start>{}</log-start><from>{}</from><to>{}</to></entry>'.format(object_base, apikey, params['rulename'], srcaddr, dstaddr, services, applications, action, log_end, log_start, srczones, dstzones)

    else:
        pass
        ##return unknown firewall type
    return result


def get_sw_objects(target, username, password, fw_type, session=None):
    import json
    import base64
    import sonicwall as sw

    sw_objects = {'address_objects': {'ipv4': [], 'ipv6': [], 'fqdn': []},
                  'address_groups': {'ipv4': [], 'ipv6': [], 'fqdn': []}, 'service_objects': [], 'service_groups': []}
    if session == None:
        session = requests.Session()
        session.mount('https://' + target, sw.DESAdapter())
        urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
        if not options.web and (options.username == None or options.password == None):
            options.username, options.password = get_creds()
        if fw_type.lower() == 'sonicwall':
            response = sw.do_login(session, options.username, options.password, target, True)
            apikey = None
        elif fw_type.lower() in ['sw65']:
            url = 'https://{}/api/sonicos/auth'.format(target)
            session.headers = OrderedDict(
                [('User-Agent', 'python-requests/2.18.4'), ('Accept', '*/*'), ('Accept-Encoding', 'gzip, deflate'),
                 ('Connection', 'keep-alive')])
            post_data = None
            # auth = requests.auth.HTTPBasicAuth(options.username, options.password) -- replaced with manually setting headers myself since python requests basic auth was not handling special characters correctly
            response_code = None
            login_tries = 0
            while response_code != 200 and login_tries < 1:
                try:
                    login_tries += 1
                    response = session.post(url=url, headers={'authorization': "Basic " + base64.b64encode(
                        '{}:{}'.format(options.username, options.password).encode()).decode()}, verify=False,
                                            timeout=options.timeout_sw_webui_login)
                    response_code = response.status_code
                    # debug('LOGIN RESULT', response.text)
                except:
                    pass
            apikey = None

            if response_code != 200:
                session = None
                apikey = None
                log('!-- Login failed')

    elif session != None:
        # log(session)
        debug('!-- Checking if in configuration mode')
        url = 'https://{}/api/sonicos/address-objects/ipv4'.format(target)
        # post_data={}
        post_data = {'address_object': {
            'ipv4': {
                'name': 'api_test_object',
                'zone': 'LAN',
                'host': {'ip': '192.168.255.254'}}}}
        result = session.post(url=url, json=post_data, verify=False, timeout=options.timeout_sw_webui_post)
        # log(result)
        # log(json.loads(result.text))
        if not json.loads(result.text)['status']['success']:
            if not json.loads(result.text)['status']['cli']['configuring']:
                # log('result',result.text)
                return False, 'Not in config mode'

        url = 'https://{}/api/sonicos/address-objects/ipv4'.format(target)
        result = session.get(url=url, data=post_data, verify=False, timeout=options.timeout_sw_api)
        # log(result)
        addresses_ipv4 = json.loads(result.text)
        for address_object in [address['ipv4']['name'] for address in addresses_ipv4['address_objects']]:
            sw_objects['address_objects']['ipv4'].append(address_object)

        url = 'https://{}/api/sonicos/address-objects/fqdn'.format(target)
        result = session.get(url=url, data=post_data, verify=False, timeout=options.timeout_sw_api)
        addresses_fqdn = json.loads(result.text)
        if 'address_objects' in addresses_fqdn:
            for address_object in [address['fqdn']['name'] for address in addresses_fqdn['address_objects']]:
                sw_objects['address_objects']['fqdn'].append(address_object)

        url = 'https://{}/api/sonicos/address-groups/ipv4'.format(target)
        result = session.get(url=url, data=post_data, verify=False, timeout=options.timeout_sw_api)
        addresses_ipv4 = json.loads(result.text)
        for address_object in [address['ipv4']['name'] for address in addresses_ipv4['address_groups']]:
            sw_objects['address_groups']['ipv4'].append(address_object)

        url = 'https://{}/api/sonicos/address-groups/ipv6'.format(target)
        result = session.get(url=url, data=post_data, verify=False, timeout=options.timeout_sw_api)
        addresses_ipv6 = json.loads(result.text)
        for address_object in [address['ipv6']['name'] for address in addresses_ipv6['address_groups']]:
            sw_objects['address_groups']['ipv6'].append(address_object)

        url = 'https://{}/api/sonicos/service-objects'.format(target)
        result = session.get(url=url, data=post_data, verify=False, timeout=options.timeout_sw_api)
        services = json.loads(result.text)
        for service_object in [service['name'] for service in services['service_objects']]:
            sw_objects['service_objects'].append(service_object)

        url = 'https://{}/api/sonicos/service-groups'.format(target)
        result = session.get(url=url, data=post_data, verify=False, timeout=options.timeout_sw_api)
        services = json.loads(result.text)
        for service_object in [service['name'] for service in services['service_groups']]:
            sw_objects['service_groups'].append(service_object)

        # url='https://{}/api/sonicos/auth'.format(target)
        # session.delete(url=url, verify=False)

    return sw_objects


def exec_fw_command(target, fw_type, commands, syntax='cli', policylens=None, delay=None, use_session=True,
                    use_apikey=False, dryrun=False,
                    sw_objects=None):  # add sw_sesssion, enable_api and commit options -- what is policy lens for?

    ## in theory, for checkpoint, commands could include multiple CMAs.  We should build a list of all the CMAs in a set of commands, then generate a sid and uid for each

    import requests
    import re
    import sonicwall as sw
    from urllib.parse import quote
    import time
    import json
    import base64

    valid_commands = ['create_address',
                      'modify_address',
                      'create_rule',
                      'modify_rule',
                      'create_service',
                      'modify_service',
                      'raw_command']
    # all_params=['context', 'ip1', 'ip2', 'name', 'members', 'comment', 'color', 'type', 'props', 'zone', 'srczone', 'dstzone', 'service', 'app', 'cmdtype', 'rulename', 'rulenum']

    retries = 3
    result = True
    # sw_objects={'address_objects': {'ipv4': [], 'ipv6': [], 'fqdn': []}, 'address_groups': {'ipv4': [], 'ipv6': [], 'fqdn': []}, 'service_objects': [], 'service_groups': [] }
    sw_objects = None
    if fw_type.lower() in ['sonicwall', 'palo', 'paloalto', 'pano', 'sw65', 'checkpoint'] and syntax != 'cli':
        session = requests.Session()
        session.mount('https://' + target, sw.DESAdapter())
        urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
        if not options.web and (options.username == None or options.password == None):
            options.username, options.password = get_creds()
        if fw_type.lower() == 'sonicwall':
            response = sw.do_login(session, options.username, options.password, target, True)
            apikey = None
        elif fw_type.lower() in ['sw65']:
            tries = 0
            success = False
            while tries < retries and not success:
                tries += 1
                try:
                    url = 'https://{}/api/sonicos/auth'.format(target)
                    session.headers = OrderedDict([('User-Agent', 'python-requests/2.18.4'), ('Accept', '*/*'),
                                                   ('Accept-Encoding', 'gzip, deflate'), ('Connection', 'keep-alive')])
                    post_data = None
                    # auth = requests.auth.HTTPBasicAuth(options.username, options.password) -- replaced with manually setting headers myself since python requests basic auth was not handling special characters correctly
                    response_code = None
                    login_tries = 0
                    apikey = None
                    while response_code != 200 and login_tries < 1:
                        login_tries += 1
                        response = session.post(url=url, headers={'authorization': "Basic " + base64.b64encode(
                            '{}:{}'.format(options.username, options.password).encode()).decode()}, verify=False,
                                                timeout=options.timeout_sw_webui_login)
                        response_code = response.status_code
                        # log('LOGIN RESULT', response.text)
                        apikey = True
                    if response_code != 200:
                        session = None
                        apikey = None
                        log('!-- Login failed')
                    else:
                        if not sw_objects:
                            ## build sonicwall objects list - this is needed to determine object type for when they need to be added to other objects
                            ## get addresses_objects, address_groups, address_fqdn, services_objects, service_groups for ipv4, ipv6, fqdn
                            ## verify we are in config mode
                            # log('building sw_objects')
                            sw_objects = get_sw_objects(target, options.username, options.password, fw_type, session)
                    success = True
                except Exception as e:
                    log('An exception occured when trying to log in to Sonicwall : {}'.format(e))

        elif fw_type.lower() in ['palo', 'pano', 'paloalto'] and use_session:
            try:
                key = session.get(
                    'https://' + target + '/api/?type=keygen&user=' + options.username + '&password=' + quote(
                        options.password), verify=False, stream=True, timeout=options.timeout_palo_api)
                if len(re.findall("status = 'success'", key.text)) == 0:
                    log('Unable to execute configuration commands - Login Failed')
                    debug(key.text)
                    return False
                apikey = re.sub(r'.*<key>(.*)</key>.*', r'\1', key.text)
            except:
                apikey = None
        elif fw_type.lower() in ['checkpoint']:
            debug('!-- Logging into Checkpoint R80 API to get SID and UID')
            apikey, session, message = ckpt_login(target, options.context[0], options.username, options.password)
            if not apikey:
                debug('!-- Login to Checkpoint R80 API failed')
                session = None
                apikey = None
            else:
                debug(
                    '!-- Login to Checkpoint R80 API successful - Retreived SID {} and UID {}'.format(apikey, session))
                pass
                # session=options.context[0]

        else:  # what is this here for?
            session = None
            apikey = True

    else:
        session = None
        apikey = None
    # debug(apikey)
    # debug(session)

    if apikey or fw_type.lower() not in ['palo', 'paloalto', 'pano', 'sw65'] or syntax.lower() == 'cli':
        #
        tries = 0
        success = False
        debug('COMMANDS', commands)
        while tries < retries and not success:
            tries += 1
            # log('starting push -- try : {}'.format(tries))
            try:
                successful_commands = 0
                for command, params in commands:
                    debug('COMMAND', command)
                    debug('PARAMS', params)
                    #        for param in all_params: #set defalt value for all unset params - no validation is done at this time that the right params are passed for each cmdtype
                    #            if param not in command:
                    #                if param=='members':
                    #                    command[param]=[]
                    #                elif param=='color':
                    #                    command['color']='black'
                    #                else:
                    #                    command[param]=None

                    if 'comment' not in params:  # should provide proper handling of missing comment in functions below instead of setting this for everything CHANGE_ME
                        params['comment'] = ''
                    if command == 'create_address':
                        result = create_address_obj(target, session, apikey, fw_type, syntax, params, sw_objects)
                    elif command == 'modify_address':
                        result = modify_address_obj(target, session, apikey, fw_type, syntax, params, sw_objects)
                    elif command == 'modify_address_group':
                        result = modify_address_obj(target, session, apikey, fw_type, syntax, params, sw_objects)
                    elif command == 'create_rule':
                        result = create_rule_obj(target, session, apikey, fw_type, syntax, params, sw_objects)
                    elif command == 'modify_rule':
                        result = modify_rule_obj(target, session, apikey, fw_type, syntax, params, sw_objects)
                    elif command == 'create_service':
                        result = create_service_obj(target, session, apikey, fw_type, syntax, params, sw_objects)
                    elif command == 'modify_service':
                        result = modify_service_obj(target, session, apikey, fw_type, syntax, params, sw_objects)
                    else:
                        return 'Unknown Command'
                    if syntax.lower != 'cli':
                        debug('{},{},{},"{}",{}'.format(target, fw_type, command, params, result))
                    if delay:
                        debug('Sleeping for {} seconds'.format(delay))
                        time.sleep(delay)
                success = result == True
                if success:
                    successful_commands += 1
            except Exception as e:
                log('An exception occured when trying to perform exec_fw_command : {}'.format(e))

        ## Add sonicwall log-out / commit routines
        tries = 0
        success = False
        if successful_commands > 0:
            # log('attempting commit')
            if fw_type.lower() in ['sw65']:
                while tries < retries and not success:
                    tries += 1
                    try:
                        commit_result = session.get('https://{}/api/sonicos/config/pending'.format(target), data=None,
                                                    verify=False, timeout=options.timeout_sw_webui)
                        debug(commit_result.text)
                        if json.loads(commit_result.text) != {}:
                            debug('!-- Commiting pending changes')
                            commit_result = session.post('https://{}/api/sonicos/config/pending'.format(target),
                                                         data=None, verify=False, timeout=options.timeout_sw_webui_post)
                            debug(commit_result.text)
                            if 'status' in json.loads(commit_result.text):
                                success = True
                            if not json.loads(commit_result.text)['status']['success']:
                                result = False, json.loads(commit_result.text)['status']['info'][0]['message']
                        else:
                            debug('!-- No Changes made - Skipping commit')
                            success = True
                        debug('!-- Logging out of API')
                        url = 'https://{}/api/sonicos/auth'.format(target)
                        session.delete(url=url, verify=False, timeout=options.timeout_sw_webui)
                    except Exception as e:
                        log('An exception occured when trying to commit Sonicwall config : {}'.format(e))
            elif fw_type.lower() == 'checkpoint' and syntax.lower() == 'api':
                if result == True:
                    debug('result before publish', result)
                    publish_result = ckpt_api_call(target, 443, "publish", {}, apikey)
                    debug("publish result: " + json.dumps(publish_result.text))
                    if 'task-id' not in json.loads(publish_result.text):
                        result = False, 'Publish Failed'
                        debug('!-- Changes failed -- discarding changes')
                        discard_result = ckpt_api_call(target, 443, "discard", {'uid': session}, apikey)
                        debug('discard result', discard_result)
                else:
                    debug('!-- Changes failed -- discarding changes')
                    discard_result = ckpt_api_call(target, 443, "discard", {'uid': session}, apikey)
                    debug('discard result', discard_result)
                debug('!-- Logging out of Checkpoint API')
                logout_result = ckpt_api_call(target, 443, "logout", {}, apikey)
                debug("logout result: " + json.dumps(logout_result.text))
    else:
        return False, 'no API key'
    # log('result', result)
    return result


def inverse_match(subnets):
    ## address match results should not be just the first address object of the policy "[0]".. It should be changed to a tuple, containing the address object and object type.  The match type would be nice, but currently the matching is done on all the addresses in the policy at once, so this would be difficult to implement as it is currently written.
    ## this is only for reporting purposes.  the logic should be sound for matching as it currently is.  the problem is that when generating the matching report for policies, only the first address object is returned.
    from netaddr import IPSet
    import os
    from urllib.parse import unquote as url_unquote

    searchnets = IPSet([])
    sourcenets = IPSet([])
    destnets = IPSet([])
    inverse = OrderedDict()

    for network in subnets:
        searchnets.add(network)
    '''
        if len(os.path.basename(network))>0:
            if os.path.basename(network[0]) == '@':
                for i in file_to_list(network[1:]):
                    searchnets.add(i)
            else:
                searchnets.add(network)
    '''

    # print(searchnets)

    for context in contexts:

        inverse[context] = OrderedDict()
        inverse[context]['stats'] = {}
        inverse[context]['policies'] = []
        inverse[context]['effected_policies'] = []
        inverse[context]['addresses'] = []
        inverse[context]['addr_stats'] = [0, 0, 0]
        inverse[context]['policy_stats'] = [0, 0, 0]
        inverse[context]['stats'] = {'match': {'rules': {'total': 0, 'complete': 0, 'partial': 0},
                                               'addresses': {'total': 0, 'complete': 0, 'partial': 0}
                                               },
                                     'cleanup': {'rules': {'disabled': 0, 'deleted': 0, 'skipped_not_allow_rule': 0,
                                                           'skipped_notdisabled': 0},
                                                 'addresses': {'rem_rules': 0, 'rem_groups': 0, 'rem_dg': 0}
                                                 },

                                     'exec': {'rules': {'disabled': {'pass': 0, 'fail': 0, 'skipped': 0},
                                                        'deleted': {'pass': 0, 'fail': 0, 'skipped': 0}},
                                              'addresses': {'rem_rules': {'pass': 0, 'fail': 0, 'skipped': 0},
                                                            'rem_groups': {'pass': 0, 'fail': 0, 'skipped': 0},
                                                            'rem_dg': {'pass': 0, 'fail': 0, 'skipped': 0}}
                                              }}
        complete_matches = []  # CHANGEME - not sure what these were used for and I believe they can be removed
        partial_matches = []
        for policy in config[context]['policies']:
            rulematch = False
            source_match = 'none'
            dest_match = 'none'
            source_addr = ''  ###+ bcolors.OKGREEN
            dest_addr = ''  ###+ bcolors.OKGREEN
            sourcenets = IPSet([])
            destnets = IPSet([])
            if config[context]['policies'][policy]['policyProps'] == '0':  ## Only perform matching for custom rules
                for source in config[context]['policies'][policy]['policySrcNet']:
                    for member in expand_address(config[context]['addresses'], source,
                                                 config[context]['addressmappings']):
                        if member in config[context]['addresses']:
                            for network in config[context]['addresses'][member]['IPv4Networks']:
                                if network.prefixlen > 8:
                                    sourcenets.add(str(network))
                        elif member in config['shared']['addresses']:
                            for network in config['shared']['addresses'][member]['IPv4Networks']:
                                if network.prefixlen > 8:
                                    sourcenets.add(str(network))
                for dest in config[context]['policies'][policy]['policyDstNet']:
                    for member in expand_address(config[context]['addresses'], dest,
                                                 config[context]['addressmappings']):
                        if member in config[context]['addresses']:
                            for network in config[context]['addresses'][member]['IPv4Networks']:
                                if network.prefixlen > 8:
                                    destnets.add(str(network))
                        elif member in config['shared']['addresses']:
                            for network in config['shared']['addresses'][member]['IPv4Networks']:
                                if network.prefixlen > 8:
                                    destnets.add(str(network))

                if sourcenets and ((sourcenets & searchnets) == sourcenets):  ## Don't match empty sourcenets
                    source_match = 'complete'
                    for member in config[context]['policies'][policy]['policySrcNet']:
                        if member not in partial_matches: partial_matches.append(member)

                    rulematch = True
                elif (sourcenets & searchnets):
                    source_match = 'partial'
                    for member in config[context]['policies'][policy]['policySrcNet']:
                        if member not in complete_matches: complete_matches.append(member)
                    rulematch = True
                if destnets and ((destnets & searchnets) == destnets):  ## Don't match empty destnets
                    dest_match = 'complete'
                    for member in config[context]['policies'][policy]['policyDstNet']:
                        if member not in partial_matches: partial_matches.append(member)
                    rulematch = True
                elif (destnets & searchnets):
                    dest_match = 'partial'
                    for member in config[context]['policies'][policy]['policyDstNet']:
                        if member not in complete_matches: complete_matches.append(member)
                    rulematch = True

                if rulematch:
                    debug('RULEMATCH!!')
                    if config[context]['policies'][policy]['policyName'] not in inverse[context][
                        'effected_policies']:  # build a list of effected policies
                        # log('adding: ', config[context]['policies'][policy]['policyName'])
                        inverse[context]['effected_policies'].append(config[context]['policies'][policy]['policyName'])
                    # else:
                    #    log('new : ', config[context]['policies'][policy]['policyName'])

                    if config[context]['policies'][policy]['policyEnabled'] == '0':
                        enabled = False
                    elif config[context]['policies'][policy]['policyEnabled'] == '1':
                        enabled = True

                    if config[context]['policies'][policy]['policyAction'] == '0':
                        action = 'deny'
                    elif config[context]['policies'][policy]['policyAction'] == '1':
                        action = 'discard'
                    elif config[context]['policies'][policy]['policyAction'] == '2':
                        action = 'allow'
                    elif config[context]['policies'][policy]['policyAction'] == '3':
                        action = 'CltAuth'

                    name = config[context]['policies'][policy]['policyName']
                    comment = url_unquote(config[context]['policies'][policy]['policyComment'])

                    if config[context]['policies'][policy]['policySrcZone'] == []:
                        source_zone = 'any'
                    else:
                        source_zone = config[context]['policies'][policy]['policySrcZone'][0]

                    if config[context]['policies'][policy]['policyDstZone'] == []:
                        dest_zone = 'any'
                    else:
                        dest_zone = config[context]['policies'][policy]['policyDstZone'][0]
                    if len(config[context]['policies'][policy]['policySrcNet']) > 0: source_addr += \
                    config[context]['policies'][policy]['policySrcNet'][0]  ###+ bcolors.ENDC
                    if len(config[context]['policies'][policy]['policyDstNet']) > 0: dest_addr += \
                    config[context]['policies'][policy]['policyDstNet'][0]  ###+ bcolors.ENDC
                    if len(config[context]['policies'][policy]['policyDstSvc']) > 0: dest_service = \
                    config[context]['policies'][policy]['policyDstSvc'][0]
                    if dest_service == '' or config[context]['policies'][policy][
                        'policyDstSvc'] == []: dest_service = 'any'

                    if source_addr == '' or source_addr.lower() == 'any':
                        source_type = 'any'
                    else:
                        if source_addr in config[context]['addresses']:
                            tmp_type = config[context]['addresses'][source_addr]['addrObjType']
                        elif 'shared' in config:
                            if source_addr in config['shared']['addresses']:
                                tmp_type = config['shared']['addresses'][source_addr]['addrObjType']
                            else:
                                tmp_type = '0'
                        else:
                            tmp_type = '0'

                        if tmp_type == '1':
                            source_type = 'host'
                        elif tmp_type == '2':
                            source_type = 'range'
                        elif tmp_type == '4':
                            source_type = 'network'
                        elif tmp_type == '0':
                            source_type = 'ERROR'
                        else:
                            source_type = 'group'

                    if dest_addr == '' or dest_addr.lower() == 'any':
                        dest_type = 'any'
                    else:
                        if dest_addr in config[context]['addresses']:
                            tmp_type = config[context]['addresses'][dest_addr]['addrObjType']
                        elif 'shared' in config:
                            if dest_addr in config['shared']['addresses']:
                                tmp_type = config['shared']['addresses'][dest_addr]['addrObjType']
                        else:
                            tmp_type = '0'

                        if tmp_type == '1':
                            dest_type = 'host'
                        elif tmp_type == '2':
                            dest_type = 'range'
                        elif tmp_type == '4':
                            dest_type = 'network'
                        elif tmp_type == '91':
                            dest_type = 'special'
                        elif tmp_type == '0':
                            dest_type = 'ERROR'
                        else:
                            dest_type = 'group'

                    if dest_service == '' or dest_service.lower() == 'any':
                        service_type = 'any'
                    else:
                        if dest_service in config[context]['services']:
                            tmp_type = config[context]['services'][dest_service]['svcObjType']
                        elif 'shared' in config:
                            if dest_service in config['shared']['services']:
                                tmp_type = config['shared']['services'][dest_service]['svcObjType']
                        else:
                            tmp_type = '0'

                        if tmp_type == '1':
                            service_type = 'name'
                        elif tmp_type == '2':
                            service_type = 'group'
                        elif tmp_type == '4':
                            service_type = 'portset'
                        elif tmp_type == '0':
                            service_type = 'ERROR'
                        else:
                            service_type = 'group'

                    inverse[context]['stats']['match']['rules']['total'] += 1
                    if source_match == 'complete' or dest_match == 'complete':
                        inverse[context]['stats']['match']['rules']['complete'] += 1
                    else:
                        inverse[context]['stats']['match']['rules']['partial'] += 1

                    if config[context]['config']['fw_type'].lower() == 'checkpoint':
                        rule_num = config[context]['policies'][policy]['policyNum']
                        ui_num = config[context]['policies'][policy]['policyUiNum']
                    else:
                        rule_num = 0
                        ui_num = 0
                    inverse[context]['policies'].append({'devname': config[context]['config']['name'],
                                                         'rule_num': rule_num,
                                                         'fw_type': config[context]['config']['fw_type'], \
                                                         'fw_version': config[context]['config']['version'],
                                                         'enabled': enabled,
                                                         'action': action,
                                                         'name': name,
                                                         'source_zone': source_zone,
                                                         'dest_zone': dest_zone, \
                                                         'source_type': source_type,
                                                         'source_addr': source_addr,
                                                         'source_match': source_match,
                                                         'dest_type': dest_type,
                                                         'dest_addr': dest_addr,
                                                         'dest_match': dest_match,
                                                         'service_type': service_type,
                                                         'dest_service': dest_service,
                                                         'comment': comment,
                                                         'rule_num': config[context]['policies'][policy]['policyNum'],
                                                         'ui_num': config[context]['policies'][policy]['policyUiNum'],
                                                         'source_list': config[context]['policies'][policy][
                                                             'policySrcNet'],
                                                         'dest_list': config[context]['policies'][policy][
                                                             'policyDstNet']})

        for address in config[context]['addresses']:

            addressnets = IPSet([])
            for member in expand_address(config[context]['addresses'], address, config[context]['addressmappings']):
                if member in config[context]['addresses']:
                    for network in config[context]['addresses'][member]['IPv4Networks']:
                        if network.prefixlen > 8:
                            addressnets.add(str(network))
                elif member in config['shared']['addresses']:
                    for network in config['shared']['addresses'][member]['IPv4Networks']:
                        if network.prefixlen > 8:
                            addressnets.add(str(network))
            try:
                if config[context]['addresses'][address]['addrObjType'] == '1':
                    addr_type = 'host'
                elif config[context]['addresses'][address]['addrObjType'] == '2':
                    addr_type = 'range'
                elif config[context]['addresses'][address]['addrObjType'] == '4':
                    addr_type = 'network'
                elif config[context]['addresses'][address]['addrObjType'] == '8':
                    addr_type = 'group'
                else:
                    addr_type = config[context]['addresses'][address]['addrObjType']
            except:
                if config['shared']['addresses'][address]['addrObjType'] == '1':
                    addr_type = 'host'
                elif config['shared']['addresses'][address]['addrObjType'] == '2':
                    addr_type = 'range'
                elif config['shared']['addresses'][address]['addrObjType'] == '4':
                    addr_type = 'network'
                elif config['shared']['addresses'][address]['addrObjType'] == '8':
                    addr_type = 'group'
                else:
                    addr_type = config['shared']['addresses'][address]['addrObjType'] \
 \
            if addressnets and ((addressnets & searchnets) == addressnets):  ## Don't match empty destnets
                log('complete', address, level=logging.DEBUG)
                inverse[context]['addresses'].append(
                    {'devname': config[context]['config']['name'], 'fw_type': config[context]['config']['fw_type'],
                     'fw_version': config[context]['config']['version'], 'match': 'complete', 'type': addr_type,
                     'mapping': 'root', 'address': address})
            elif (addressnets & searchnets):
            log('partial', address, level=logging.DEBUG)
                inverse[context]['addresses'].append(
                    {'devname': config[context]['config']['name'], 'fw_type': config[context]['config']['fw_type'],
                     'fw_version': config[context]['config']['version'], 'match': 'partial', 'type': addr_type, \
                     'mapping': 'root', 'address': address})

            if config[context]['addresses'][address]['addrObjType'] == '8' and not (addressnets and (
                    (addressnets & searchnets) == addressnets)):  # what is being excluded here with the NOT?
                for mapping in config[context]['addressmappings'][address]:
                    addressnets = IPSet([])
                    for member in expand_address(config[context]['addresses'], mapping,
                                                 config[context]['addressmappings']):
                        if 'member' in config[context]['addresses']:
                            for network in config[context]['addresses'][member]['IPv4Networks']:
                                if network.prefixlen > 8:
                                    addressnets.add(str(network))
                        elif 'member' in config['shared']['addresses']:
                            for network in config['shared']['addresses'][member]['IPv4Networks']:
                                if network.prefixlen > 8:
                                    addressnets.add(str(network))
                    try:
                        if config[context]['addresses'][mapping]['addrObjType'] == '1':
                            addr_type = 'host'
                        elif config[context]['addresses'][mapping]['addrObjType'] == '2':
                            addr_type = 'range'
                        elif config[context]['addresses'][mapping]['addrObjType'] == '4':
                            addr_type = 'network'
                        elif config[context]['addresses'][mapping]['addrObjType'] == '8':
                            addr_type = 'group'
                        else:
                            addr_type = config[context]['addresses'][mapping]['addrObjType']
                        # location='context'
                    except:
                        if 'shared' in config:
                            if mapping in config['shared']['addresses']:
                                if config['shared']['addresses'][mapping]['addrObjType'] == '1':
                                    addr_type = 'host'
                                elif config['shared']['addresses'][mapping]['addrObjType'] == '2':
                                    addr_type = 'range'
                                elif config['shared']['addresses'][mapping]['addrObjType'] == '4':
                                    addr_type = 'network'
                                elif config['shared']['addresses'][mapping]['addrObjType'] == '8':
                                    addr_type = 'group'
                                else:
                                    addr_type = config['shared']['addresses'][mapping]['addrObjType']
                        else:
                            addr_type = 'GMS'  # WHY GMS???
                    if addressnets and ((addressnets & searchnets) == addressnets):  ## Don't match empty destnets
                        inverse[context]['addresses'].append({'devname': config[context]['config']['name'],
                                                              'fw_type': config[context]['config']['fw_type'],
                                                              'fw_version': config[context]['config']['version'],
                                                              'match': 'complete', 'type': addr_type,
                                                              'address': mapping, 'mapping': address})
                        inverse[context]['addr_stats'][0] += 1
                        inverse[context]['addr_stats'][1] += 1
                        inverse[context]['stats']['match']['addresses']['total'] += 1
                        inverse[context]['stats']['match']['addresses']['complete'] += 1
                    elif (addressnets & searchnets):
                        inverse[context]['addresses'].append({'devname': config[context]['config']['name'],
                                                              'fw_type': config[context]['config']['fw_type'],
                                                              'fw_version': config[context]['config']['version'],
                                                              'match': 'partial', 'type': addr_type, 'address': mapping,
                                                              'mapping': address})
                        inverse[context]['addr_stats'][0] += 1
                        inverse[context]['addr_stats'][2] += 1
                        inverse[context]['stats']['match']['addresses']['total'] += 1
                        inverse[context]['stats']['match']['addresses']['partial'] += 1
    debug(inverse)
    return inverse;


def cip_match4(subnets):
    ## this differs from inverse_match in that each ip address passed in as a member of the subnets list is checked individually
    ## This first method has an outer loop of each address object and an inner loop of each ip address being searched - a second routine will be added to iterate through the ip address search list first, then network objects.
    ## I anticipate method 1 to be faster because the addressnets variable would need to be created far less.

    ## time to search 379 networks across all "internet" objects takes just under 17 minutes

    from netaddr import IPSet
    import os
    from urllib.parse import unquote as url_unquote
    import ipaddress

    searchnets = []
    sourcenets = IPSet([])
    destnets = IPSet([])
    change = OrderedDict()

    for network in subnets:
        if len(os.path.basename(network)) > 0:
            if os.path.basename(network[0]) == '@':
                for i in file_to_list(network[1:]):
                    if i[0] != '#':
                        searchnets.append(i.rstrip().split(','))
            else:
                searchnets.append(network.split(','))
    for searchnet, newnet in searchnets:
        if ipaddress.IPv4Network(searchnet).prefixlen < ipaddress.IPv4Network(newnet).prefixlen:
            log('Replacement of {} with smaller network {} requested - exact network matches will be replaced only'.format(
                searchnet, newnet))
    for searchnet, newnet in searchnets:
        try:
            ipaddress.IPv4Network(searchnet)
        except:
            log('Bad Old Network Given - ABORTING : {}'.format(ipaddress.IPv4Network(searchnet)))
            exit(1)
        try:
            ipaddress.IPv4Network(newnet)
        except:
            log('Bad New Network Given - ABORTING : {}'.format(ipaddress.IPv4Network(newnet)))
            exit(1)
    tmpindex = 0
    for searchnet, newnet in searchnets:
        tmpindex += 1
        for searchnet2, newnet2 in searchnets[tmpindex:]:
            debug('Checking if New network {} overlaps with new network {}'.format(newnet, newnet2))
            # log(newnet,newnet2)
            if IPSet([newnet]) & IPSet([newnet2]) != IPSet([]):
                log('WARNING! New network {} overlaps with new network {}'.format(newnet, newnet2))
    match_id = 0

    for context in contexts:
        if 'version' not in config[context]['config']: config[context]['config']['version'] = ''
        change[context] = OrderedDict()
        change[context]['fw_type'] = config[context]['config']['fw_type']
        change[context]['groups'] = OrderedDict()
        change[context]['addresses'] = OrderedDict()
        change[context]['sources'] = OrderedDict()
        change[context]['dests'] = OrderedDict()
        change[context]['nat'] = OrderedDict()
        change[context]['colors'] = OrderedDict()
        change[context]['group_policies'] = OrderedDict()
        expanded = {'groups': OrderedDict(),
                    'policy_src': OrderedDict(),
                    'policy_dst': OrderedDict(),
                    'nat_orig_src': OrderedDict(),
                    'nat_orig_dst': OrderedDict(),
                    'nat_trans_src': OrderedDict(),
                    'nat_trans_dst': OrderedDict(),
                    'all': []}

        expanded['all'] = []
        for group in config[context]['addresses']:
            if config[context]['addresses'][group]['addrObjType'] == '8':
                tmplist = expand_address(config[context]['addresses'], group, config[context]['addressmappings'],
                                         inc_group=True)
                expanded['groups'][group] = tmplist

        for policy in config[context]['policies']:
            expanded['policy_src'][policy] = []
            expanded['policy_dst'][policy] = []

            for pol_src in config[context]['policies'][policy]['policySrcNet']:
                tmplist = expand_address(config[context]['addresses'], pol_src, config[context]['addressmappings'],
                                         inc_group=True)
                expanded['policy_src'][policy].extend(tmplist)
                expanded['all'].extend(tmplist)

            for pol_dst in config[context]['policies'][policy]['policyDstNet']:
                tmplist = expand_address(config[context]['addresses'], pol_dst, config[context]['addressmappings'],
                                         inc_group=True)
                expanded['policy_dst'][policy].extend(tmplist)
                expanded['all'].extend(tmplist)

        if 'nat' in config[context]:
            for policy in config[context]['nat']:
                expanded['nat_orig_src'][policy] = []
                expanded['nat_orig_dst'][policy] = []
                expanded['nat_trans_src'][policy] = []
                expanded['nat_trans_dst'][policy] = []

                for nat_src in config[context]['nat'][policy]['natPolicyOrigSrc']:
                    tmplist = expand_address(config[context]['addresses'], nat_src, config[context]['addressmappings'],
                                             inc_group=True)
                    expanded['nat_orig_src'][policy].extend(tmplist)
                    expanded['all'].extend(tmplist)
                for nat_dst in config[context]['nat'][policy]['natPolicyOrigDst']:
                    tmplist = expand_address(config[context]['addresses'], nat_dst, config[context]['addressmappings'],
                                             inc_group=True)
                    expanded['nat_orig_dst'][policy].extend(tmplist)
                    expanded['all'].extend(tmplist)
                for nat_src in config[context]['nat'][policy]['natPolicyTransSrc']:
                    tmplist = expand_address(config[context]['addresses'], nat_src, config[context]['addressmappings'],
                                             inc_group=True)
                    expanded['nat_trans_src'][policy].extend(tmplist)
                    expanded['all'].extend(tmplist)
                for nat_dst in config[context]['nat'][policy]['natPolicyTransDst']:
                    tmplist = expand_address(config[context]['addresses'], nat_dst, config[context]['addressmappings'],
                                             inc_group=True)
                    expanded['nat_trans_dst'][policy].extend(tmplist)
                    expanded['all'].extend(tmplist)

        complete_matches = []  # CHANGEME - not sure what these were used for and I believe they can be removed
        partial_matches = []

        addresses_to_add = []
        for idx, address in enumerate(config[context]['addresses']):
            ## only perform matching for hosts, ranges and networks
            if config[context]['addresses'][address]['addrObjType'] in ['1', '2', '4', '91']:
                addressnets = IPSet([])
                for member in expand_address(config[context]['addresses'], address, config[context][
                    'addressmappings']):  ## why is this being done for addr types 1,2,4,91??
                    for network in config[context]['addresses'][member]['IPv4Networks']:
                        if network.prefixlen > 8:
                            addressnets.add(str(network))
                tmp_addr = None
                if address in config[context]['addresses']:
                    tmp_addr = config[context]['addresses'][address]
                elif address in config['shared']['addresses'] and config[context]['config']['fw_type'] == 'panorama':
                    tmp_addr = config['shared']['addresses'][address]
                if tmp_addr != None:
                    if tmp_addr['addrObjType'] == '1':
                        addr_type = 'host'
                    elif tmp_addr['addrObjType'] == '2':
                        addr_type = 'range'
                    elif tmp_addr['addrObjType'] == '4':
                        addr_type = 'network'
                    elif tmp_addr['addrObjType'] == '8':
                        addr_type = 'group'
                    elif tmp_addr['addrObjType'] == '91':
                        addr_type = 'cluster_member'
                    else:
                        addr_type = tmp_addr['addrObjType']

                for searchnet, newnet in searchnets:
                    if ipaddress.IPv4Network(searchnet).prefixlen >= ipaddress.IPv4Network(
                            newnet).prefixlen or addressnets == IPSet(
                            [searchnet]):  ## allow for replacement of larger to smaller for exact matches
                        newaddr = None
                        search = IPSet([searchnet])
                        if addr_type in ['host', 'range', 'network', 'cluster_member']:
                            addr_matches = addressnets & search
                        else:
                            addr_matches = ''
                        if addressnets and ((addressnets & search) == addressnets) or (
                                addressnets & search):  ### if its a complete or partial match...
                            if addressnets == search:
                                match_type = 'exact'
                            elif addressnets and ((addressnets & search) == addressnets):
                                match_type = 'complete'
                            else:
                                match_type = 'partial'
                            ## determine new object information
                            if match_type != 'partial' or options.exclude_partial == False:
                                if config[context]['addresses'][address]['addrObjType'] == '1':  ## host
                                    try:
                                        hidx = list(ipaddress.IPv4Network(searchnet)).index(ipaddress.IPv4Address(
                                            config[context]['addresses'][address]['IPv4Networks'][0][0]))
                                        newip1 = str(list(ipaddress.IPv4Network(newnet))[hidx])
                                        newip2 = '255.255.255.255'
                                        newaddr = "H-" + str(newip1)
                                    except:
                                        log('ERROR')

                                elif config[context]['addresses'][address]['addrObjType'] == '2':  ## range
                                    if match_type == 'complete':
                                        # log('Complete Range Match')
                                        if ipaddress.IPv4Address(
                                                config[context]['addresses'][address]['IPv4Networks'][0][0]) in list(
                                                ipaddress.IPv4Network(searchnet)):
                                            rfidx = list(ipaddress.IPv4Network(searchnet)).index(ipaddress.IPv4Address(
                                                config[context]['addresses'][address]['IPv4Networks'][0][0]))
                                        else:
                                            rfidx = 0
                                        if ipaddress.IPv4Address(
                                                config[context]['addresses'][address]['IPv4Networks'][-1][-1]) in list(
                                                ipaddress.IPv4Network(searchnet)):
                                            rlidx = list(ipaddress.IPv4Network(searchnet)).index(ipaddress.IPv4Address(
                                                config[context]['addresses'][address]['IPv4Networks'][-1][-1]))
                                        else:
                                            rlidx = -1
                                        newip1 = str(list(ipaddress.IPv4Network(newnet))[rfidx])
                                        newip2 = str(list(ipaddress.IPv4Network(newnet))[rlidx])
                                        newaddr = "R-" + str(newip1) + '-' + str(newip2)
                                    else:
                                        ## if searchnet is entirely contained within the range, do the same thing as we do for networks and just create a new network object
                                        log('WARNING -- range object with a partial match - this needs to be handled manually')
                                        log('DETAILS -- Search Network : {search}  Range Start: {rstart} Range End: {rend}'.format(
                                            search=searchnet,
                                            rstart=config[context]['addresses'][address]['addrObjIp1'],
                                            rend=config[context]['addresses'][address]['addrObjIp2']))
                                        if ipaddress.IPv4Address(
                                                config[context]['addresses'][address]['IPv4Networks'][0][0]) in list(
                                                ipaddress.IPv4Network(searchnet)):
                                            rfidx = list(ipaddress.IPv4Network(searchnet)).index(ipaddress.IPv4Address(
                                                config[context]['addresses'][address]['IPv4Networks'][0][0]))
                                        else:
                                            rfidx = 0
                                        if ipaddress.IPv4Address(
                                                config[context]['addresses'][address]['IPv4Networks'][-1][-1]) in list(
                                                ipaddress.IPv4Network(searchnet)):
                                            rlidx = list(ipaddress.IPv4Network(searchnet)).index(ipaddress.IPv4Address(
                                                config[context]['addresses'][address]['IPv4Networks'][-1][-1]))
                                            if rlidx > len(list(ipaddress.IPv4Network(newnet))):
                                                rlidx = -1
                                        else:
                                            rlidx = -1
                                        # log(rfidx, rlidx)
                                        newip1 = str(list(ipaddress.IPv4Network(newnet))[rfidx])
                                        newip2 = str(list(ipaddress.IPv4Network(newnet))[rlidx])
                                        newaddr = "R-" + str(newip1) + '-' + str(newip1).split('.')[3]
                                        newaddr = "R-" + str(newip1) + '-' + str(newip2)
                                elif config[context]['addresses'][address]['addrObjType'] == '4':  ## network
                                    if match_type == 'complete':
                                        nidx = list(ipaddress.IPv4Network(searchnet)).index(ipaddress.IPv4Address(
                                            config[context]['addresses'][address]['IPv4Networks'][0][
                                                0]))  # complete match index - searched network is a superset of the current address object
                                        nlen = config[context]['addresses'][address]['IPv4Networks'][0].prefixlen
                                        newip1 = str(list(ipaddress.IPv4Network(newnet))[nidx])
                                        newip2 = str(cidr_to_netmask(nlen))
                                        newaddr = 'N-' + newip1 + '-' + str(netmask_to_cidr(newip2))
                                    else:
                                        if len(re.findall('/', newnet)) > 0:
                                            newip1, newip2 = newnet.split('/')
                                            newip2 = cidr_to_netmask(newip2)
                                        else:
                                            newip1 = newnet
                                            newip2 = '255.255.255.255'
                                        newaddr = 'N-' + newip1 + '-' + str(netmask_to_cidr(newip2))
                                if newaddr != None:
                                    if newaddr in config[context]['addresses']:
                                        while newaddr in config[context]['addresses']:
                                            newaddr = newaddr + '_DUPE'
                                        log('WARNING -- existing address already exists with the proposed new name, renaming to : ' + newaddr,
                                            level=logging.INFO)

                                    if searchnet not in change[context]['addresses']:
                                        change[context]['addresses'][searchnet] = []

                                    ## consider changing new addresses to include list of tuple searchaddress,oldaddress
                                    ## consider keeping track of the number of matches
                                    if expanded['all'].count(address) == 0:
                                        debug('Object {} not found in any policy'.format(address))
                                    if match_type.lower() != 'partial':
                                        skip_address = 'no'
                                    else:
                                        skip_address = 'yes'
                                    change[context]['addresses'][searchnet].append(
                                        {'devname': config[context]['config']['name'],
                                         'fw_type': config[context]['config']['fw_type'],
                                         'fw_version': config[context]['config']['version'],
                                         'context': context,
                                         'match': match_type,
                                         'match_id': match_id,
                                         'type': addr_type,
                                         'mapping': 'root',
                                         'searchaddress': searchnet,
                                         'oldaddress': address,
                                         'old_ip1': config[context]['addresses'][address]['addrObjIp1'],
                                         'old_ip2': config[context]['addresses'][address]['addrObjIp2'],
                                         'zone': config[context]['addresses'][address]['addrObjZone'],
                                         'new_addr': newaddr,
                                         'new_ip1': newip1,
                                         'new_ip2': newip2,
                                         'matchlen': int(
                                             netmask_to_cidr(config[context]['addresses'][address]['addrObjIp2'])),
                                         'comment': 'WAS: ' + address + ' - ' + config[context]['addresses'][address][
                                             'addrObjComment'],
                                         'oldcolor': config[context]['addresses'][address]['addrObjColor'],
                                         'color': config[context]['addresses'][address]['addrObjColor'],
                                         'skip': skip_address,
                                         'inuse': expanded['all'].count(address)

                                         })
                                    match_id += 1
                                    if newaddr not in change[context]['colors']:
                                        change[context]['colors'][newaddr] = {}
                                        change[context]['colors'][newaddr]['color'] = \
                                        config[context]['addresses'][address]['addrObjColor']
                                        change[context]['colors'][newaddr]['matchlen'] = int(
                                            netmask_to_cidr(config[context]['addresses'][address]['addrObjIp2']))
                                    if int(netmask_to_cidr(config[context]['addresses'][address]['addrObjIp2'])) > \
                                            change[context]['colors'][newaddr]['matchlen'] and expanded['all'].count(
                                            address) > 0:
                                        change[context]['colors'][newaddr]['color'] = \
                                        config[context]['addresses'][address]['addrObjColor']
                                        change[context]['colors'][newaddr]['matchlen'] = int(
                                            netmask_to_cidr(config[context]['addresses'][address]['addrObjIp2']))
                                    addresses_to_add.append(newaddr)
                                    for group in config[context]['addressmappings']:
                                        if address in config[context]['addressmappings'][
                                            group]:  # and (options.cipskippartial and match_type !='partial'): ## added condition for 152.62.0.0 because of the time it was taking to process, and this replacement is not happning
                                            if address not in change[context]['groups']: change[context]['groups'][
                                                address] = []
                                            change[context]['groups'][address].append(
                                                {'devname': config[context]['config']['name'],
                                                 'fw_type': config[context]['config']['fw_type'],
                                                 'fw_version': config[context]['config']['version'],
                                                 'type': 'group',
                                                 'searchaddress': searchnet,
                                                 'oldmember': member,
                                                 'newmember': newaddr,
                                                 'group': group
                                                 })
                                            ## move matched_policies routing from report to here -- this is needed since it relies on having "config" available

                                            matched_policies = {}
                                            for p in config[context]['policies']:
                                                if config[context]['policies'][p][
                                                    'policyName'] not in options.cipblacklist:
                                                    policy_addresses = []
                                                    for s in config[context]['policies'][p]['policySrcNet']:
                                                        policy_addresses.extend(
                                                            expand_address(config[context]['addresses'], s,
                                                                           config[context]['addressmappings'],
                                                                           inc_group=True))
                                                        policy_addresses.extend([s])
                                                    for d in config[context]['policies'][p]['policyDstNet']:
                                                        policy_addresses.extend(
                                                            expand_address(config[context]['addresses'], s,
                                                                           config[context]['addressmappings'],
                                                                           inc_group=True))
                                                        policy_addresses.extend([d])
                                                    if group in policy_addresses:
                                                        if config[context]['policies'][p][
                                                            'policyName'] not in matched_policies:
                                                            # matched_policies.append(config[context]['policies'][p]['policyName'])
                                                            matched_policies[
                                                                config[context]['policies'][p]['policyName']] = [(
                                                                                                                 config[
                                                                                                                     context][
                                                                                                                     'policies'][
                                                                                                                     p][
                                                                                                                     'policyUiNum'],
                                                                                                                 config[
                                                                                                                     context][
                                                                                                                     'policies'][
                                                                                                                     p][
                                                                                                                     'policyNum'])]
                                                        else:
                                                            matched_policies[
                                                                config[context]['policies'][p]['policyName']].append((
                                                                                                                     config[
                                                                                                                         context][
                                                                                                                         'policies'][
                                                                                                                         p][
                                                                                                                         'policyUiNum'],
                                                                                                                     config[
                                                                                                                         context][
                                                                                                                         'policies'][
                                                                                                                         p][
                                                                                                                         'policyNum']))

                                            change[context]['group_policies'][group] = matched_policies
                                    for policy in config[context]['policies']:
                                        if config[context]['policies'][policy][
                                            'policyName'] not in options.cipblacklist:
                                            if address in config[context]['policies'][policy]['policySrcNet']:
                                                if address not in change[context]['sources']:
                                                change[context]['sources'][address] = []
                                                change[context]['sources'][address].append(
                                                    {'devname': config[context]['config']['name'],
                                                     'fw_type': config[context]['config']['fw_type'],
                                                     'fw_version': config[context]['config']['version'],
                                                     'type': 'policy_source',
                                                     'policy_name': config[context]['policies'][policy]['policyName'],
                                                     'policy_num': config[context]['policies'][policy]['policyNum'],
                                                     'policy_uinum': config[context]['policies'][policy]['policyUiNum'],
                                                     'src_zone': config[context]['policies'][policy]['policySrcZone'],
                                                     'dst_zone': config[context]['policies'][policy]['policyDstZone'],
                                                     'orig_policy': config[context]['policies'][policy],
                                                     'searchaddress': searchnet,
                                                     'oldaddress': address, \
                                                     'newaddress': newaddr})
                                    for policy in config[context]['policies']:
                                        if config[context]['policies'][policy][
                                            'policyName'] not in options.cipblacklist:
                                            if address in config[context]['policies'][policy]['policyDstNet']:
                                                if address not in change[context]['dests']: change[context]['dests'][
                                                    address] = []
                                                change[context]['dests'][address].append(
                                                    {'devname': config[context]['config']['name'],
                                                     'fw_type': config[context]['config']['fw_type'],
                                                     'fw_version': config[context]['config']['version'],
                                                     'type': 'policy_dest',
                                                     'policy_name': config[context]['policies'][policy]['policyName'],
                                                     'policy_num': config[context]['policies'][policy]['policyNum'],
                                                     'policy_uinum': config[context]['policies'][policy]['policyUiNum'],
                                                     'src_zone': config[context]['policies'][policy]['policySrcZone'],
                                                     'dst_zone': config[context]['policies'][policy]['policyDstZone'],
                                                     'orig_policy': config[context]['policies'][policy],
                                                     'searchaddress': searchnet,
                                                     'oldaddress': address,
                                                     'newaddress': newaddr})

                                    for policy in config[context]['nat']:
                                        if config[context]['nat'][policy]['natPolicyName'] not in options.cipblacklist:
                                            if address in config[context]['nat'][policy]['natPolicyOrigSrc']:
                                                if address not in change[context]['nat']: change[context]['nat'][
                                                    address] = []
                                                change[context]['nat'][address].append(
                                                    {'devname': config[context]['config']['name'],
                                                     'fw_type': config[context]['config']['fw_type'],
                                                     'fw_version': config[context]['config']['version'],
                                                     'searchaddress': searchnet,
                                                     'type': 'natPolicyOrigSrc',
                                                     'policy_name': config[context]['nat'][policy]['natPolicyName'],
                                                     'policy_num': config[context]['nat'][policy]['natPolicyNum'],
                                                     'policy_uinum': config[context]['nat'][policy]['natPolicyUiNum'],
                                                     'searchaddress': searchnet,
                                                     'oldaddress': address,
                                                     'newaddress': newaddr})
                                            if address in config[context]['nat'][policy]['natPolicyOrigDst']:
                                                if address not in change[context]['nat']: change[context]['nat'][
                                                    address] = []
                                                change[context]['nat'][address].append(
                                                    {'devname': config[context]['config']['name'],
                                                     'fw_type': config[context]['config']['fw_type'],
                                                     'fw_version': config[context]['config']['version'],
                                                     'type': 'natPolicyOrigDst',
                                                     'policy_name': config[context]['nat'][policy]['natPolicyName'],
                                                     'policy_num': config[context]['nat'][policy]['natPolicyNum'],
                                                     'policy_uinum': config[context]['nat'][policy]['natPolicyUiNum'],
                                                     'oldaddress': address,
                                                     'newaddress': newaddr})
                                            if address in config[context]['nat'][policy]['natPolicyTransSrc']:
                                                if address not in change[context]['nat']: change[context]['nat'][
                                                    address] = []
                                                change[context]['nat'][address].append(
                                                    {'devname': config[context]['config']['name'],
                                                     'fw_type': config[context]['config']['fw_type'],
                                                     'fw_version': config[context]['config']['version'],
                                                     'type': 'natPolicyTransSrc',
                                                     'policy_name': config[context]['nat'][policy]['natPolicyName'],
                                                     'policy_num': config[context]['nat'][policy]['natPolicyNum'],
                                                     'policy_uinum': config[context]['nat'][policy]['natPolicyUiNum'],
                                                     'searchaddress': searchnet,
                                                     'oldaddress': address,
                                                     'newaddress': newaddr})
                                            if address in config[context]['nat'][policy]['natPolicyTransDst']:
                                                if address not in change[context]['nat']: change[context]['nat'][
                                                    address] = []
                                                change[context]['nat'][address].append(
                                                    {'devname': config[context]['config']['name'],
                                                     'fw_type': config[context]['config']['fw_type'],
                                                     'fw_version': config[context]['config']['version'],
                                                     'type': 'natPolicyTransDst',
                                                     'policy_name': config[context]['nat'][policy]['natPolicyName'],
                                                     'policy_num': config[context]['nat'][policy]['natPolicyNum'],
                                                     'policy_uinum': config[context]['nat'][policy]['natPolicyUiNum'],
                                                     'searchaddress': searchnet,
                                                     'oldaddress': address,
                                                     'newaddress': newaddr})
    # print(change)
    return change


def cip_audit(subnets):
    from netaddr import IPSet
    import os
    from urllib.parse import unquote as url_unquote
    import ipaddress

    searchnets = []
    sourcenets = IPSet([])
    destnets = IPSet([])
    # change = OrderedDict()

    for network in subnets:
        if len(os.path.basename(network)) > 0:
            if os.path.basename(network[0]) == '@':
                for i in file_to_list(network[1:]):
                    if i[0] != '#':
                        searchnets.append(i.rstrip().split(','))
            else:
                searchnets.append(network.split(','))

    match_id = 0

    for context in contexts:
        for policy in config[context]['policies']:
            srcmatches = 0
            dstmatches = 0
            src_match_list_old = []
            src_match_list_new = []
            dst_match_list_old = []
            dst_match_list_new = []
            for source in config[context]['policies'][policy]['policySrcNet']:
                for address in expand_address(config[context]['addresses'], source, config[context]['addressmappings'],
                                              inc_group=False):
                    if config[context]['addresses'][address]['IPv4Networks'][0].prefixlen > 8:
                        for searchnet, newnet in searchnets:
                            if IPSet([str(x) for x in config[context]['addresses'][address]['IPv4Networks']]) & IPSet(
                                    [searchnet]):
                                if (address,
                                    config[context]['addresses'][address]['IPv4Networks']) not in src_match_list_old:
                                    src_match_list_old.append((address, config[context]['addresses'][address][
                                        'addrObjIp1'] + ' - ' + config[context]['addresses'][address]['addrObjIp2']))
                            if IPSet([str(x) for x in config[context]['addresses'][address]['IPv4Networks']]) & IPSet(
                                    [newnet]):
                                if (address,
                                    config[context]['addresses'][address]['IPv4Networks']) not in src_match_list_new:
                                    src_match_list_new.append((address, config[context]['addresses'][address][
                                        'addrObjIp1'] + ' - ' + config[context]['addresses'][address]['addrObjIp2']))

            for dest in config[context]['policies'][policy]['policyDstNet']:
                for address in expand_address(config[context]['addresses'], dest, config[context]['addressmappings'],
                                              inc_group=False):
                    if config[context]['addresses'][address]['IPv4Networks'][0].prefixlen > 8:
                        for searchnet, newnet in searchnets:
                            if IPSet([str(x) for x in config[context]['addresses'][address]['IPv4Networks']]) & IPSet(
                                    [searchnet]):
                                if (address,
                                    config[context]['addresses'][address]['IPv4Networks']) not in dst_match_list_old:
                                    dst_match_list_old.append((address, config[context]['addresses'][address][
                                        'addrObjIp1'] + ' - ' + config[context]['addresses'][address]['addrObjIp2']))
                            if IPSet([str(x) for x in config[context]['addresses'][address]['IPv4Networks']]) & IPSet(
                                    [newnet]):
                                if (address,
                                    config[context]['addresses'][address]['IPv4Networks']) not in dst_match_list_new:
                                    dst_match_list_new.append((address, config[context]['addresses'][address][
                                        'addrObjIp1'] + ' - ' + config[context]['addresses'][address]['addrObjIp2']))

            if src_match_list_old != [] or src_match_list_new != [] or dst_match_list_old != [] or dst_match_list_new != []:
                log(policy, config[context]['policies'][policy]['policyName'])
                log('-' * 180)
                if src_match_list_old != [] or src_match_list_new != []:
                    log('Sources')
                    log('-' * 180)
                    for match in src_match_list_old:
                        log('oldnet:', match)
                    for match in src_match_list_new:
                        log('newnet:', match)
                if dst_match_list_old != [] or dst_match_list_new != []:
                    log('Destinations')
                    log('-' * 180)
                    for match in dst_match_list_old:
                        log('oldnet:', match)
                    for match in dst_match_list_new:
                        log('newnet:', match)

    '''

    for context in contexts:
        if 'version' not in config[context]['config']: config[context]['config']['version']=''
        change[context]=OrderedDict()
        change[context]['fw_type']=config[context]['config']['fw_type']
        change[context]['groups']=OrderedDict()
        change[context]['addresses']=OrderedDict()
        change[context]['sources']=OrderedDict()
        change[context]['dests']=OrderedDict()
        change[context]['nat']=OrderedDict()
        change[context]['colors']=OrderedDict()
        change[context]['group_policies']=OrderedDict()
        expanded={'groups': OrderedDict(),
        'policy_src': OrderedDict(),
        'policy_dst': OrderedDict(),
        'nat_orig_src': OrderedDict(),
        'nat_orig_dst': OrderedDict(),
        'nat_trans_src': OrderedDict(),
        'nat_trans_dst': OrderedDict(),
        'all': [] }

        expanded['all']=[]
        for group in config[context]['addresses']:
            if config[context]['addresses'][group]['addrObjType']=='8':
                tmplist=expand_address(config[context]['addresses'], group, config[context]['addressmappings'], inc_group=True)
                expanded['groups'][group]=tmplist

        for policy in config[context]['policies']:
            expanded['policy_src'][policy]=[]
            expanded['policy_dst'][policy]=[]
            
            for pol_src in config[context]['policies'][policy]['policySrcNet']:
                tmplist=expand_address(config[context]['addresses'], pol_src, config[context]['addressmappings'], inc_group=True)
                expanded['policy_src'][policy].extend(tmplist)
                expanded['all'].extend(tmplist)
            
            for pol_dst in config[context]['policies'][policy]['policyDstNet']:
                tmplist=expand_address(config[context]['addresses'], pol_dst, config[context]['addressmappings'], inc_group=True)
                expanded['policy_dst'][policy].extend(tmplist)
                expanded['all'].extend(tmplist)
                
        if 'nat' in config[context]:
            for policy in config[context]['nat']:
                expanded['nat_orig_src'][policy]=[]
                expanded['nat_orig_dst'][policy]=[]
                expanded['nat_trans_src'][policy]=[]
                expanded['nat_trans_dst'][policy]=[]

                for nat_src in config[context]['nat'][policy]['natPolicyOrigSrc']:
                    tmplist=expand_address(config[context]['addresses'], nat_src, config[context]['addressmappings'], inc_group=True)
                    expanded['nat_orig_src'][policy].extend(tmplist)
                    expanded['all'].extend(tmplist)
                for nat_dst in config[context]['nat'][policy]['natPolicyOrigDst']:
                    tmplist=expand_address(config[context]['addresses'], nat_dst, config[context]['addressmappings'], inc_group=True)
                    expanded['nat_orig_dst'][policy].extend(tmplist)
                    expanded['all'].extend(tmplist)
                for nat_src in config[context]['nat'][policy]['natPolicyTransSrc']:
                    tmplist=expand_address(config[context]['addresses'], nat_src, config[context]['addressmappings'], inc_group=True)
                    expanded['nat_trans_src'][policy].extend(tmplist)
                    expanded['all'].extend(tmplist)
                for nat_dst in config[context]['nat'][policy]['natPolicyTransDst']:
                    tmplist=expand_address(config[context]['addresses'], nat_dst, config[context]['addressmappings'], inc_group=True)
                    expanded['nat_trans_dst'][policy].extend(tmplist)
                    expanded['all'].extend(tmplist)
            

        complete_matches=[] # CHANGEME - not sure what these were used for and I believe they can be removed
        partial_matches=[]
        
        addresses_to_add=[]
        for idx, address in enumerate(config[context]['addresses']):
            ## only perform matching for hosts, ranges and networks
            if config[context]['addresses'][address]['addrObjType'] in ['1', '2', '4', '91']:
                addressnets=IPSet([])
                for member in expand_address(config[context]['addresses'],address,config[context]['addressmappings']):  ## why is this being done for addr types 1,2,4,91??
                    for network in config[context]['addresses'][member]['IPv4Networks']:
                        if network.prefixlen > 8 :
                            addressnets.add(str(network))
                tmp_addr=None
                if address in config[context]['addresses']:
                    tmp_addr=config[context]['addresses'][address]
                elif address in config['shared']['addresses'] and config[context]['config']['fw_type']=='panorama':
                    tmp_addr=config['shared']['addresses'][address]
                if tmp_addr!=None:
                    if tmp_addr['addrObjType'] == '1': addr_type='host'
                    elif tmp_addr['addrObjType'] == '2': addr_type='range'
                    elif tmp_addr['addrObjType'] == '4': addr_type='network'
                    elif tmp_addr['addrObjType'] == '8': addr_type='group'
                    elif tmp_addr['addrObjType'] == '91': addr_type='cluster_member'
                    else: addr_type=tmp_addr['addrObjType']

                for searchnet,newnet in searchnets:
                    if ipaddress.IPv4Network(searchnet).prefixlen >= ipaddress.IPv4Network(newnet).prefixlen or addressnets==IPSet([searchnet]): ## allow for replacement of larger to smaller for exact matches
                        newaddr=None
                        search=IPSet([searchnet])
                        if addr_type in ['host', 'range', 'network', 'cluster_member']:
                            addr_matches=addressnets & search
                        else:
                            addr_matches=''
                        if addressnets and ((addressnets & search) == addressnets) or ( addressnets & search ): ### if its a complete or partial match...
                            if addressnets==search:
                                match_type='exact'
                            elif addressnets and ((addressnets & search) == addressnets):
                                match_type='complete'
                            else:
                                match_type='partial'
                            ## determine new object information
                            if match_type!='partial' or options.exclude_partial==False:
                                if config[context]['addresses'][address]['addrObjType']=='1': ## host
                                    try:
                                        hidx=list(ipaddress.IPv4Network(searchnet)).index(ipaddress.IPv4Address(config[context]['addresses'][address]['IPv4Networks'][0][0]))
                                        newip1=str(list(ipaddress.IPv4Network(newnet))[hidx])
                                        newip2='255.255.255.255'
                                        newaddr="H-"+str(newip1)
                                    except:
                                        log ('ERROR')
                                    
                                elif config[context]['addresses'][address]['addrObjType']=='2': ## range
                                    if match_type=='complete':
                                        rfidx=list(ipaddress.IPv4Network(searchnet)).index(ipaddress.IPv4Address(config[context]['addresses'][address]['IPv4Networks'][0][0]))
                                        rlidx=list(ipaddress.IPv4Network(searchnet)).index(ipaddress.IPv4Address(config[context]['addresses'][address]['IPv4Networks'][-1][-1]))
                                        newip1=str(list(ipaddress.IPv4Network(newnet))[rfidx])
                                        newip2=str(list(ipaddress.IPv4Network(newnet))[rlidx])
                                        newaddr="R-"+str(newip1)+'-'+str(newip2)
                                    else:
                                        ## if searchnet is entirely contained within the range, do the same thing as we do for networks and just create a new network object
                                        log('WARNING -- range object with a partial match - this needs to be handled manually')
                                        log ('DETAILS -- Search Network : {search}  Range Start: {rstart} Range End: {rend}'.format(search=searchnet, rstart=config[context]['addresses'][address]['addrObjIp1'], rend=config[context]['addresses'][address]['addrObjIp2']))
                                        if ipaddress.IPv4Address(config[context]['addresses'][address]['IPv4Networks'][0][0]) in list(ipaddress.IPv4Network(searchnet)):
                                            rfidx=list(ipaddress.IPv4Network(searchnet)).index(ipaddress.IPv4Address(config[context]['addresses'][address]['IPv4Networks'][0][0]))
                                        else:
                                            rfidx=0
                                        if ipaddress.IPv4Address(config[context]['addresses'][address]['IPv4Networks'][-1][-1]) in list(ipaddress.IPv4Network(searchnet)):
                                            rlidx=list(ipaddress.IPv4Network(searchnet)).index(ipaddress.IPv4Address(config[context]['addresses'][address]['IPv4Networks'][-1][-1]))
                                        else:
                                            rlidx=-1
                                        newip1=str(list(ipaddress.IPv4Network(newnet))[rfidx])
                                        newip2=str(list(ipaddress.IPv4Network(newnet))[rlidx])
                                        newaddr="R-"+str(newip1)+'-'+str(newip1).split('.')[3]
                                        newaddr="R-"+str(newip1)+'-'+str(newip2)
                                elif config[context]['addresses'][address]['addrObjType']=='4': ## network
                                    if match_type=='complete':
                                        nidx=list(ipaddress.IPv4Network(searchnet)).index(ipaddress.IPv4Address(config[context]['addresses'][address]['IPv4Networks'][0][0])) # complete match index - searched network is a superset of the current address object
                                        nlen=config[context]['addresses'][address]['IPv4Networks'][0].prefixlen    
                                        newip1=str(list(ipaddress.IPv4Network(newnet))[nidx])
                                        newip2=str(cidr_to_netmask(nlen))
                                        newaddr='N-' + newip1+'-' + str(netmask_to_cidr(newip2))
                                    else:
                                        if len(re.findall('/',newnet))>0:
                                            newip1, newip2=newnet.split('/')
                                            newip2=cidr_to_netmask(newip2)
                                        else:
                                            newip1=newnet
                                            newip2='255.255.255.255'
                                        newaddr='N-' + newip1 + '-' + str(netmask_to_cidr(newip2))
                                if newaddr!=None:
                                    if newaddr in config[context]['addresses']:
                                        while newaddr in config[context]['addresses']:
                                            newaddr=newaddr+'_DUPE'
                                        log('WARNING -- existing address already exists with the proposed new name, renaming to : ' + newaddr, level=logging.INFO)
                                        
                                    if searchnet not in change[context]['addresses']:
                                        change[context]['addresses'][searchnet]=[]
                                    
                                    ## consider changing new addresses to include list of tuple searchaddress,oldaddress
                                    ## consider keeping track of the number of matches
                                    if expanded['all'].count(address)==0:
                                        debug('Object {} not found in any policy'.format(address))                    
                                    if match_type.lower()!='partial':
                                        skip_address='no'
                                    else:
                                        skip_address='yes'
                                    change[context]['addresses'][searchnet].append({    'devname': config[context]['config']['name'], 
                                                                                        'fw_type': config[context]['config']['fw_type'], 
                                                                                        'fw_version': config[context]['config']['version'],
                                                                                        'context' : context,
                                                                                        'match': match_type, 
                                                                                        'match_id': match_id,
                                                                                        'type': addr_type, 
                                                                                        'mapping': 'root', 
                                                                                        'searchaddress': searchnet, 
                                                                                        'oldaddress': address,
                                                                                        'old_ip1': config[context]['addresses'][address]['addrObjIp1'],
                                                                                        'old_ip2': config[context]['addresses'][address]['addrObjIp2'],
                                                                                        'zone': config[context]['addresses'][address]['addrObjZone'],
                                                                                        'new_addr': newaddr,
                                                                                        'new_ip1' : newip1,
                                                                                        'new_ip2' : newip2,
                                                                                        'matchlen' : int(netmask_to_cidr(config[context]['addresses'][address]['addrObjIp2'])),
                                                                                        'comment' : 'WAS: ' + address + ' - ' + config[context]['addresses'][address]['addrObjComment'],
                                                                                        'oldcolor': config[context]['addresses'][address]['addrObjColor'],
                                                                                        'color' : config[context]['addresses'][address]['addrObjColor'],
                                                                                        'skip' : skip_address,
                                                                                        'inuse' : expanded['all'].count(address)

                                                                                        })
                                    match_id += 1
                                    if newaddr not in change[context]['colors']:
                                        change[context]['colors'][newaddr]={}
                                        change[context]['colors'][newaddr]['color']=config[context]['addresses'][address]['addrObjColor']
                                        change[context]['colors'][newaddr]['matchlen']=int(netmask_to_cidr(config[context]['addresses'][address]['addrObjIp2']))
                                    if int(netmask_to_cidr(config[context]['addresses'][address]['addrObjIp2'])) > change[context]['colors'][newaddr]['matchlen'] and expanded['all'].count(address) > 0 :
                                        change[context]['colors'][newaddr]['color']=config[context]['addresses'][address]['addrObjColor']
                                        change[context]['colors'][newaddr]['matchlen']=int(netmask_to_cidr(config[context]['addresses'][address]['addrObjIp2']))
                                    addresses_to_add.append(newaddr)
                                    for group in config[context]['addressmappings']                        :
                                        if address in config[context]['addressmappings'][group]:
                                            if address not in change[context]['groups']: change[context]['groups'][address]=[]
                                            change[context]['groups'][address].append({   'devname': config[context]['config']['name'], 
                                                                                        'fw_type': config[context]['config']['fw_type'],
                                                                                        'fw_version': config[context]['config']['version'],
                                                                                        'type' : 'group',
                                                                                        'searchaddress': searchnet,
                                                                                        'oldmember': member,
                                                                                        'newmember': newaddr,
                                                                                        'group' : group
                                                                                        })
                                        ## move matched_policies routing from report to here -- this is needed since it relies on having "config" available
                                        
                                            matched_policies={}
                                            for p in config[context]['policies']:
                                                if config[context]['policies'][p]['policyName'] not in options.cipblacklist:
                                                    policy_addresses=[]
                                                    for s in config[context]['policies'][p]['policySrcNet']:
                                                        policy_addresses.extend(expand_address(config[context]['addresses'], s, config[context]['addressmappings'], inc_group=True))
                                                        policy_addresses.extend([s])
                                                    for d in config[context]['policies'][p]['policyDstNet']:
                                                        policy_addresses.extend(expand_address(config[context]['addresses'], s, config[context]['addressmappings'], inc_group=True))
                                                        policy_addresses.extend([d])
                                                    if group in policy_addresses:
                                                        if config[context]['policies'][p]['policyName'] not in matched_policies: 
                                                            #matched_policies.append(config[context]['policies'][p]['policyName'])
                                                            matched_policies[config[context]['policies'][p]['policyName']]=[config[context]['policies'][p]['policyUiNum']]
                                                        else:
                                                            matched_policies[config[context]['policies'][p]['policyName']].append(config[context]['policies'][p]['policyUiNum'])

                                            change[context]['group_policies'][group]=matched_policies
                                    for policy in config[context]['policies']:
                                        if config[context]['policies'][policy]['policyName'] not in options.cipblacklist:
                                            if address in config[context]['policies'][policy]['policySrcNet']:
                                                if address not in change[context]['sources']: change[context]['sources'][address]=[]
                                                change[context]['sources'][address].append({  'devname': config[context]['config']['name'], 
                                                                                            'fw_type': config[context]['config']['fw_type'],
                                                                                            'fw_version': config[context]['config']['version'],
                                                                                            'type': 'policy_source',
                                                                                            'policy_name': config[context]['policies'][policy]['policyName'],
                                                                                            'policy_num': config[context]['policies'][policy]['policyNum'],
                                                                                            'policy_uinum': config[context]['policies'][policy]['policyUiNum'],
                                                                                            'src_zone': config[context]['policies'][policy]['policySrcZone'],
                                                                                            'dst_zone': config[context]['policies'][policy]['policyDstZone'],
                                                                                            'orig_policy': config[context]['policies'][policy],
                                                                                            'searchaddress': searchnet,
                                                                                            'oldaddress' : address,
                                                                                            'newaddress': newaddr })
                                    for policy in config[context]['policies']:
                                        if config[context]['policies'][policy]['policyName'] not in options.cipblacklist:
                                            if address in config[context]['policies'][policy]['policyDstNet']:
                                                if address not in change[context]['dests']: change[context]['dests'][address]=[]
                                                change[context]['dests'][address].append({    'devname': config[context]['config']['name'], 
                                                                                            'fw_type': config[context]['config']['fw_type'],
                                                                                            'fw_version': config[context]['config']['version'],
                                                                                            'type' : 'policy_dest',
                                                                                            'policy_name': config[context]['policies'][policy]['policyName'],
                                                                                            'policy_num': config[context]['policies'][policy]['policyNum'],
                                                                                            'policy_uinum': config[context]['policies'][policy]['policyUiNum'],
                                                                                            'src_zone': config[context]['policies'][policy]['policySrcZone'],
                                                                                            'dst_zone': config[context]['policies'][policy]['policyDstZone'],
                                                                                            'orig_policy': config[context]['policies'][policy],
                                                                                            'searchaddress': searchnet,
                                                                                            'oldaddress' : address,
                                                                                            'newaddress': newaddr })
                                        

                                    for policy in config[context]['nat']:
                                        if config[context]['nat'][policy]['natPolicyName'] not in options.cipblacklist:
                                            if address in config[context]['nat'][policy]['natPolicyOrigSrc']:
                                                if address not in change[context]['nat']: change[context]['nat'][address]=[]
                                                change[context]['nat'][address].append({        'devname': config[context]['config']['name'], 
                                                                                                'fw_type': config[context]['config']['fw_type'],
                                                                                                'fw_version': config[context]['config']['version'],
                                                                                                'searchaddress': searchnet,
                                                                                                'type' : 'natPolicyOrigSrc',
                                                                                                'policy_name': config[context]['nat'][policy]['natPolicyName'],
                                                                                                'policy_num': config[context]['nat'][policy]['natPolicyNum'],
                                                                                                'policy_uinum': config[context]['nat'][policy]['natPolicyUiNum'],
                                                                                                'searchaddress': searchnet,
                                                                                                'oldaddress' : address,
                                                                                                'newaddress': newaddr })
                                            if address in config[context]['nat'][policy]['natPolicyOrigDst']:
                                                if address not in change[context]['nat']: change[context]['nat'][address]=[]
                                                change[context]['nat'][address].append({        'devname': config[context]['config']['name'], 
                                                                                                'fw_type': config[context]['config']['fw_type'],
                                                                                                'fw_version': config[context]['config']['version'],
                                                                                                'type' : 'natPolicyOrigDst',
                                                                                                'policy_name': config[context]['nat'][policy]['natPolicyName'],
                                                                                                'policy_num': config[context]['nat'][policy]['natPolicyNum'],
                                                                                                'policy_uinum': config[context]['nat'][policy]['natPolicyUiNum'],
                                                                                                'oldaddress' : address,
                                                                                                'newaddress': newaddr })
                                            if address in config[context]['nat'][policy]['natPolicyTransSrc']:
                                                if address not in change[context]['nat']: change[context]['nat'][address]=[]
                                                change[context]['nat'][address].append({        'devname': config[context]['config']['name'], 
                                                                                                'fw_type': config[context]['config']['fw_type'],
                                                                                                'fw_version': config[context]['config']['version'],
                                                                                                'type' : 'natPolicyTransSrc',
                                                                                                'policy_name': config[context]['nat'][policy]['natPolicyName'],
                                                                                                'policy_num': config[context]['nat'][policy]['natPolicyNum'],
                                                                                                'policy_uinum': config[context]['nat'][policy]['natPolicyUiNum'],
                                                                                                'searchaddress': searchnet,
                                                                                                'oldaddress' : address,
                                                                                                'newaddress': newaddr })
                                            if address in config[context]['nat'][policy]['natPolicyTransDst']:
                                                if address not in change[context]['nat']: change[context]['nat'][address]=[]
                                                change[context]['nat'][address].append({        'devname': config[context]['config']['name'], 
                                                                                                'fw_type': config[context]['config']['fw_type'],
                                                                                                'fw_version': config[context]['config']['version'],
                                                                                                'type' : 'natPolicyTransDst',
                                                                                                'policy_name': config[context]['nat'][policy]['natPolicyName'],
                                                                                                'policy_num': config[context]['nat'][policy]['natPolicyNum'],
                                                                                                'policy_uinum': config[context]['nat'][policy]['natPolicyUiNum'],
                                                                                                'searchaddress': searchnet,
                                                                                                'oldaddress' : address,
                                                                                                'newaddress': newaddr })
    return change
    '''


def cip_report2(change, showskipped=True):
    ## BEGIN REPORT
    report_width = 100
    if options.web: set_web_tab('report')
    policy_matches = OrderedDict()
    for context in contexts:
        # policy_matches=OrderedDict()
        for saddr in change[context]['addresses']:
            log('++' + '=' * report_width + '++')
            log('++   Searched Network Object : {:25.25s}{:45.45s} ++'.format(saddr, ''))
            log('++' + '=' * report_width + '++')
            log('')
            for faddr in change[context]['addresses'][saddr]:
                skip_address = faddr['skip'].lower()[0]
                if skip_address != 'y' or showskipped:
                    oldaddr = faddr['oldaddress']
                    newaddr = faddr['new_addr']
                    log('||' + '=' * report_width + '||')
                    log('|| Address Match : {:50.50s}{:33.33s}||'.format(url_unquote(oldaddr), ''))
                    log('||' + '=' * report_width + '||')
                    log('|| {:12.12s} : {:33.33s} {:50.50s}||'.format('Context', faddr['context'], ''))
                    log('|| {:12.12s} : {:33.33s} {:50.50s}||'.format('Address Type', faddr['type'], ''))
                    log('|| {:12.12s} : {:33.33s} {:50.50s}||'.format('Match Type', faddr['match'], ''))
                    log('|| {:12.12s} : {:33.33s} {:50.50s}||'.format('Skipped', str(skip_address == 'y'), ''))
                    log('|| {:12.12s} : {:33.33s} {:50.50s}||'.format('In Use Count', str(faddr['inuse']), ''))
                    log('|| {:12.12s} : {:49.49s} {:15.15s} - {:15.15s} ||'.format('Old Address', url_unquote(oldaddr),
                                                                                   faddr['old_ip1'], faddr['old_ip2']))
                    log('|| {:12.12s} : {:49.49s} {:15.15s} - {:15.15s} ||'.format('New Address', newaddr,
                                                                                   faddr['new_ip1'], faddr['new_ip2']))
                    log('||' + '=' * report_width + '||')

                    if oldaddr in change[context]['groups']:
                        log('|| Group Matches' + ' ' * (report_width - 14) + '||')
                        log('||' + '=' * report_width + '||')
                        for fgaddr in change[context]['groups'][oldaddr]:
                            if newaddr == fgaddr['newmember']:
                                for match in change[context]['group_policies'][fgaddr['group']]:
                                    log('|| {:30.30s} {:30.30s} {:30.30s}{:7.7s}||'.format(url_unquote(fgaddr['group']),
                                                                                           fgaddr['newmember'],
                                                                                           match,
                                                                                           ''
                                                                                           ))
                            if skip_address != 'y' and fgaddr['fw_type'] == 'checkpoint':
                                for policy in change[context]['group_policies'][fgaddr['group']]:
                                    if policy not in policy_matches:
                                        policy_matches[policy] = change[context]['group_policies'][fgaddr['group']][
                                            policy]
                        log('||' + '=' * report_width + '||')
                    else:
                        log('|| No Group Matches' + ' ' * (report_width - 17) + '||')
                        log('||' + '=' * report_width + '||')
                    if oldaddr in change[context]['sources'] or oldaddr in change[context]['dests']:
                        log('|| Security Policy Matches' + ' ' * (report_width - 24) + '||')
                        log('||' + '=' * report_width + '||')
                        if oldaddr in change[context]['sources']:
                            for fpaddr in change[context]['sources'][oldaddr]:
                                if newaddr == fpaddr['newaddress']:
                                    log('|| {:20.20s} {:50.50s} {:7.7s} {:7.7s} {:11.11s}||'.format(fpaddr['type'],
                                                                                                    fpaddr[
                                                                                                        'policy_name'],
                                                                                                    str(fpaddr[
                                                                                                            'policy_num']),
                                                                                                    str(fpaddr[
                                                                                                            'policy_uinum']),
                                                                                                    ''
                                                                                                    ))
                                    if (skip_address != 'y' or showskipped) and fpaddr['fw_type'] == 'checkpoint':
                                        if fpaddr['policy_name'] not in policy_matches:
                                            policy_matches[fpaddr['policy_name']] = [
                                                (fpaddr['policy_uinum'], fpaddr['policy_num'])]
                                        elif (fpaddr['policy_uinum'], fpaddr['policy_num']) not in policy_matches[
                                            fpaddr['policy_name']]:
                                            policy_matches[fpaddr['policy_name']].append(
                                                (fpaddr['policy_uinum'], fpaddr['policy_num']))
                        if oldaddr in change[context]['dests']:
                            for fpaddr in change[context]['dests'][oldaddr]:
                                if newaddr == fpaddr['newaddress']:
                                    log('|| {:20.20s} {:50.50s} {:7.7s} {:7.7s} {:11.11s}||'.format(fpaddr['type'],
                                                                                                    fpaddr[
                                                                                                        'policy_name'],
                                                                                                    str(fpaddr[
                                                                                                            'policy_num']),
                                                                                                    str(fpaddr[
                                                                                                            'policy_uinum']),
                                                                                                    ''
                                                                                                    ))
                                    if (skip_address != 'y' or showskipped) and fpaddr['fw_type'] == 'checkpoint':
                                        if fpaddr['policy_name'] not in policy_matches:
                                            policy_matches[fpaddr['policy_name']] = [
                                                (fpaddr['policy_uinum'], fpaddr['policy_num'])]
                                        elif (fpaddr['policy_uinum'], fpaddr['policy_num']) not in policy_matches[
                                            fpaddr['policy_name']]:
                                            policy_matches[fpaddr['policy_name']].append(
                                                (fpaddr['policy_uinum'], fpaddr['policy_num']))
                        log('||' + '=' * report_width + '||')
                    else:
                        log('|| NO Security Policy Matches' + ' ' * (report_width - 27) + '||')
                        log('||' + '=' * report_width + '||')
                    if oldaddr in change[context]['nat']:
                        log('|| NAT Policy Matches' + ' ' * (report_width - 19) + '||')
                        log('||' + '=' * report_width + '||')
                        for fnaddr in change[context]['nat'][oldaddr]:
                            if newaddr == fnaddr['newaddress']:
                                log('|| {:20.20s} {:50.50s} {:7.7s} {:7.7s} {:11.11s}||'.format(fnaddr['type'],
                                                                                                fnaddr['policy_name'],
                                                                                                str(fnaddr[
                                                                                                        'policy_num']),
                                                                                                str(fnaddr[
                                                                                                        'policy_uinum']),
                                                                                                ''
                                                                                                ))
                                if (skip_address != 'y' or showskipped) and fnaddr['fw_type'] == 'checkpoint':
                                    if fnaddr['policy_name'] not in policy_matches:
                                        policy_matches[fnaddr['policy_name']] = [
                                            (fnaddr['policy_uinum'], fnaddr['policy_num'])]
                                    elif (fnaddr['policy_uinum'], fnaddr['policy_num']) not in policy_matches[
                                        fnaddr['policy_name']]:
                                        policy_matches[fnaddr['policy_name']].append(
                                            (fnaddr['policy_uinum'], fnaddr['policy_num']))
                        log('||' + '=' * report_width + '||')
                    else:
                        log('|| NO NAT Policy Matches' + ' ' * (report_width - 22) + '||')
                        log('||' + '=' * report_width + '||')
                    log('')
    log('||' + '=' * (report_width + 40) + '||')
    log('|| Effected Policies' + ' ' * (report_width + 22) + '||')
    log('||' + '=' * (report_width + 40) + '||')

    if len(policy_matches) > 0:
        # log('|| Policy Nums' + ' ' * (report_width+28) + '||')
        col1_size = len(max(policy_matches, key=len))
        col2_size = 136 - col1_size
        for match in policy_matches:
            log('|| {:<{col1_size}} : {:<{col2_size}}||'.format(match, ', '.join(
                [str(num) for uinum, num in policy_matches[match]]), col1_size=col1_size, col2_size=col2_size))
        log('||' + '=' * (report_width + 40) + '||')
        log('|| Policy UI Nums' + ' ' * (report_width + 25) + '||')
        for match in policy_matches:
            log('|| {:<{col1_size}} : {:<{col2_size}}||'.format(match, ', '.join(
                [str(uinum) for uinum, num in policy_matches[match]]), col1_size=col1_size, col2_size=col2_size))
    else:
        log('|| NONE' + ' ' * (report_width + 35) + '||')
    log('||' + '=' * (report_width + 40) + '||')
    return


def cip_match_reviewout(change, filename=''):
    if options.web: set_web_tab('reviewout')
    log('#context,type,matchtype,mID,searchaddress,oldaddress,old_addr1,old_addr2,new_addr,new_ip1,new_ip2,old_color,new_color,comment,use_count,skip,DO_NOT_CHANGE')
    if options.web: log('## https://10.215.19.133/lab/cgi-bin/migrate.py?Submit=true&cipsubmit=' + timestr)
    for context in change:
        for saddr in change[context]['addresses']:
            for index, faddr in enumerate(change[context]['addresses'][saddr]):
                log('{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{}'.format(
                    context,
                    faddr['type'],
                    faddr['match'],
                    faddr['match_id'],
                    faddr['searchaddress'],
                    faddr['oldaddress'],
                    faddr['old_ip1'],
                    faddr['old_ip2'],
                    faddr['new_addr'],
                    faddr['new_ip1'],
                    faddr['new_ip2'],
                    faddr['oldcolor'],
                    change[context]['colors'][faddr['new_addr']]['color'],
                    faddr['comment'],
                    faddr['inuse'],
                    faddr['skip'],
                    str(index)))
    return


def cip_match_reviewin(filename, change, matchesonly=False):
    ## consider updating routines to
    import copy
    # newchanges=copy.deepcopy(changes)

    with open(filename, 'r') as infile:
        for line in infile:
            if line[0] != '#':
                try:
                    context, addrtype, match, mID, searchaddress, oldaddress, old_ip1, old_ip2, new_addr, new_ip1, new_ip2, oldcolor, color, comment, usecount, skip, index = line.strip().split(
                        ',')
                except:
                    try:
                        context, addrtype, match, mID, searchaddress, oldaddress, old_ip1, old_ip2, new_addr, new_ip1, new_ip2, oldcolor, color, comment, usecount, skip, index = line.strip().split(
                            '\t')
                    except:
                        log('Error parsing infile')
                        return False
                log('{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{}'.format(context, addrtype, match, mID,
                                                                                searchaddress, oldaddress, old_ip1,
                                                                                old_ip2, new_addr, new_ip1, new_ip2,
                                                                                oldcolor, color, comment, usecount,
                                                                                skip, index))

                if context != None:
                    if searchaddress in change[context]['addresses']:
                        if change[context]['addresses'][searchaddress][int(index)]['comment'] != comment:
                            log('Replacing Comment {} with {}'.format(
                                change[context]['addresses'][searchaddress][int(index)]['comment'], comment))
                            change[context]['addresses'][searchaddress][int(index)]['comment'] = comment
                        if change[context]['addresses'][searchaddress][int(index)]['skip'] != skip:
                            log('Replacing Skip {} with {}'.format(
                                change[context]['addresses'][searchaddress][int(index)]['skip'], skip))
                            change[context]['addresses'][searchaddress][int(index)]['skip'] = skip
                        if change[context]['addresses'][searchaddress][int(index)]['color'] != color:
                            log('Replacing Color {} with {}'.format(
                                change[context]['addresses'][searchaddress][int(index)]['color'], color))
                            change[context]['addresses'][searchaddress][int(index)]['color'] = color

                        if int(index) < len(change[context]['addresses'][searchaddress]):
                            if change[context]['addresses'][searchaddress][int(index)]['new_addr'] != new_addr:
                                log('Replacing New Address Name {} with {}'.format(
                                    change[context]['addresses'][searchaddress][int(index)]['new_addr'], new_addr))
                                change[context]['addresses'][searchaddress][int(index)]['new_addr'] = new_addr
                                ## update polices and groups
                                for oldaddr in change[context]['groups']:
                                    for index, match in enumerate(change[context]['groups'][oldaddr]):
                                        if match['oldmember'] == oldaddress:
                                            change[context]['groups'][oldaddr][index]['newmember'] = new_addr
                                            log('Updating group {} with address {}'.format(match['group'], new_addr))
                                for oldaddr in change[context]['sources']:
                                    for index, match in enumerate(change[context]['sources'][oldaddr]):
                                        if match['oldaddress'] == oldaddress:
                                            change[context]['sources'][oldaddr][index]['newaddress'] = new_addr
                                            log('Updating rule {} in policy {} with address {}'.format(
                                                match['policy_name'], match['policy_num'], new_addr))
                                for oldaddr in change[context]['dests']:
                                    for index, match in enumerate(change[context]['dests'][oldaddr]):
                                        if match['oldaddress'] == oldaddress:
                                            change[context]['dests'][oldaddr][index]['newaddress'] = new_addr
                                            log('Updating rule {} in policy {} with address {}'.format(
                                                match['policy_name'], match['policy_num'], new_addr))
                                for oldaddr in change[context]['nat']:
                                    for index, match in enumerate(change[context]['nat'][oldaddr]):
                                        if match['oldaddress'] == oldaddress:
                                            change[context]['nat'][oldaddr][index]['newaddress'] = new_addr
                                            log('Updating rule {} in policy {} with address {}'.format(
                                                match['policy_name'], match['policy_num'], new_addr))
        return change


def get_fw_type(ipaddress):
    import requests
    import re

    session = requests.Session()
    session.mount(ipaddress, DESAdapter())
    urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
    try:
        response = session.get('https://' + ipaddress, verify=False, stream=True, timeout=options.timeout_sw_webui,
                               allow_redirects=False)
        if response.status_code == 302:
            # print('302 returned')
            if response.headers['Location'].lower() == '/php/login.php':
                # unable to distinguish between palo and pano via login.php content
                fw_type = 'palo'
            else:
                fw_type = 'unknown'
        elif len(re.findall('SonicWALL', response.text)) > 0:
            fw_type = 'sonicwall'
        elif len(re.findall('<TITLE>Gaia</TITLE>', response.text)) > 0:
            fw_type = 'checkpoint'
        else:
            fw_type = 'unknown'
        # if fw_type=='unknown':
        #    print(response.text)
    except Exception as e:
        # print(e)
        fw_type = 'unknown'

    return fw_type


def cip_match_dbedit(change, target='', syntax='cli', showresults=False):
    import copy
    import urllib

    for context in change:
        if len(change[context]['addresses']) > 0:
            log('#### Context: ' + context)
            debug(len(change[context]['addresses']))
        change[context]['colors'] = OrderedDict()
        for saddr in change[context]['addresses']:  ## these routines are to update the color dictionary
            for faddr in change[context]['addresses'][saddr]:
                if faddr['skip'].lower()[0] != 'y':
                    naddr = faddr['new_addr']
                    if naddr not in change[context]['colors']:
                        change[context]['colors'][naddr] = {}
                        change[context]['colors'][naddr]['color'] = faddr['color']
                        change[context]['colors'][naddr]['matchlen'] = faddr['matchlen']
                    if int(netmask_to_cidr(faddr['old_ip2'])) > change[context]['colors'][naddr]['matchlen'] and faddr[
                        'inuse'] > 0:
                        change[context]['colors'][naddr]['color'] = faddr['color']
                        change[context]['colors'][naddr]['matchlen'] = int(netmask_to_cidr(faddr['old_ip2']))

        dbedit = []
        added_addresses = []

        for saddr in change[context]['addresses']:
            for foundaddr in change[context]['addresses'][saddr]:
                faddr_copy = copy.deepcopy(foundaddr)
                faddr_copy.pop('oldmember', None)
                if foundaddr['skip'][0].lower() != 'y' and faddr_copy not in dbedit:
                    oldaddr = foundaddr['oldaddress']
                    newaddr = foundaddr['new_addr']
                    dbcolor = change[context]['colors'][newaddr]['color']
                    if str(foundaddr['new_ip1']) == '255.255.255.255':
                        debug('Skipping found address of {}'.format(oldaddr))
                    else:
                        if foundaddr['new_addr'] not in added_addresses:
                            debug(change[context]['fw_type'])
                            result = exec_fw_command(target, change[context]['fw_type'], [('create_address', {
                                'addressname': foundaddr['new_addr'], 'ip1': str(foundaddr['new_ip1']),
                                'ip2': str(foundaddr['new_ip2']), 'addresstype': foundaddr['type'],
                                'zone': foundaddr['zone'], 'color': dbcolor, 'comment': foundaddr['comment']})],
                                                     syntax=syntax)
                            added_addresses.append(foundaddr['new_addr'])
                            if showresults: log('Create Address {}: {}'.format(foundaddr['new_addr'], result))
                        # if len (change[context]['groups'][oldaddr])>0:
                        if oldaddr in change[context]['groups']:
                            for faddr in change[context]['groups'][oldaddr]:
                                faddr_copy = copy.deepcopy(faddr)
                                faddr_copy.pop('oldmember', None)
                                if newaddr == faddr['newmember']:
                                    if faddr_copy not in dbedit:
                                        dbedit.append(faddr_copy)
                                        # result=modify_rule_obj(target, session, apikey, fw_type, syntax, params)
                                        result = exec_fw_command(target, change[context]['fw_type'], [('modify_address',
                                                                                                       {
                                                                                                           'action': 'addmembers',
                                                                                                           'addressname':
                                                                                                               faddr[
                                                                                                                   'group'],
                                                                                                           'members': [
                                                                                                               faddr[
                                                                                                                   'newmember']]})],
                                                                 syntax=syntax)
                                        if showresults: log(
                                            'Add Address {} to group {}: {}'.format(faddr['newmember'], faddr['group'],
                                                                                    result))

                        if oldaddr in change[context]['sources'] or oldaddr in change[context]['dests']:
                            if oldaddr in change[context]['sources']:
                                for faddr in change[context]['sources'][oldaddr]:
                                    faddr_copy = copy.deepcopy(faddr)
                                    faddr_copy.pop('searchaddress', None)
                                    if newaddr == faddr['newaddress']:
                                        if faddr_copy not in dbedit:
                                            dbedit.append(faddr_copy)
                                            # exec_fw_command(target, change[context]['fw_type'], [('modify_address', {'action': 'addmember', 'addressname': 'test_group', 'members': [faddr['newmember']]})], syntax='cli')
                                            result = exec_fw_command(target, change[context]['fw_type'], [(
                                                                                                          'modify_rule',
                                                                                                          {
                                                                                                              'context': context,
                                                                                                              'policyname':
                                                                                                                  faddr[
                                                                                                                      'policy_name'],
                                                                                                              'policynum': str(
                                                                                                                  faddr[
                                                                                                                      'policy_num']),
                                                                                                              'action': 'addmembers',
                                                                                                              'sources': [
                                                                                                                  faddr[
                                                                                                                      'newaddress']]})],
                                                                     syntax=syntax)
                                            if showresults: log(
                                                'Add Address {} to Source in Rule {}: {}'.format(faddr['newaddress'],
                                                                                                 str(faddr[
                                                                                                         'policy_num']),
                                                                                                 result))
                                            # modify_rule_obj(target, session, apikey, fw_type, syntax, params)
                            if oldaddr in change[context]['dests']:
                                for faddr in change[context]['dests'][oldaddr]:
                                    faddr_copy = copy.deepcopy(faddr)
                                    faddr_copy.pop('searchaddress', None)
                                    if newaddr == faddr['newaddress']:
                                        if faddr_copy not in dbedit:
                                            dbedit.append(faddr_copy)
                                            result = exec_fw_command(target, change[context]['fw_type'], [(
                                                                                                          'modify_rule',
                                                                                                          {
                                                                                                              'context': context,
                                                                                                              'policyname':
                                                                                                                  faddr[
                                                                                                                      'policy_name'],
                                                                                                              'policynum': str(
                                                                                                                  faddr[
                                                                                                                      'policy_num']),
                                                                                                              'action': 'addmembers',
                                                                                                              'dests': [
                                                                                                                  faddr[
                                                                                                                      'newaddress']]})],
                                                                     syntax=syntax)
                                            if showresults: log('Add Address {} to Destination in Rule {}: {}'.format(
                                                faddr['newaddress'], str(faddr['policy_num']), result))

                        if oldaddr in change[context]['nat']:
                            for faddr in change[context]['nat'][oldaddr]:
                                faddr_copy = copy.deepcopy(faddr)
                                faddr_copy.pop('oldaddress', None)
                                if newaddr == faddr['newaddress']:
                                    if faddr_copy not in dbedit:
                                        dbedit.append(faddr_copy)
                                        if faddr['type'] == 'natPolicyOrigSrc':
                                            if change[context]['fw_type'] == 'checkpoint':
                                                ## for this just remove the old element and add the new one
                                                log("#rmelement fw_policies {} rule_adtr:{}:src_adtr network_objects:{}".format(
                                                    faddr['policy_name'], str(faddr['policy_num']), oldaddr))
                                                log("#addelement fw_policies {} rule_adtr:{}:src_adtr network_objects:{}".format(
                                                    faddr['policy_name'], str(faddr['policy_num']),
                                                    faddr['newaddress']))
                                                # log("modify fw_policies " + faddr['policy_name'] + " rule_adtr:" + str(faddr['policy_num']) + ":src_adtr:'' network_objects:" + faddr['newaddress'])
                                            elif change[context]['fw_type'] == 'sonicwall':
                                                log('change nat policy placeholder')
                                            elif change[context]['fw_type'] == 'panorama':
                                                log('change nat policy placeholder')
                                        if faddr['type'] == 'natPolicyOrigDst':
                                            if change[context]['fw_type'] == 'checkpoint':
                                                ## for this just remove the old element and add the new one
                                                log("#rmelement fw_policies {} rule_adtr:{}:dst_adtr network_objects:{}".format(
                                                    faddr['policy_name'], str(faddr['policy_num']), oldaddr))
                                                log("#addelement fw_policies {} rule_adtr:{}:dst_adtr network_objects:{}".format(
                                                    faddr['policy_name'], str(faddr['policy_num']),
                                                    faddr['newaddress']))
                                                # log("modify fw_policies " + faddr['policy_name'] + " rule_adtr:" + str(faddr['policy_num']) + ":dst_adtr:'' network_objects:" + faddr['newaddress'])
                                            elif change[context]['fw_type'] == 'sonicwall':
                                                log('change nat policy placeholder')
                                            elif change[context]['fw_type'] == 'panorama':
                                                log('change nat policy placeholder')
                                        if faddr['type'] == 'natPolicyNewSrc':
                                            if change[context]['fw_type'] == 'checkpoint':
                                                ## for this, a temp object needs to be created..
                                                ## https://www.mail-archive.com/fw-1-mailinglist@amadeus.us.checkpoint.com/msg22701.html
                                                '''
                                                I also need to get the address translation type...
                                                create $type tmp_name
                                                modify owned tmp_name '' $valuenetwork:objects:faddr['newaddress']
                                                add_owned_remove_name fw_policies faddr['policy_name']  rule_adtr:str(faddr['policy_num']):dst|src_adtr_translated owned:tmp_name
                                                delete owned tmp_name

                                                Where $type is obviously the type of the owned object, these are one of:
                                                        service_translate
                                                        translate_hide
                                                        translate_static

                                                So you essentially chose the translation method by the "type" of the owned
                                                object (for src or dst. service is always service_translate).

                                                $field - Well, in my code $field is always \'\' (ie. two quoted
                                                apostrophies, though you may well not need to quote them (so just '').

                                                $value is the actual either a service (service:foo) which is of course only
                                                valid if the type is service_translate, a network object
                                                (network_objects:foo) for the other two or a global, like global:Any, which
                                                works in all of them.

                                                $prefix is what you're adding it to, and would be *one* of:
                                                        fw_policies ##New rule_adtr:0:service_adtr_translated
                                                        fw_policies ##New rule_adtr:0:dst_adtr_translated
                                                        fw_policies ##New rule_adtr:0:src_adtr_translated
                                                '''
                                                log("modify fw_policies " + faddr['policy_name'] + " rule_adtr:" + str(
                                                    faddr['policy_num']) + ":src_adtr_translated:'' network_objects:" +
                                                    faddr['newaddress'])
                                            elif change[context]['fw_type'] == 'sonicwall':
                                                log('change nat policy placeholder')
                                            elif change[context]['fw_type'] == 'panorama':
                                                log('change nat policy placeholder')
                                        if faddr['type'] == 'natPolicyNewDst':
                                            if change[context]['fw_type'] == 'checkpoint':
                                                log("modify fw_policies " + faddr['policy_name'] + " rule_adtr:" + str(
                                                    faddr['policy_num']) + ":dst_adtr_translated:'' network_objects:" +
                                                    faddr['newaddress'])
                                            elif change[context]['fw_type'] == 'sonicwall':
                                                log('change nat policy placeholder')
                                            elif change[context]['fw_type'] == 'panorama':
                                                log('change nat policy placeholder')
    return


def remove_dupes(duplicates, context):  ## pass in context name

    replacements = 0
    exist_count = 0

    log("!-- Renaming Duplicate Objects in Policies")

    for index in config[context]['policies']:
        for dupe in duplicates['addresses']:
            if dupe in config[context]['policies'][index]['policySrcNet']:
                replacements += 1
                config[context]['policies'][index]['policySrcNet'].remove(dupe)
                config[context]['policies'][index]['policySrcNet'].append(duplicates['addresses'][dupe])
            if dupe in config[context]['policies'][index]['policyDstNet']:
                replacements += 1
                config[context]['policies'][index]['policyDstNet'].remove(dupe)
                config[context]['policies'][index]['policyDstNet'].append(duplicates['addresses'][dupe])
        for dupe in duplicates['services']:

            if dupe in config[context]['policies'][index]['policyDstSvc']:
                replacements += 1
                config[context]['policies'][index]['policyDstSvc'].remove(dupe)
                config[context]['policies'][index]['policyDstSvc'].append(duplicates['services'][dupe])

    log("!-- Renaming Duplicate Objects in Address Mappings")

    for map in config[context]['addressmappings']:
        for dupe in duplicates['addresses']:
            if dupe in config[context]['addressmappings'][map]:
                replacements += 1
                log('ADDRMAP: Replacing {:30.30s} with {:30.30s}'.format(dupe, duplicates['addresses'][dupe],
                                                                         level=logging.INFO))
                config[context]['addressmappings'][map].remove(dupe)
                config[context]['addressmappings'][map].append(duplicates['addresses'][dupe])

    log("!-- Renaming Duplicate Objects in Service Mappings")

    for map in config[context]['servicemappings']:
        for dupe in duplicates['services']:
            if dupe in config[context]['servicemappings'][map]:
                replacements += 1
                log('SVCMAP: Replacing {:30.30s} with {:30.30s} in {:30.30s}'.format(dupe, duplicates['services'][dupe],
                                                                                     map), level=logging.INFO)
                config[context]['servicemappings'][map].remove(dupe)
                config[context]['servicemappings'][map].append(duplicates['services'][dupe])

    log("!-- Renaming Duplicate Objects in Routing Objects")

    ## Routing policy Src/Dst is not currently a list, do I need to change this? CHANGEME
    for index in config[context]['routing']:
        for dupe in duplicates['addresses']:
            if dupe in config[context]['routing'][index]['pbrObjSrc']:
                replacements += 1
                config[context]['routing'][index]['pbrObjSrc'].remove(dupe)
                config[context]['routing'][index]['pbrObjSrc'].append(duplicates['addresses'][dupe])
            if dupe in config[context]['routing'][index]['pbrObjDst']:
                replacements += 1
                config[context]['routing'][index]['pbrObjDst'].remove(dupe)
                config[context]['routing'][index]['pbrObjDst'].append(duplicates['addresses'][dupe])
            if dupe in config[context]['routing'][index]['pbrObjGw']:
                replacements += 1
                config[context]['routing'][index]['pbrObjGw'].remove(dupe)
                config[context]['routing'][index]['pbrObjGw'].append(duplicates['addresses'][dupe])

    # Remove duplicates from address and service objects and mappings

    log("!-- Removing Duplicate Address and Service Objects")

    tmpaddr = OrderedDict()
    tmpaddrmap = OrderedDict()

    for index in config[context]['addresses']:
        dupefound = False
        for dupe in duplicates['addresses']:
            if dupe == index:
                dupefound = True;
                break;
        if not dupefound:
            tmpaddr[index] = config[context]['addresses'][index]
    config[context]['addresses'] = tmpaddr

    for index in config[context]['addressmappings']:
        dupefound = False
        for dupe in duplicates['addresses']:
            if dupe == index:
                dupefound = True;
                break;
        if not dupefound:
            tmpaddrmap[index] = config[context]['addressmappings'][index]
    config[context]['addressmappings'] = tmpaddrmap

    tmpsvc = OrderedDict()
    tmpsvcmap = OrderedDict()

    for index in config[context]['services']:
        dupefound = False
        for dupe in duplicates['services']:
            if dupe == index:
                dupefound = True;
                break;
        if not dupefound:
            tmpsvc[index] = config[context]['services'][index]
    config[context]['services'] = tmpsvc

    for index in config[context]['servicemappings']:
        dupefound = False
        for dupe in duplicates['services']:
            if dupe == index:
                dupefound = True;
                break;
        if not dupefound:
            tmpsvcmap[index] = config[context]['servicemappings'][index]
    config[context]['servicmappings'] = tmpsvcmap

    return replacements;


def inverse_rule_cleanup(inverse_results, matching='complete'):
    from urllib.parse import quote as url_quote, unquote as url_unquote
    import re

    panohostip = '%PANOIP%'
    userkey = '%APIKEY%'
    inverse_stats = OrderedDict()

    inverse_cmds = ([])
    inverse_newcmds = ([])
    if options.inversedisable:
        if options.web: set_web_tab('disable')
        log('!-- Disabling Inverse Policy Matches')
    if options.inversedelete:
        if options.web: set_web_tab('delete')
        log('!-- Deleting Inverse Policy Matches')

    for context in contexts:
        log('-' * 150)
        inverse_stats[context] = [0, 0, 0, 0]  # disabled, deleted, skipped-notall, skipped-notdisablde
        log('Context  : ' + context)
        log('Firewall : ' + config[context]['config']['name'])
        log('Mgmt IP  : ' + str(config[context]['config']['mgmtip']))
        num = 0
        for match in inverse_results[context]['policies']:
            if match['action'].lower() != 'allow': inverse_stats[context][2] += 1
            if match['enabled'] == False: inverse_stats[context][3] += 1
            if (match['action'].lower() == 'allow' or options.inverseallrules) and (options.inversedisable or match[
                'enabled'] == False):  # perform checking only for "allow" rules, for all objects in disable mode, enabled rules only in delete mode
                if match['source_match'] == 'complete' or match['dest_match'] == 'complete' or options.inversepartial:
                    log('-' * 150)
                    log('Context      : ' + context)
                    if match['fw_type'] == 'checkpoint':
                        log('Policy Name  : ' + match['name'])
                    else:
                        log('Rule Name    : ' + match['name'])
                    log('Rule Comment : ' + match['comment'])
                    log('Rule Enabled : ' + str(match['enabled']))
                    log('{:15.15s} {:60.60s} {:60.60s}'.format('', 'Source', 'Destination'))
                    log('{:15.15s} {:60.60s} {:60.60s}'.format('Match Type', match['source_match'],
                                                               match['dest_match']))
                    log('{:15.15s} {:60.60s} {:60.60s}'.format('Zone', match['source_zone'], match['dest_zone']))
                    if match['fw_type'] == 'sonicwall': log(
                        '{:15.15s} {:60.60s} {:60.60s}'.format('Address Type', match['source_type'],
                                                               match['dest_type']))
                    if len(match['source_list']) > len(match['dest_list']):
                        num_obj = len(match['source_list'])
                    else:
                        num_obj = len(match['dest_list'])
                    for idx in range(num_obj):
                        src = ''
                        dst = ''
                        if idx < len(match['source_list']): src = match['source_list'][idx]
                        if idx < len(match['dest_list']): dst = match['dest_list'][idx]
                        if idx == 0:
                            log('{:15.15s} {:60.60s} {:60.60s}'.format('Address', src, dst))
                        else:
                            log('{:15.15s} {:60.60s} {:60.60s}'.format('', src, dst))
                    log('{:15.15s} {:60.60s}'.format('Service', url_unquote(match['dest_service']), ''))

                    if match['source_type'].lower() == 'any':
                        src_str = 'any'
                    elif match['source_type'].lower() in ['range', 'network',
                                                          'host']:  # despite "range" and "network" being keywords in the CLI, these objects seem to use the "name" keyword instead (in 6.1.1.7 anyhow)
                        src_str = 'name "' + ss(match['source_addr']) + '"'
                    else:
                        src_str = match['source_type'] + ' "' + url_unquote(match['source_addr']) + '"'

                    if match['dest_type'].lower() == 'any':
                        dst_str = 'any'
                    elif match['dest_type'].lower() in ['range', 'network',
                                                        'host']:  # despite "range" and "network" being keywords in the CLI, these objects seem to use the "name" keyword instead (in 6.1.1.7 anyhow)
                        dst_str = 'name "' + ss(match['dest_addr']) + '"'
                    else:
                        dst_str = match['dest_type'] + ' "' + url_unquote(match['dest_addr']) + '"'

                    if match['service_type'].lower() == 'any':
                        svc_str = 'any'
                    else:
                        svc_str = match['service_type'] + ' "' + url_unquote(match['dest_service']) + '"'

                    if match['source_match'] != 'none':
                        for addr in match['source_list']:
                            log('-' * 150)
                            log('Source Address Object : ' + addr)
                            log('-' * 150)
                            for context, parent, name, address in search_address([addr], [context]):
                                log('{:60.60s} {:60.60s}'.format(name, address))
                    if match['dest_match'] != 'none':
                        log('-' * 150)
                        log('Destination Address Object : ' + match['dest_addr'])
                        log('-' * 150)
                        for context, parent, name, address in search_address([match['dest_addr']], [context]):
                            log('{:60.60s} {:60.60s}'.format(name, address))
                    log('-' * 150)

                    if match['fw_type'].lower() == 'sonicwall':  ## changeme - use config/context/config/fw_type
                        if len(match['source_addr']) > 38 or len(match[
                                                                     'dest_addr']) > 38:  # sonicwall has an issue with address name params >38 chars long on CLI
                            log('**', end='')
                        if options.inversedisable:
                            inverse_newcmds.append(
                                {'num': num, 'fw_type': 'sonicwall', 'fw_ip': config[context]['config']['mgmtip'],
                                 'fw_version': match['fw_version'], 'rule-action': 'disable', 'matchtype': 'rule',
                                 'srczone': match['source_zone'], 'dstzone': match['dest_zone'],
                                 'action': match['action'], 'source': src_str, 'dest': dst_str, 'service': svc_str,
                                 'device_group': context, 'rule_num': match['rule_num'], 'ui_num': match['ui_num'],
                                 'policy_name': match['name']})
                            num += 1
                            inverse_stats[context][0] += 1
                        else:
                            inverse_newcmds.append(
                                {'num': num, 'fw_type': 'sonicwall', 'fw_ip': config[context]['config']['mgmtip'],
                                 'fw_version': match['fw_version'], 'rule-action': 'delete', 'matchtype': 'rule',
                                 'srczone': match['source_zone'], 'dstzone': match['dest_zone'],
                                 'action': match['action'], 'source': src_str, 'dest': dst_str, 'service': svc_str,
                                 'device_group': context, 'rule_num': match['rule_num'], 'ui_num': match['ui_num'],
                                 'policy_name': match['name']})
                            num += 1
                            inverse_stats[context][1] += 1
                    elif match['fw_type'].lower() == 'checkpoint':
                        if options.inversedisable:
                            inverse_newcmds.append(
                                {'num': num, 'fw_type': 'checkpoint', 'fw_ip': config[context]['config']['mgmtip'],
                                 'fw_version': match['fw_version'], 'rule-action': 'disable', 'matchtype': 'rule',
                                 'srczone': match['source_zone'], 'dstzone': match['dest_zone'],
                                 'action': match['action'], 'source': src_str, 'dest': dst_str, 'service': svc_str,
                                 'device_group': context, 'rule_num': match['rule_num'], 'ui_num': match['ui_num'],
                                 'policy_name': match['name']})
                            num += 1
                            inverse_stats[context][0] += 1
                        else:
                            inverse_newcmds.append(
                                {'num': num, 'fw_type': 'checkpoint', 'fw_ip': config[context]['config']['mgmtip'],
                                 'fw_version': match['fw_version'], 'rule-action': 'delete', 'matchtype': 'rule',
                                 'srczone': match['source_zone'], 'dstzone': match['dest_zone'],
                                 'action': match['action'], 'source': src_str, 'dest': dst_str, 'service': svc_str,
                                 'device_group': context, 'rule_num': match['rule_num'], 'ui_num': match['ui_num'],
                                 'policy_name': match['name']})
                            num += 1
                            inverse_stats[context][1] += 1
                    elif match['fw_type'].lower() == 'panorama':  ## assume firewall type is panorama
                        if options.inversedisable:
                            inverse_stats[context][0] += 1
                            num += 1
                            inverse_newcmds.append(
                                {'num': num, 'fw_type': 'panorama', 'fw_ip': config[context]['config']['mgmtip'],
                                 'fw_version': match['fw_version'], 'rule-action': 'disable', 'matchtype': 'rule',
                                 'srczone': match['source_zone'], 'dstzone': match['dest_zone'],
                                 'action': match['action'], 'source': url_unquote(match['source_addr']),
                                 'dest': url_unquote(match['dest_addr']), 'service': url_unquote(match['dest_service']),
                                 'device_group': context, 'rule_name': match['name'], 'rule_num': match['rule_num']})
                        else:
                            inverse_stats[context][1] += 1
                            num += 1
                            inverse_newcmds.append(
                                {'num': num, 'fw_type': 'panorama', 'fw_ip': config[context]['config']['mgmtip'],
                                 'fw_version': match['fw_version'], 'rule-action': 'delete', 'matchtype': 'rule',
                                 'srczone': match['source_zone'], 'dstzone': match['dest_zone'],
                                 'action': match['action'], 'source': url_unquote(match['source_addr']),
                                 'dest': url_unquote(match['dest_addr']), 'service': url_unquote(match['dest_service']),
                                 'device_group': context, 'rule_name': match['name'], 'rule_num': match['rule_num']})
                    elif match['fw_type'].lower() == 'paloalto':
                        if options.inversedisable:
                            inverse_stats[context][0] += 1
                            num += 1
                            inverse_newcmds.append(
                                {'num': num, 'fw_type': 'paloalto', 'fw_ip': config[context]['config']['mgmtip'],
                                 'fw_version': match['fw_version'], 'rule-action': 'disable', 'matchtype': 'rule',
                                 'srczone': match['source_zone'], 'dstzone': match['dest_zone'],
                                 'action': match['action'], 'source': url_unquote(match['source_addr']),
                                 'dest': url_unquote(match['dest_addr']), 'service': url_unquote(match['dest_serv  ice']),
                                 'device_group': context, 'rule_name': match['name'], 'rule_num': match['rule_num']})
                        else:
                            inverse_stats[context][1] += 1
                            num += 1
                            inverse_newcmds.append(
                                {'num': num, 'fw_type': 'paloalto', 'fw_ip': config[context]['config']['mgmtip'],
                                 'fw_version': match['fw_version'], 'rule-action': 'delete', 'matchtype': 'rule',
                                 'srczone': match['source_zone'], 'dstzone': match['dest_zone'],
                                 'action': match['action'], 'source': url_unquote(match['source_addr']),
                                 'dest': url_unquote(match['dest_addr']), 'service': url_unquote(match['dest_service']),
                                 'device_group': context, 'rule_name': match['name'], 'rule_num': match['rule_num']})
                    elif context.lower() == 'shared':  # SHOULD NO LONGER BE NEEDED - REMOVE
                        pass
                        log(re.sub(r'&key=.*', '%APIKEY%', request), level=logging.INFO)
                        if options.inversedisable:
                            pass
                        else:
                            pass
                    log('\r\n')
    return inverse_newcmds, inverse_stats


def inverse_address_cleanup(inverse_results, matching='complete', skipshared=True):
    from urllib.parse import quote as url_quote, unquote as url_unquote
    import re

    if options.web: set_web_tab('address')
    panohostip = '%PANOIP%'
    userkey = '%APIKEY%'
    inverse_stats = OrderedDict()

    inverse_cmds = ([])
    inverse_newcmds = ([])
    inverse_revcmds = ([])
    log('!-- Deleting Inverse Address Matches')
    num = 0
    for context in contexts:

        inverse_stats[context] = OrderedDict(
            [('addresses', 0), ('policies', 0), ('groups', 0)])  # address,policy,groups
        log('=' * 180)
        log('Context  : ' + context)
        log('Firewall : ' + config[context]['config']['name'])
        log('Mgmt IP  : ' + str(config[context]['config']['mgmtip']))
        for match in inverse_results[context]['addresses']:
            inverse_stats[context]['addresses'] += 1
            if (match['match'].lower() == 'complete' or options.inversepartial) and match['mapping'] == 'root' and (
                    context.lower() != 'shared' or skipshared == False):  # match is complete, a host object, and at the root level (not an entry with group membership listed)

                log('=' * 180)
                if match['fw_type'].lower() != 'checkpoint':
                    log('Context      : ' + context)
                log('Address      : ' + match['address'])
                log('Address Type : ' + match['type'])
                if match['type'] == 'host':
                    addr_str = config[context]['addresses'][match['address']]['addrObjIp1'] + '/32'
                elif match['type'] == 'network':
                    addr_str = config[context]['addresses'][match['address']]['addrObjIp1'] + '/' + str(
                        netmask_to_cidr(config[context]['addresses'][match['address']]['addrObjIp2']))
                elif match['type'] == 'range:':
                    addr_str = config[context]['addresses'][match['address']]['addrObjIp1'] + '-' + \
                               config[context]['addresses'][match['address']]['addrObjIp2']
                else:
                    addr_str = 'Details Below'
                log('Address Def  : ' + addr_str)
                log('Match Type   : ' + match['match'])
                log('Parent       : ' + match['mapping'])

                if context.lower() == 'sonicwall':
                    log('sonicwall', match['address'])
                else:
                    if context.lower() != 'shared':
                        if match['address'] in config[context]['addresses']:
                            shared = False
                        else:
                            shared = True
                    else:  # context is shared
                        shared = False
                    log('-' * 180)
                    log('Group Membership')
                    log('-' * 180)
                    found = False
                    for address in config[context]['addressmappings']:
                        if match['address'] in config[context]['addressmappings'][address]:
                            found = True
                            log(str(address))
                            if match['fw_type'].lower() == 'sonicwall':
                                inverse_newcmds.append(
                                    {'fw_type': 'sonicwall', 'fw_ip': config[context]['config']['mgmtip'],
                                     'device_group': context, 'match_type': 'address', 'cleanup_type': 'group',
                                     'group': str(address), 'member': match['address']})
                            else:
                                inverse_newcmds.append(
                                    {'fw_type': match['fw_type'], 'fw_ip': config[context]['config']['mgmtip'],
                                     'device_group': context, 'match_type': 'address', 'cleanup_type': 'group',
                                     'group': str(address), 'member': match['address']})

                            num += 1
                            inverse_stats[context]['groups'] += 1
                    if not found:
                        log('None')

                    if match['type'].lower() == 'group':
                        log('-' * 180)
                        log('Group Members')
                        log('-' * 180)
                        for member in expand_address(config[context]['addresses'], match['address'],
                                                     config[context]['addressmappings']):
                            tmpaddr = None
                            if member in config[context]['addresses']:
                                tmpaddr = config[context]['addresses'][member]
                            elif member in config['shared']['addresses']:
                                tmpaddr = config['shared']['addresses'][member]
                            if tmpaddr['addrObjType'] == '1':
                                addr_str = tmpaddr['addrObjIp1'] + '/32'
                            elif tmpaddr['addrObjType'] == '4':
                                addr_str = tmpaddr['addrObjIp1'] + '/' + str(netmask_to_cidr(tmpaddr['addrObjIp2']))
                            elif tmpaddr['addrObjType'] == '2:':
                                addr_str = tmpaddr['addrObjIp1'] + '-' + tmpaddr['addrObjIp2']
                            else:
                                addr_str = 'Group Object'
                            log('  {:30.30s} {:30.30s}'.format(member, addr_str))

                    ## check to see if address is used in any policies -- Ideally the policies using the object would already be disabled & deleted

                    ## check if shared address is  in the match list for each context - if so it has already been removed from the context rules and can be skipped
                    log('-' * 180)
                    log('Rule Membership')
                    log('-' * 180)
                    if context == 'shared':
                        polcontexts = contexts
                    else:
                        polcontexts = [context]
                    found = False
                    for polcontext in polcontexts:
                        for policy in config[polcontext]['policies']:
                            if match['address'] in config[polcontext]['policies'][policy]['policySrcNet']:
                                found = True
                                inverse_stats[context]['policies'] += 1
                                if match['fw_type'].lower() == 'sonicwall':
                                    log('Source       :  {:20.20s} {:20.20s} {:40.40s} {:40.40s} {:40.40s}'.format(
                                        config[polcontext]['policies'][policy]['policySrcZone'][0],
                                        config[polcontext]['policies'][policy]['policyDstZone'][0],
                                        config[polcontext]['policies'][policy]['policySrcNet'][0],
                                        config[polcontext]['policies'][policy]['policyDstNet'][0],
                                        config[polcontext]['policies'][policy]['policyDstSvc'][0]))
                                    inverse_newcmds.append(
                                        {'fw_type': 'sonicwall', 'fw_ip': config[context]['config']['mgmtip'],
                                         'device_group': polcontext, 'match_type': 'address',
                                         'cleanup_type': 'policy-source',
                                         'policy_name': config[polcontext]['policies'][policy]['policyName'],
                                         'member': match['address']})
                                elif match['fw_type'].lower() == 'checkpoint':
                                    log('Source       : ' + config[polcontext]['policies'][policy][
                                        'policyName'] + ':rule:' + str(
                                        config[polcontext]['policies'][policy]['policyNum']) + '  (UI#: ' + str(
                                        config[polcontext]['policies'][policy]['policyUiNum']) + ')')
                                    inverse_newcmds.append(
                                        {'fw_type': match['fw_type'], 'fw_ip': config[context]['config']['mgmtip'],
                                         'device_group': polcontext, 'match_type': 'address',
                                         'cleanup_type': 'policy-source',
                                         'policy_name': config[polcontext]['policies'][policy]['policyName'],
                                         'member': match['address'],
                                         'rule_num': config[polcontext]['policies'][policy]['policyNum']})
                                else:
                                    log('Source       : ' + config[polcontext]['policies'][policy]['policyName'])
                                    inverse_newcmds.append(
                                        {'fw_type': match['fw_type'], 'fw_ip': config[context]['config']['mgmtip'],
                                         'device_group': polcontext, 'match_type': 'address',
                                         'cleanup_type': 'policy-source',
                                         'policy_name': config[polcontext]['policies'][policy]['policyName'],
                                         'member': match['address'],
                                         'rule_num': config[polcontext]['policies'][policy]['policyNum']})
                                num += 1

                            if match['address'] in config[polcontext]['policies'][policy]['policyDstNet']:
                                found = True
                                inverse_stats[context]['policies'] += 1
                                if match['fw_type'].lower() == 'sonicwall':
                                    log('Destination  :  {:20.20s} {:20.20s} {:40.40s} {:40.40s} {:40.40s}'.format(
                                        config[polcontext]['policies'][policy]['policySrcZone'][0],
                                        config[polcontext]['policies'][policy]['policyDstZone'][0],
                                        config[polcontext]['policies'][policy]['policySrcNet'][0],
                                        config[polcontext]['policies'][policy]['policyDstNet'][0],
                                        config[polcontext]['policies'][policy]['policyDstSvc'][0]))
                                    inverse_newcmds.append(
                                        {'fw_type': 'sonicwall', 'fw_ip': config[context]['config']['mgmtip'],
                                         'device_group': polcontext, 'match_type': 'address',
                                         'cleanup_type': 'policy-dest',
                                         'policy_name': config[polcontext]['policies'][policy]['policyName'],
                                         'member': match['address']})
                                elif match['fw_type'].lower() == 'checkpoint':
                                    log('Destination  : ' + config[polcontext]['policies'][policy][
                                        'policyName'] + ':rule:' + str(
                                        config[polcontext]['policies'][policy]['policyNum']) + '  (UI#: ' + str(
                                        config[polcontext]['policies'][policy]['policyUiNum']) + ')')
                                    inverse_newcmds.append(
                                        {'fw_type': match['fw_type'], 'fw_ip': config[context]['config']['mgmtip'],
                                         'device_group': polcontext, 'match_type': 'address',
                                         'cleanup_type': 'policy-dest',
                                         'policy_name': config[polcontext]['policies'][policy]['policyName'],
                                         'member': match['address'],
                                         'rule_num': config[polcontext]['policies'][policy]['policyNum']})
                                else:
                                    log('Destination  : ' + config[polcontext]['policies'][policy]['policyName'])
                                    inverse_newcmds.append(
                                        {'fw_type': match['fw_type'], 'fw_ip': config[context]['config']['mgmtip'],
                                         'device_group': polcontext, 'match_type': 'address',
                                         'cleanup_type': 'policy-dest',
                                         'policy_name': config[polcontext]['policies'][policy]['policyName'],
                                         'member': match['address'],
                                         'rule_num': config[polcontext]['policies'][policy]['policyNum']})
                                num += 1

                    ## check to see if address is used in any shared policies (not likely, as we currently do not have any shared pre-rules)

                    if not found:
                        log('NONE')

                    ## remove address from context
                    if not shared:  # only remove if address is not a shared object in a context other than shared
                        if match['type'] == 'group':
                            if match['fw_type'].lower() == 'sonicwall':
                                inverse_newcmds.append(
                                    {'fw_type': 'sonicwall', 'fw_ip': config[context]['config']['mgmtip'],
                                     'device_group': context, 'match_type': 'address', 'cleanup_type': 'address-group',
                                     'address': match['address']})
                            else:
                                inverse_newcmds.append(
                                    {'fw_type': match['fw_type'], 'fw_ip': config[context]['config']['mgmtip'],
                                     'device_group': context, 'match_type': 'address', 'cleanup_type': 'address-group',
                                     'address': match['address']})
                        else:
                            if match['fw_type'].lower() == 'sonicwall':
                                inverse_newcmds.append(
                                    {'fw_type': 'sonicwall', 'fw_ip': config[context]['config']['mgmtip'],
                                     'device_group': context, 'match_type': 'address', 'cleanup_type': 'address',
                                     'address': match['address']})
                            else:
                                inverse_newcmds.append(
                                    {'fw_type': match['fw_type'], 'fw_ip': config[context]['config']['mgmtip'],
                                     'device_group': context, 'match_type': 'address', 'cleanup_type': 'address',
                                     'address': match['address']})
                        num += 1
                log('\r\n')

    return inverse_newcmds, inverse_stats


def inverse_showcommands(commands):
    if 'rules' in commands:
        for i in commands['rules']:
            log(i)
    if 'addresses' in commands:
        for i in commands['addresses']:
            log(i)

    return


def set_web_tab(tabname, status_msg='', fileext='.txt',
                alttext=''):  # alttext is for future support to insert html code after closing textarea

    # global prevtab
    if tabname != '':
        prevtab = tabs2[tabname]['prevtab']
    else:
        prevtab = list(tabs2.keys())[-1]

    if prevtab != None:
        if tabs2[prevtab]['tabtype'] == 'textarea':
            log('</textarea>')
    if prevtab != None and fileext != '':
        if tabs2[prevtab]['download'] == True:
            log('''Download textarea: <br />
<input value='download' type='button' onclick='doDL_''' + prevtab + '''(document.getElementById("''' + prevtab + '''_text").value)' />''')

    log('</div>')
    if status_msg != '':
        log('''<style>
    .alert {
    padding: 20px;
    background-color: #f44336;
    color: white;
    opacity: 1;
    transition: opacity 0.6s;
    margin-bottom: 15px;
}

.alert.success {background-color: #4CAF50;}
.alert.info {background-color: #2196F3;}
.alert.warning {background-color: #ff9800;}

.closebtn {
    margin-left: 15px;
    color: white;
    font-weight: bold;
    float: right;
    font-size: 22px;
    line-height: 20px;
    cursor: pointer;
    transition: 0.3s;
}

.closebtn:hover {
    color: black;
</style>

<div class="alert info">
  <span class="closebtn">&times;</span>  
  Performing next step -- output displayed on tab: ''' + status_msg +
            '''</div>
<script>
var close = document.getElementsByClassName("closebtn");
var i;

for (i = 0; i < close.length; i++) {
    close[i].onclick = function(){
        var div = this.parentElement;
        div.style.opacity = "0";
        setTimeout(function(){ div.style.display = "none"; }, 600);
    }
}
</script>''')
    log('''<div id="''' + tabname + '''" class="tabcontent">''')
    if tabname != '':
        log('''<script>
          document.getElementById("''' + tabname + '''_tab").click();
      </script>
      <script type='text/javascript'>

function doDL_''' + tabname + '''(data) {
var uri = 'data:x-application/text,' + escape(data);

var downloadLink = document.createElement("a");
downloadLink.href = uri;
downloadLink.download = "''' + tabname + fileext + '''";

document.body.appendChild(downloadLink);
downloadLink.click();
document.body.removeChild(downloadLink);
}

</script>''')

        if tabname != '':
            if tabs2[tabname]['tabtype'] == 'textarea':
                log('''<textarea id="''' + tabname + '''_text" ''' + tabs2[tabname][
                    'textarea'] + ''' cols=\"200\" rows=\"20\">''')

    return


def inverse_newexec(username, password, targetip, commands, noexec=False, skipshared=True, method='cli'):
    import requests
    from urllib.parse import quote
    import re

    userkey = ''
    ## build list of address-group-with-exception objects
    group_with_exceptions = {}
    for context in contexts:
        group_with_exceptions[context] = []
        for addr in config[context]['addresses']:
            if config[context]['addresses'][addr]['addrObjType'] == '98':
                group_with_exceptions[context].append(addr)
        # if context in group_with_exceptions:
        # log('EXCEPTIONS', group_with_exceptions[context])
    if 'rules' in commands:
        for cmd in commands['rules']:

            if cmd['rule-action'] == 'delete':
                exec_fw_command(cmd['fw_ip'], cmd['fw_type'], [('modify_rule',
                                                                {'context': context,
                                                                 'policyname': cmd['policy_name'],
                                                                 'policynum': str(cmd['rule_num']),
                                                                 'action': 'delete',
                                                                 'sources': cmd['source'],
                                                                 'dests': cmd['dest'],
                                                                 'service': cmd['service'],
                                                                 'polaction': cmd['action'],
                                                                 'srczone': cmd['srczone'],
                                                                 'dstzone': cmd['dstzone']})], syntax='cli')
            if cmd['rule-action'] == 'disable':
                if 'commment' not in cmd:
                    cmd['comment'] = ''
                exec_fw_command(cmd['fw_ip'], cmd['fw_type'],
                                [('modify_rule',
                                  {'context': context,
                                   'policyname': cmd['policy_name'],
                                   'policynum': str(cmd['rule_num']),
                                   'action': 'disable',
                                   'sources': cmd['source'],
                                   'dests': cmd['dest'],
                                   'service': cmd['service'],
                                   'polaction': cmd['action'],
                                   'srczone': cmd['srczone'],
                                   'dstzone': cmd['dstzone']}),
                                 ('modify_rule',
                                  {'context': context,
                                   'policyname': cmd['policy_name'],
                                   'policynum': str(cmd['rule_num']),
                                   'action': 'comment',
                                   'sources': cmd['source'],
                                   'dests': cmd['dest'],
                                   'service': cmd['service'],
                                   'polaction': cmd['action'],
                                   'srczone': cmd['srczone'],
                                   'dstzone': cmd['dstzone'],
                                   'comment': cmd['comment'] + options.inversecomment})
                                 ], syntax='cli')

                # ('modify_rule', { 'context': context, 'policyname': cmd['policy_name'], 'action': 'comment', 'comment': cmd['comment'] + options.inversecomment })

    if 'addresses' in commands:
        for cmd in commands['addresses']:
            if cmd['cleanup_type'] == 'group':
                ## modify members
                exec_fw_command(cmd['fw_ip'], cmd['fw_type'], [('modify_address', {'context': cmd['device_group'],
                                                                                   'action': 'delmembers',
                                                                                   'addressname': cmd['group'],
                                                                                   'members': [cmd['member']]
                                                                                   })], syntax='cli')
            elif cmd['cleanup_type'] == 'policy-source':
                if cmd['fw_type'] != 'sonicwall':
                    exec_fw_command(cmd['fw_ip'], cmd['fw_type'], [('modify_rule',
                                                                    {
                                                                        'context': cmd['device_group'],
                                                                        'policyname': cmd['policy_name'],
                                                                        'policynum': str(cmd['rule_num']),
                                                                        'action': 'delmembers',
                                                                        'sources': [cmd['member']]
                                                                    }
                                                                    )], syntax='cli')
            elif cmd['cleanup_type'] == 'policy-dest':
                if cmd['fw_type'] != 'sonicwall':
                    exec_fw_command(cmd['fw_ip'], cmd['fw_type'], [('modify_rule', {'context': cmd['device_group'],
                                                                                    'policyname': cmd['policy_name'],
                                                                                    'policynum': str(cmd['rule_num']),
                                                                                    'action': 'delmembers',
                                                                                    'dests': [cmd['member']] \
                                                                                    })], syntax='cli')
            elif cmd['cleanup_type'] == 'address':
                exception_found = False
                for gwe in group_with_exceptions[cmd['device_group']]:
                    if cmd['address'] in config[cmd['device_group']]['addresses'][gwe]['include'] or cmd['address'] in \
                            config[cmd['device_group']]['addresses'][gwe]['exclude']:
                        exception_found = True
                        print(
                            'EXCEPTION: Address {} marked for deletion found used in adress group with exception - skipping'.format(
                                cmd['address']))
                        break
                if not exception_found:
                    exec_fw_command(cmd['fw_ip'], cmd['fw_type'], [('modify_address', {'context': cmd['device_group'],
                                                                                       'action': 'delete',
                                                                                       'addressname': cmd['address'],
                                                                                       'addresstype': '1',
                                                                                       })], syntax='cli')
            elif cmd['cleanup_type'] == 'address-group':
                exception_found = False
                for gwe in group_with_exceptions[cmd['device_group']]:
                    if cmd['address'] in config[cmd['device_group']]['addresses'][gwe]['include'] or cmd['address'] in \
                            config[cmd['device_group']]['addresses'][gwe]['exclude']:
                        exception_found = True
                        print(
                            'EXCEPTION: Address-Group {} marked for deletion found used in adress group with exception - skipping'.format(
                                cmd['address']))
                        break
                if not exception_found:
                    exec_fw_command(cmd['fw_ip'], cmd['fw_type'], [('modify_address', {'context': cmd['device_group'],
                                                                                       'action': 'delete',
                                                                                       'addressname': cmd['address'],
                                                                                       'addresstype': 'group'
                                                                                       })], syntax='cli')
    return


def process_cmd_args():
    def file_list(listtype='text'):
        class customAction(argparse.Action):
            def __call__(self, parser, args, values, option_string=None):
                import os
                from netaddr import IPSet
                if listtype == 'ipset':
                    returnlist = IPSet([])
                else:
                    returnlist = []
                for value in values:
                    if os.path.basename(value[0]) == '@':
                        for i in file_to_list(value[1:]):
                            if listtype.lower() == 'ipset':
                                returnlist.add(i.rstrip())
                            else:
                                returnlist.append(i.rstrip())
                    else:
                        if listtype.lower() == 'ipset':
                            returnlist.add(value.rstrip())
                        else:
                            returnlist.append(value)

                setattr(args, self.dest, returnlist)

        # print(customAction)
        return customAction

    import argparse

    options = argparse.ArgumentParser(description=' Description', epilog='Epilog')
    options.add_argument('-i', '--i', help='input SonicWall configuration filename', type=str, metavar='filename',
                         dest='sonicwall')
    options.add_argument('-p', '--p', '--sonicwallip', '--ipaddr',
                         help='import config from the IP address of SonicWall device', type=str, metavar='IP Address',
                         dest='sonicwallip')
    options.add_argument('-pp', '--pp', '--sonicwall_api_ip', '--swapi',
                         help='import config via API from the IP address of SonicWall device', type=str,
                         metavar='IP Address', dest='sonicwall_api_ip')
    options.add_argument('--gms', help='import config from the IP address of SonicWall device', type=str,
                         metavar='IP Address', dest='gms')
    options.add_argument('-P', '--P', '--panoramaip', help='import config from the IP address of Panorama server',
                         type=str, metavar='IP Address', dest='panoramaip')
    options.add_argument('-I', help='input Panorama configuration filename', type=str, metavar='filename',
                         dest='panorama')
    options.add_argument('-o', '--outfile', help='output configuration filename', type=str, metavar='filename',
                         dest='outfile')
    options.add_argument('-c', '--devicegroup', nargs='+',
                         help='device-group for search operations (use "any" to search all)',
                         metavar='device-group name(s)', default='', action=file_list(), type=str, dest='context')
    options.add_argument('--policynames', nargs='+',
                         help='policyname for search (--rulematch) operations and tuples (--tuples) generation ',
                         metavar='device-group name(s)', default=[''], action=file_list(), type=str, dest='policynames')
    options.add_argument('-a', nargs='+', help='(Overlapping) address object search (specify IP Address)', type=str,
                         metavar='IPAddr', dest='ipaddr')
    options.add_argument('-A', nargs='+', help='(Exact) address object search (specify IP Address)', type=str,
                         metavar='IPAddr', dest='exactipaddr')
    options.add_argument('-s', nargs='+', help='service object search (specify service protocol and port ie: tcp/23',
                         type=str, metavar='Protocol/Port', dest='service')
    options.add_argument('-S', nargs='+',
                         help='(Exact) service object search (specify service protocol and port ie: tcp/23', type=str,
                         metavar='Protocol/Port', dest='exactservice')
    options.add_argument('-e', nargs='+', help='expand an address object', type=str, metavar='object name',
                         dest='address')
    options.add_argument('-E', nargs='+', help='expand an address object (Verbose)', type=str, metavar='object name',
                         dest='address_verbose')
    options.add_argument('-x', nargs='+', help='expand a service object', type=str, metavar='object name',
                         dest='exp_service')
    options.add_argument('-X', nargs='+', help='expand a service object (Verbose)', type=str, metavar='object name',
                         dest='service_verbose')
    options.add_argument('-z', action='store_false', default=True, help='do not match 0.0.0.0/0 network on IP searches',
                         dest='zero_network')
    options.add_argument('-Z', action='store_false', default=True, help='do not match "any" service on rulematch',
                         dest='zero_service')
    options.add_argument('-N', action='store_true', default=False, help='interactive mode (NOT IMPLEMENTED)',
                         dest='interactive')
    # options.add_argument('-l', default=6, help='set log level', type=int, dest='logging')
    options.add_argument('--cp', action='store_true', default=False, help='load checkpoint config', dest='checkpoint')
    options.add_argument('--cpapi', type=str, help='load checkpoint config via API', dest='checkpoint_api')
    options.add_argument('--checkpointpol', '--cppol', nargs='?',
                         help='specify filename for Checkpoint Security Policies', default='Security_Policy.xml',
                         type=str, metavar='filename', dest='checkpointpol')
    options.add_argument('--checkpointobj', '--cpobj', nargs='?',
                         help='specify filename for Checkpoint Network Objects', default='network_objects.xml',
                         type=str, metavar='filename', dest='checkpointobj')
    options.add_argument('--checkpointsvc', '--cpsvc', nargs='?',
                         help='specify filename for Checkpoint Service Objects', default='services.xml', type=str,
                         metavar='filename', dest='checkpointsvc')
    options.add_argument('--checkpointnat', '--cpnat', nargs='?',
                         help='specify filename for Checkpoint NAT Policy Objects', default='NAT_Policy.xml', type=str,
                         metavar='filename', dest='checkpointnat')
    options.add_argument('--checkpointroute', '--cproute', nargs='?', help='specify filename for Checkpoint Routing',
                         default=None, type=str, metavar='filename', dest='checkpointroute')
    options.add_argument('--fixzones', nargs='?', help='fix zones for rules for specified device-group', default=None,
                         type=str, metavar='device-group', dest='fixzones')
    options.add_argument('--fixzones2', nargs='?', help='fix zones for rules for specified device-group', default=None,
                         type=str, metavar='device-group', dest='fixzones2')
    options.add_argument('--fixzones3', nargs='?', help='fix zones for rules for specified device-group', default=None,
                         type=str, metavar='device-group', dest='fixzones3')
    options.add_argument('--fwtype', nargs='?',
                         help='Firewall type for some options.grouptarget routines ("sonicwall", "palo", "pano", "checkpoint"',
                         default=None, type=str, metavar='firewall-type', dest='fwtype')
    options.add_argument('--checkpointcontext', nargs='?', help='specify context name for Checkpoint config',
                         default='checkpoint', type=str, metavar='string', dest='checkpointcontext')
    options.add_argument('--renamecontext', nargs='?', help='specify context name for Checkpoint config', default=None,
                         type=str, metavar='string', dest='renamecontext')
    options.add_argument('--includepolicies', nargs='+',
                         help='whitelist of checkpoint policies to include when loading .xml config', default=['all'],
                         metavar='list of string', dest='includepolicies')
    options.add_argument('-t', '--tuples', type=str, metavar='filename', help='generate tuples file', dest='tuplefile')
    options.add_argument('--load', nargs='+', type=str, metavar='filename', help='load config from disk',
                         dest='loadconfig')
    options.add_argument('--save', type=str, metavar='filename', help='save config to disk', dest='saveconfig')
    options.add_argument('--saveexp', action='store_true', default=False, help='save exported config file to disk',
                         dest='saveexp')
    options.add_argument('--cipmatch', nargs='+', help='perform matching of individual source networks for IP Schema',
                         metavar='list of IP networks/hosts', type=str, dest='cipmatch')
    options.add_argument('--cipaudit', nargs='+', help='perform matching of individual source networks for IP Schema',
                         metavar='list of IP networks/hosts', type=str, dest='cipaudit')
    options.add_argument('--cipload', type=str, metavar='filename', help='load change matches from disk',
                         dest='cipload')
    options.add_argument('--cipsave', type=str, metavar='filename', help='save change matches to disk', dest='cipsave')
    options.add_argument('--cipreviewin', nargs='?', default='', type=str, metavar='filename',
                         help='csv/tab file with ChangeIP changes', dest='cipreviewin')
    options.add_argument('--cipsubmit', nargs='?', default='', type=str, metavar='filename',
                         help='show page for ChangeIP Submit', dest='cipsubmit')
    options.add_argument('--cipdbedit', action='store_true', default=False,
                         help='generate dbedit commands from ChangeIP matching', dest='cipdbedit')
    options.add_argument('--cipswedit', action='store_true', default=False,
                         help='push cipmatch changes directly to sonicwall', dest='cipswedit')
    options.add_argument('--rename', action='store_true', default=False, help='rename an address-group object',
                         dest='rename')
    options.add_argument('--cipblacklist', nargs='+', help='list of blacklisted policies (do not check)',
                         metavar='Policy Names', default=[], type=str, dest='cipblacklist')
    options.add_argument('--cipshowskipped', action='store_true', default=False,
                         help='include skipped matches in results', dest='cipshowskipped')
    options.add_argument('--cipskippartial', action='store_true', default=False,
                         help='exclude processing partial matches (added for speed due to st pete change for 152.16.136.0/24 network)',
                         dest='cipskippartial')
    options.add_argument('--inverseload', type=str, metavar='filename', help='load inverse matches from disk',
                         dest='inverseload')
    options.add_argument('--inversesave', type=str, metavar='filename', help='save inverse matches to disk',
                         dest='inversesave')
    options.add_argument('--inversecomment', type=str, metavar='filename', default='',
                         help='add comment to inverse match disabled rules', dest='inversecomment')
    options.add_argument('--inverseallrules', action='store_true', default=False,
                         help='perform inverse disable/delete for all rules, not just allow rules',
                         dest='inverseallrules')
    options.add_argument('--policysearch', nargs='+', help='search policies for IP address', metavar='IP Address',
                         type=str, dest='policysearch')
    options.add_argument('--rulematch', nargs='+', help='given source,dest,service find matching rules',
                         metavar='source,dest,prot/port', action=file_list(), type=str, dest='rulematch')
    options.add_argument('--rulemodify', nargs='?', help='given source,dest,service find matching rules',
                         metavar='source,dest,prot/port', type=str, dest='rulemodify')
    options.add_argument('--excludeaddresses', nargs='+',
                         help='exclude these address objects from rulematch search (case sensitive)',
                         metavar='address name', action=file_list(), default=[], type=str, dest='excludeaddress')
    options.add_argument('--excludesrcnetworks', nargs='+', help='exclude these source networks from rulematch search',
                         metavar='network name', action=file_list(), default=[], type=str, dest='excludesrcnetwork')
    options.add_argument('--excludedstnetworks', nargs='+',
                         help='exclude these destination networks from rulematch search', metavar='network name',
                         action=file_list(), default=[], type=str, dest='excludedstnetwork')
    options.add_argument('--batch', nargs='+', help='batch processing of commands',
                         metavar='list of commands or @filename', type=str, dest='batch')  # not yet implemented
    options.add_argument('--inversematch', nargs='+', help='perform "inverse" rule matching',
                         metavar='list of IP networks/hosts', type=str, action=file_list(), dest='inversematch')
    options.add_argument('--inversesingle', action='store_true', default=False,
                         help='for inverse matching, perform matching on one network at a time rather than as a group',
                         dest='inversesingle')
    options.add_argument('--vrouter', help='Virtual Router Name (used in .xml output config', type=str,
                         metavar='string', dest='vrouter', default='VRouter')
    options.add_argument('--logprofile', help='Logprofile name to use for readxlsmigrations and readxls', type=str,
                         metavar='string', dest='logprofile')
    options.add_argument('--securityprofile', help='Security profile name to use for migrations', type=str,
                         metavar='string', dest='securityprofile')
    options.add_argument('--ruletag', help='Tag to add to created rules', type=str, metavar='string', dest='ruletag')
    options.add_argument('--tuplezone', '-tz',
                         help='limit tuple creation to specified source,destination zones (default is All,All)',
                         type=str, metavar='string', dest='tuplezone', default='all,all')
    options.add_argument('--device-group', help='Device Group/Template Name (used in .xml output config', type=str,
                         metavar='string', dest='devicegroup_name', default='Default Device Group')
    options.add_argument('--mappings', nargs='+', help='interface mappings', type=str, metavar='filename',
                         default=['@./interfaces.map'], dest='mappings')
    options.add_argument('--unused', action='store_true', default=False, help='find unused objects', dest='find_unused')
    options.add_argument('--show-unused', action='store_true', default=False,
                         help='show unused objects (will set find used to true)', dest='show_unused')
    ## consider changing default, and then rename this to keep-unused
    options.add_argument('--remove-unused', action='store_true', default=False,
                         help='remove unused objects (will set find used to true)', dest='remove_unused')
    options.add_argument('--show-dupes', action='store_true', default=False, help='show duplicate objects',
                         dest='show_dupes')
    ## consider changing default, and then rename this to keep-dupes
    options.add_argument('--remove-dupes', action='store_true', default=False, help='remove duplicate objects',
                         dest='remove_dupes')
    options.add_argument('--show-devicegroups', action='store_true', default=False,
                         help='show device groups from Panorama configuration', dest='show_devicegroups')
    options.add_argument('--show-templates', action='store_true', default=False,
                         help='show templates from Panorama configuration', dest='show_templates')
    options.add_argument('--skip-disabled', action='store_true', default=False, help='do not load disabled rules',
                         dest='skip_disabled')
    options.add_argument('--exclude-partial', action='store_true', default=False,
                         help='exclude partial matches from matches (currently implemented in CIP match only)',
                         dest='exclude_partial')
    options.add_argument('--show-mismatched', action='store_true', default=False, help='show service mismatches',
                         dest='show_mismatch')
    options.add_argument('--skip-userid', action='store_false', default=True,
                         help='do not include user_id config in output', dest='userid')
    options.add_argument('--dump-config', action='store_true', default=False,
                         help='dump config into an Excel (.xlsx) spreadsheet', dest='dump_config')
    options.add_argument('--show-logprofiles', action='store_true', default=False,
                         help='show log profiles for each device-group', dest='show_logprofiles')
    options.add_argument('--web', '--Submit', action='store_true', default=False, help='enable "web" mode', dest='web')
    options.add_argument('--sccm', action='store_true', default=False,
                         help='Compare "SCCM Servers object in Device group to shared', dest='sccm')
    options.add_argument('--setlogprofile', type=str, help='change log profile setting', dest='setlogprofile')
    options.add_argument('--csv', type=str, help='enable "csv" mode (only used for rulematch currently)', dest='csv')
    options.add_argument('--html', action='store_true', default=False,
                         help='enable "html" mode (only used for rulematch currently)', dest='html')
    options.add_argument('--push', action='store_true', default=False, help='push configuration to panorama',
                         dest='push')
    options.add_argument('--inversedisable', action='store_true', default=False,
                         help='enable "generate report to disable rules from inverse match results',
                         dest='inversedisable')
    options.add_argument('--inversedelete', action='store_true', default=False,
                         help='enable "generate report to delete rules from inverse match results',
                         dest='inversedelete')
    options.add_argument('--inversestats', action='store_true', default=False,
                         help='show report output only, do not execute commands for inverse matching',
                         dest='inversestats')
    options.add_argument('--inverseexecute', nargs='?', const='', type=str,
                         help='execute commands for inverse matching', dest='inverseexecute')
    options.add_argument('--inversepartial', action='store_true', default=False,
                         help='include partial matches in command generation', dest='inversepartial')
    options.add_argument('--inverseaddressdelete', action='store_true', default=False,
                         help='remove address matches from inverse results', dest='inverseaddressdelete')
    options.add_argument('--dbedit', nargs='+', type=str, metavar='context',
                         help='create dbedit objects from a particular config', dest='dbedit')
    options.add_argument('--pan8', action='store_true', default=False, help='target device for config push is pan8',
                         dest='pan8')
    options.add_argument('--username', type=str, help=argparse.SUPPRESS, dest='username')
    options.add_argument('--password', type=str, help=argparse.SUPPRESS, dest='password')
    options.add_argument('--pushusername', type=str, help=argparse.SUPPRESS, dest='pushusername')
    options.add_argument('--pushpassword', type=str, help=argparse.SUPPRESS, dest='pushpassword')
    options.add_argument('--pushnotemplate', action='store_true', default=False,
                         help='do not create or push template/template stack', dest='pushnotemplate')
    options.add_argument('--getconfigs', nargs='+', type=str, help='run Nexpose routines', action=file_list(),
                         dest='getconfigs')
    options.add_argument('--nexpose', '--bulkaddresses', type=str, help='run Nexpose routines', dest='nexpose')
    options.add_argument('--nexposesvc', '--bulkservices', type=str, help='run Nexpose routines', dest='nexposesvc')
    options.add_argument('--nexposerule', '--bulkrules', type=str, nargs='+', help='run Nexpose routines',
                         action=file_list(), dest='nexposerule')
    options.add_argument('--skipzone', action='store_true', default=False,
                         help='do not compute zone for bulk address object creation (for adding objects to group)',
                         dest='skipzone')
    options.add_argument('--addgroupmember', type=str, nargs='+', help='add address object to group',
                         dest='addgroupmember')
    options.add_argument('--matchtypes', type=str, nargs='+', default=['all'],
                         help='what match types to include in rulematch results', dest='matchtypes')
    options.add_argument('--devicestoadd', type=str, metavar='device list',
                         help='list of device serial numbers to add to devgroup/template for panorama push',
                         dest='devicetoadd')
    options.add_argument('--pushfile', type=str, metavar='filename', help='filename to push to panorama',
                         dest='pushfile')
    options.add_argument('--puship', type=str, metavar='IP Address',
                         help='IP address of Panorama server for comamnd push', dest='puship')
    options.add_argument('--firewall', type=str, metavar='String', help='Firewall type (used for HTML forms)',
                         dest='firewall')
    options.add_argument('--expandcheckpoint', action='store_true', default=False,
                         help='When reading Sonicwall configuration, expand "ImportChkpt" group objects into members',
                         dest='expandcheckpoint')
    options.add_argument('--logging', type=int, default=logging.NOTICE, dest='logging')
    options.add_argument('--timeout_sw_webui', type=int, default=30, dest='timeout_sw_webui')
    options.add_argument('--timeout_sw_api', type=int, default=30, dest='timeout_sw_api')
    options.add_argument('--timeout_sw_webui_post', type=int, default=120, dest='timeout_sw_webui_post')
    options.add_argument('--timeout_sw_webui_login', type=int, default=30, dest='timeout_sw_webui_login')
    options.add_argument('--timeout_palo_api', type=int, default=60, dest='timeout_palo_api')
    options.add_argument('-q', '--quiet', action='store_const', const=logging.NONE, dest='logging')
    options.add_argument('-v', help='Verbose (Informational) logging level', action='store_const', const=logging.INFO,
                         dest='logging')
    options.add_argument('--debug', help='Debug level logging', action='store_const', const=logging.DEBUG,
                         dest='logging')
    options.add_argument('--file', nargs='+', help='test for custom action for filespec', metavar='filename meta',
                         default='', action=file_list(), type=str, dest='filename')
    options.add_argument('--ipset', nargs='+', help='test for custom action for filespec', metavar='filename meta',
                         action=file_list('ipset'), type=str, dest='iplist')
    options.add_argument('--readxls', help='preliminary work for converting xls to ruleset', metavar='filename meta',
                         type=str, dest='readxls')
    options.add_argument('--readxls_notshared',
                         help='preliminary work for converting xls to ruleset - putting objects into shared',
                         action='store_false', default=True, dest='readxls_shared')
    options.add_argument('--pushobjects', action='store_true', default=False, help='push address and service objects',
                         dest='pushobjects')
    options.add_argument('--pushrules', action='store_true', default=False, help='push rules', dest='pushrules')
    options.add_argument('--getidp', action='store_true', default=False, help='Get Sonicwall IDP page details',
                         dest='getidp')
    options.add_argument('--zonemaps', nargs='+', help='Zone mapping details when reading XML file',
                         metavar='xlszone,fwzone,policynametext', type=str, dest='zonemaps')
    options.add_argument('--fixzonemaps', nargs='+', help='Zone mapping details when fixing converted Expedition zones',
                         metavar='interface,oldzone,newzone', type=str, action=file_list(), dest='fixzonemaps')
    options.add_argument('--rulelist', nargs='+', help='', metavar='', type=str, action=file_list(), dest='rulelist')
    options.add_argument('--migratezones', nargs='+', help='Zone mapping details when migrating SW to Palo',
                         metavar='sw_zone,palo_zone', type=str, action=file_list(), dest='migratezones')
    options.add_argument('--nick', type=str, help='update logprofiles', dest='nick')
    options.add_argument('--readonly', help='enable readonly for Nexpose address routines', action='store_true',
                         default=False, dest='readonly')
    options.add_argument('--testing', help='enable block of code for Testing new routines', action='store_true',
                         default=False, dest='testing')
    options.add_argument('--gordon', action='store_true', default=False, help='get list of users', dest='gordon')
    options.add_argument('--management', action='store_true', default=False, help='get interface management properties',
                         dest='management')
    options.add_argument('--secureid', action='store_true', default=False,
                         help='update all rules with RSA secureid details', dest='secureid')
    options.add_argument('--movecheckpoint', action='store_true', default=False,
                         help='Generate dbedit commands to move Checkpoint policy to a new CMA', dest='movecheckpoint')
    options.add_argument('--emcroute', nargs='+', type=str, help='Update EMC public network routes internally',
                         dest='emcroute')
    options.add_argument('--comment', type=str, default=argparse.SUPPRESS,
                         help='Comment for bulk object/rule creation (when supported by target)', dest='comment')
    options.add_argument('--sw_upload_fw', help='upload SonicWall firmware file', action='store_true', default=False,
                         dest='sw_upload_fw')
    options.add_argument('--sw_backup', help='perform "Create Backup" on  SonicWall', action='store_true',
                         default=False, dest='sw_backup')
    options.add_argument('--sw_audit', help='audit SonicWall configuration', action='store_true', default=False,
                         dest='sw_audit')
    options.add_argument('--sw_reboot', help='reboot SonicWall using uploaded firmware', action='store_true',
                         default=False, dest='sw_reboot')
    options.add_argument('--sw_failover', help='Force failover on Sonicwall', action='store_true', default=False,
                         dest='sw_failover')
    options.add_argument('--sw_get_tsr', help='upload SonicWall firmware file', action='store_true', default=False,
                         dest='sw_get_tsr')
    options.add_argument('--sw_enable_api', help='', action='store_true', default=False, dest='sw_enable_api')
    options.add_argument('--sw_revert_api', help='', action='store_true', default=False, dest='sw_revert_api')
    options.add_argument('--fixcomments', nargs='+', help='list of address objects that need comment updated',
                         metavar='IP Address', action=file_list(), type=str, dest='fixcomments')
    options.add_argument('--grouptargets', '--targets', nargs='+',
                         help='list of Sonicwall IP addresses to make group changes to', metavar='IP Address',
                         action=file_list(), type=str, dest='grouptargets')
    options.add_argument('--groupaddresses', nargs='+', help='list of IP addresses to add to group',
                         metavar='IP address', action=file_list(), type=str, dest='groupaddresses')
    options.add_argument('--groupmaster', nargs='+',
                         help='list of master group candidate names -- uses first name only', metavar='group names',
                         action=file_list(), type=str, dest='groupmaster')
    options.add_argument('--groupusemaster', action='store_true', default=False,
                         help='place addresses directly into master group rather than subgroups', dest='groupusemaster')
    options.add_argument('--groupservices', nargs='+', help='list of services to add to group', metavar='IP address',
                         action=file_list(), type=str, dest='groupservices')
    options.add_argument('--testcreate', action='store_true', default=False, help='testing', dest='testcreate')
    options.add_argument('--testdelete', action='store_true', default=False, help='testing', dest='testdelete')
    options.add_argument('--testmodify', action='store_true', default=False, help='testing', dest='testmodify')
    options.add_argument('--dmz', action='store_true', default=False, help='testing', dest='dmz')
    options.add_argument('--uuid', type=str, nargs="*", default=None, help='testing', action=file_list(), dest='uuid')
    options.add_argument('--ldap', nargs='+', help='testing', dest='ldap')
    options.add_argument('--recheck', nargs='+', help='list of IP addresses to log into', metavar='IP Address',
                         action=file_list(), type=str, dest='recheck')

    # help=argparse.SUPPRESS

    # NOT IMPLEMENTED YET options.add_argument('--dupes', action='store_true', default=False, help='find duplicate objects', dest='find_dupes')
    # NOT IMPLEMENTED YET options.add_argument('--show-dupes', action='store_true', default=False, help='show duplicate objects', dest='show_dupes')
    # NOT IMPLEMENTED YET options.add_argument('--skip-disabled', action='store_true', default=False, help='ignore disabled rules', dest='skip_disabled')
    # NOT IMPLEMENTED YET options.add_argument('--skip-shared', action='store_true', default=False, help='ignore shared objects', dest='skip_shared')
    ## --show--templates
    ## --show--devicegroups

    ## option for writing config
    ## option to skip shared objects
    ## option to skip disabled rules when reading config - do not do this, as is will mess up checkpoint indexes.  it would be best to just handle disabled rules for the various functions

    return options;


from collections import defaultdict, OrderedDict
import cgi
import cgitb
import urllib3
import xlsxwriter  # needed to be installed
import sys
import time

timestamp = int(time.time())
timestr = str(timestamp)

# configfilename = "config_python.txt"

## build command line argument from form

form = cgi.FieldStorage()
config = defaultdict(dict)
parser = process_cmd_args()

cmdarg = []

for el in form:
    if form.getlist(el) != ['false'] and not form[el].filename:  # do not add parameter if it has a filename value
        cmdarg.extend([str('--' + str(el))])
    for values in form.getlist(el):
        if isinstance(values, str):
            for value in str(values).split('\r\n'):
                if str(value) != 'true' and str(value) != 'false' and str(
                        value).lower() != 'submit':  # do not append values for boolean options
                    cmdarg.extend([str(value)])

## somewhere after creating cmdarg, we have to process checkpointpol and checkpointobj if those files are being uploaded

if 'Submit' in form:
    options = parser.parse_args(cmdarg)
else:
    options = parser.parse_args()

if options.web:
    tabs2 = OrderedDict()
    prevtab = None
    if options.web != None:
        tabs2.update({'console': {'description': 'Console', 'download': True, 'textarea': 'readonly',
                                  'tabtype': 'textarea', 'prevtab': None}})
    if options.rulematch:
        tabs2.update({'rulematch': {'description': 'Matching Rules', 'download': True, 'textarea': 'readonly',
                                    'tabtype': 'table', 'prevtab': list(tabs2)[-1]}})
    if options.outfile != None:
        tabs2.update({'outfile': {'description': 'Configuration Push', 'download': True, 'textarea': 'readonly',
                                  'tabtype': 'textarea', 'prevtab': list(tabs2)[-1]}})
    if options.puship != None:
        tabs2.update({'push': {'description': 'Push Results', 'download': True, 'textarea': 'readonly',
                               'tabtype': 'textarea', 'prevtab': list(tabs2)[-1]}})
    if options.inversedisable:
        tabs2.update({'disable': {'description': 'Disable Report', 'download': True, 'textarea': 'readonly',
                                  'tabtype': 'textarea', 'prevtab': list(tabs2)[-1]}})
    if options.inversedelete:
        tabs2.update({'delete': {'description': 'Delete Report', 'download': True, 'textarea': 'readonly',
                                 'tabtype': 'textarea', 'prevtab': list(tabs2)[-1]}})
    if options.inverseaddressdelete:
        tabs2.update({'address': {'description': 'Address Cleanup Report', 'download': True, 'textarea': 'readonly',
                                  'tabtype': 'textarea', 'prevtab': list(tabs2)[-1]}})
    if options.inversedisable or options.inversedelete or options.inverseaddressdelete:
        tabs2.update({'command': {'description': 'Commands', 'download': True, 'textarea': 'readonly',
                                  'tabtype': 'textarea', 'prevtab': list(tabs2)[-1]}})
    if options.inverseexecute != None or options.pushrules or options.pushobjects:
        tabs2.update({'exec': {'description': 'Command Execution', 'download': True, 'textarea': 'readonly',
                               'tabtype': 'textarea', 'prevtab': list(tabs2)[-1]}})
    if options.inversestats:
        tabs2.update({'stats': {'description': 'Stats', 'download': True, 'textarea': 'readonly', 'tabtype': 'textarea',
                                'prevtab': list(tabs2)[-1]}})
    if options.cipmatch:
        tabs2.update({'report': {'description': 'Report', 'download': True, 'textarea': 'readonly',
                                 'tabtype': 'textarea', 'prevtab': list(tabs2)[-1]}})
        tabs2.update({'reviewout': {'description': 'Review Out', 'download': True, 'textarea': '',
                                    'tabtype': 'textarea', 'prevtab': list(tabs2)[-1]}})
    if options.cipsubmit:
        tabs2.update({'submitchanges': {'description': 'Submit', 'download': False, 'textarea': 'readonly',
                                        'tabtype': 'textarea', 'prevtab': list(tabs2)[-1]}})
    if options.cipdbedit:
        tabs2.update({'reviewin': {'description': 'Review In', 'download': True, 'textarea': 'readonly',
                                   'tabtype': 'textarea', 'prevtab': list(tabs2)[-1]}})
        tabs2.update({'report': {'description': 'Report', 'download': True, 'textarea': 'readonly',
                                 'tabtype': 'textarea', 'prevtab': list(tabs2)[-1]}})
        tabs2.update({'commands': {'description': 'Commands', 'download': True, 'textarea': 'readonly',
                                   'tabtype': 'textarea', 'prevtab': list(tabs2)[-1]}})
    if options.dump_config:
        tabs2.update({'Download': {'description': 'Download', 'download': False, 'textarea': 'readonly',
                                   'tabtype': 'table', 'prevtab': list(tabs2)[-1]}})
    if options.readxls:
        tabs2.update({'ReadXLS': {'description': 'XLS Conversion', 'download': True, 'textarea': 'readonly',
                                  'tabtype': 'textarea', 'prevtab': list(tabs2)[-1]}})

contexts = []

customops = parser.parse_args()

customops.firewall_name = 'CHANGEME'
customops.rule_profile_setting = 'Svc_Segmentation'  # Dell_Corp_Profile_Group

customops.log_forward_profile_name = 'AMER-Dell-Standard-Logging'

customops.snmp_traps = 'AMER-Dell-Standard-SMNP_Traps'
customops.logging = 'AMER-Dell-Standard-Logging'  ## ??
customops.base_rule_name = 'SonicWallImportRule'
customops.devicegroup_name = 'Services Segmentation External'  ## Austin_PC1_Corp_Internal
customops.devicegroup_name = 'Bangalore'
customops.int_mgmt_profile = 'Dell'  ##  ??
customops.logsettings = OrderedDict([('AMER-Dell-Standard-Logging', OrderedDict(
    [('Splunk', {'server': '10.143.0.231', 'port': '514', 'transport': 'UDP', 'format': 'BSD', 'facility': 'LOG_USER'}),
     ('SecureWorksCTA',
      {'server': '143.166.6.185', 'port': '514', 'transport': 'UDP', 'format': 'BSD', 'facility': 'LOG_USER'})])),
                                     ('SecureWorksCTA', OrderedDict([('SecureWorksCTA',
                                                                      {'server': '143.166.6.185', 'port': '514',
                                                                       'transport': 'UDP', 'format': 'BSD',
                                                                       'facility': 'LOG_USER'})]))
                                     ])

customops.trapprofiles = {'AMER-Dell-Standard-SMNP_Traps': {
    'AUSPWSWORAP01': {'ip': '10.177.202.136', 'community': '1bigbox'}
}
}
customops.domain = 'dell.com'
customops.dnsservers = ('10.8.8.8', '10.7.7.7')
customops.secureproxy = OrderedDict([('host', 'anonproxy.us.dell.com'), ('port', '80')])
customops.timezone = 'America/Chicago'
customops.ntpservers = ('143.166.255.32', '143.166.226.32')
customops.updateserver = 'updates.paloaltonetworks.com'
customops.snmpsettings = {'community': '1bigbox', 'contact': 'Security-Network-L3',
                          'location': 'PC1 MDF-R11-R2 U213-16'}
customops.loginbanner = '''*****************************************
           ''' + customops.firewall_name + '''
*****************************************
This node is the property of Dell Inc.

*****************************************
UNAUTHORIZED ACCESS PROHIBITED
*****************************************'''

## Overwrite defaults

customops.logsettings = OrderedDict([('AMER-Dell-Standard-Logging', OrderedDict([('APAC-Splunk',
                                                                                  {'server': '10.93.131.112',
                                                                                   'port': '514', 'transport': 'UDP',
                                                                                   'format': 'BSD',
                                                                                   'facility': 'LOG_USER'}),
                                                                                 ('SecureWorksCTA',
                                                                                  {'server': '143.166.6.186',
                                                                                   'port': '514', 'transport': 'UDP',
                                                                                   'format': 'BSD',
                                                                                   'facility': 'LOG_USER'})])),
                                     ('SecureWorksCTA', OrderedDict([('SecureWorksCTA',
                                                                      {'server': '143.166.6.186', 'port': '514',
                                                                       'transport': 'UDP', 'format': 'BSD',
                                                                       'facility': 'LOG_USER'})]))
                                     ])
customops.snmpsettings = {'community': '1bigbox', 'contact': 'Security-Network-L3', 'location': 'Bangalore BGL4'}
customops.rule_profile_setting = 'Svc_Segmentation'
customops.rule_profile_setting = 'Dell_Corp_Profile_Group'  ## for corp firewalls
customops.log_forward_profile_name = 'AMER-Dell-Standard-Logging'
customops.log_forward_profile_name = 'Dell-AMER-Logging-Profile'  ## for corp firewalls
customops.snmp_traps = 'AMER-Dell-Standard-SMNP_Traps'
customops.logging = 'AMER-Dell-Standard-Logging'
customops.base_rule_name = 'SonicWallImportRule'
customops.devicegroup_name = 'BGL4 Services Segmentation'

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)  # suppress SSL warnings

if options.securityprofile:
    customops.rule_profile_setting = options.securityprofile.lstrip().rstrip()

if options.logprofile:
    customops.log_forward_profile_name = options.logprofile.lstrip().rstrip()

if "ipaddr" in form:  # check if program was called from web form

    cgitb.enable()  ## enable traceback output
    customops.devicegroup_name = form['devicegroup'].value

if "puship" in form:
    cgitb.enable()
    customops.devicegroup_name = form['devicegroup'].value

if "Submit" in form:
    options.web = True

    sys.stdout.write("Transfer-Encoding: chunked\r\n")
    sys.stdout.write("Content-Type: text/html\r\n")
    sys.stdout.flush()
    log('''<style type="text/css">
.container { width: 400px; border: 3px solid #f7c; }
.textareaContainer {
    display: block;
    border: 3px solid #38c;
    padding: 10px;
}
textarea { width: 100%; margin: 2; padding: 2; border-width: 1; }

/* Style the tab */
.tab {
    overflow: hidden;
    border: 1px solid #ccc;
    background-color: #f1f1f1;
}

/* Style the buttons inside the tab */
.tab button {
    background-color: inherit;
    float: left;
    border: none;
    outline: none;
    cursor: pointer;
    padding: 14px 16px;
    transition: 0.3s;
    font-size: 17px;
}

/* Change background color of buttons on hover */
.tab button:hover {
    background-color: #ddd;
}

/* Create an active/current tablink class */
.tab button.active {
    background-color: #ccc;
}

/* Style the tab content */
.tabcontent {
    display: none;
    padding: 6px 12px;
    border: 1px solid #ccc;
    border-top: none;
    animation: fadeEffect 3s;
}

@keyframes fadeEffect {
    from {opacity: 0;}
    to {opacity: 1;}
}
</style>


<div class="tab">
''')
    for tabname in tabs2:
        # label=''
        log('''<button class="tablinks" onclick="openCity(event, \'''' + tabname + '''\')" id="''' + tabname + '''_tab">''' +
            tabs2[tabname]['description'] + '''</button>''')

    # <button class="tablinks" onclick="openCity(event, 'Report')">Report</button>
    # <button class="tablinks" onclick="openCity(event, 'Commands')">Commands</button>

    log('''</div>

<script>
function openCity(evt, cityName) {
    var i, tabcontent, tablinks;
    tabcontent = document.getElementsByClassName("tabcontent");
    for (i = 0; i < tabcontent.length; i++) {
        tabcontent[i].style.display = "none";
    }
    tablinks = document.getElementsByClassName("tablinks");
    for (i = 0; i < tablinks.length; i++) {
        tablinks[i].className = tablinks[i].className.replace(" active", "");
    }
    document.getElementById(cityName).style.display = "block";
    evt.currentTarget.className += " active";
}

// Get the element with id="defaultOpen" and click on it
document.getElementById("console_tab").click();


</script>

''')
    import re

    set_web_tab('console')
    ## fix this so it does not display password
    log(re.sub(r'(--pas.*?) \'.*?\'', r"\1 '*****'", str(cmdarg)),
        level=logging.DEBUG)  ## re.sub(r'--pas.*? --', '', str(cmdarg))

if options.web and 'loadconfig' in form:
    options.loadconfig = [timestr + '.config']
    open(options.loadconfig[0], 'wb').write(form['loadconfig'].file.read())

if options.loadconfig:
    import pickle

    config = OrderedDict()

    for configfile in options.loadconfig:
        log("!-- Loading config : " + configfile)
        infile = open(configfile, 'rb')
        tmp = pickle.load(infile)
        infile.close()
        ## The following conditional is in place for backwards compatibility for old configurations saved that only contained the "config" elements before "customops" was added
        if 'config' in tmp:
            config.update(tmp['config'])
            customops = tmp['custom']
        else:
            # config=tmp
            config.update(tmp)

    contexts = []

    ## generate list of contexts

    if not options.context:
        options.context = ['all']

    if str.lower(options.context[0]) == 'all':
        for device_groups in config:
            contexts.append(device_groups)
    else:
        contexts = options.context

    # for context in contexts:
    # for context in config:
    #    log(context)
    #    for key in config['sonicwall']:
    #        log(key)
    #        log(config['sonicwall'][key])

    for context in contexts:
        if config[context]['config']['fw_type'] == 'sonicwall':
            config[context]['usedzones'] = []
            for interface in config[context]['interfaces']:
                if config[context]['interfaces'][interface]['interface_Zone'] != '':
                    config[context]['usedzones'].append(config[context]['interfaces'][interface]['interface_Zone'])
            all_zones = []
            for zone in config[context]['zones']:
                all_zones.append(config[context]['zones'][zone]['zoneObjId'])
        else:
            config[context]['usedzones'] = []
            if 'zones' in config[context]:
                for zone in config[context]['zones']:
                    if zone != 'default':
                        config[context]['usedzones'].append(config[context]['zones'][zone]['zoneObjId'])

    if options.checkpointroute:
        for context in config:
            if config[context]['config']['fw_type'].lower() == 'checkpoint':
                log('!-- Loading routes for context : {}'.format(context))
                config[context]['routing'], config[context]['interfaces'], config[context][
                    'zones'] = load_checkpoint_routing(options.checkpointroute)
                # log(config[context]['routing'])
                # log(context)

if options.panoramaip:
    if not options.web and (options.username == None or options.password == None):
        options.username, options.password = get_creds()
    palo_xml = get_palo_config_https(options.panoramaip, 'config.panorama.temp', options.username, options.password)
    if palo_xml:
        if options.logging == logging.DEBUG:
            with open(options.panoramaip + '.xml', 'w') as outfile:
                outfile.write(palo_xml)
        config = load_xml('', palo_xml)
        palo_xml = None
        # options.panorama='config.panorama.temp'

    if not options.context:
        options.context = ['all']
    if str.lower(options.context[0]) == 'all':
        for device_groups in config:
            contexts.append(device_groups)
    else:
        contexts = options.context

if options.sonicwall_api_ip:
    # log("!-- Retrieving sonicwall config")
    if not options.web and (options.username == None or options.password == None):
        options.username, options.password = get_creds()
    config['sonicwall'] = load_sonicwall_api(options.sonicwall_api_ip, options.username, options.password)
    if not options.context:
        options.context = ['sonicwall']
    for context in options.context:
        contexts.append(context)

    config['shared'] = {}
    config['shared']['config'] = {}
    config['shared']['config']['name'] = ''
    config['shared']['config']['fw_type'] = ''
    config['shared']['config']['version'] = ''
    config['shared']['config']['mgmtip'] = ''
    config['shared']['addresses'] = {}
    config['shared']['services'] = {}
    config['shared']['policies'] = {}  # return_policy
    config['shared']['nat'] = {}
    config['shared']['apps'] = {}
    config['shared']['addressmappings'] = {}
    config['shared']['servicemappings'] = {}
    config['shared']['logprofiles'] = {}
    # for context in config:
    #    log(context)

if options.sonicwallip:
    # log("!-- Retrieving sonicwall config")
    if not options.web and (options.username == None or options.password == None):
        options.username, options.password = get_creds()
    config = get_sonicwall_exp(options.sonicwallip)

    '''
    exp_config=get_sw_config_https(options.sonicwallip, None, options.username, options.password)
    #print(exp_config)
    tmpconfig=None
    if exp_config: 
        if options.logging==logging.DEBUG or options.saveexp: 
                outfile=open(options.sonicwallip + '.exp', 'w')
                outfile.write(exp_config)
                outfile.close()
        memory_config=convert_exp_file('', None, exp_config.encode())
        exp_config=None # free up memory 
        if memory_config:
            if options.logging==logging.DEBUG: 
                outfile=open(options.sonicwallip + '.txt', 'w')
                outfile.write(memory_config)
                outfile.close()
                #debug(memory_config)
            tmpconfig=load_sonicwall('', True, memory_config)
            memory_config=None  # free up memory

    #tmpconfig=load_sonicwall(options.sonicwall, options.skip_disabled, exp_config) # CHANGEME boolean value for skip-disabled

    if tmpconfig:
        if options.context !='':
            tmpcontext=options.context[0]
        else:
            tmpcontext=tmpconfig['config']['name']
        config[tmpcontext] = tmpconfig
        if not options.context:
            options.context = [tmpcontext]
        for context in options.context:
            contexts.append(context)
        tmpconfig=None  # free up memory
    '''

    ## experimental routines to load objects via https/JSON -- might be useful for unused rules routines to ensure proper indexes.
    '''
    import requests,json
    import sonicwall as sw
    urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
    session = requests.Session()
    session.mount(options.sonicwallip, DESAdapter())
    urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
    response=sw.do_login(session, options.username, options.password, options.sonicwallip)
    #print(response)
    command='https://' + options.sonicwallip + '/getObjectList.json'
    response=session.get(command, verify=False)
    #print(response.text)
    object_dict=json.loads(response.text)
    
    #print(json.dumps(object_dict, sort_keys=True, indent=4))
    
    for addr in object_dict['addrObjArray'].split('|'):
        print(addr)
        name,addrtype,zone,properties,mcast,ip1,ip2,mac,fqdn,maxHosts,v6ip1,v6ip2,v6PrefixLen,ipver,children,extraInfo=addr.split(',')
        print(name)
        if addrtype=='8':
            for child in children.split('^'):
                print('  ' + child)
    #print(object_dict['addrObjArray'].split('|')[0])
    #session=
    '''

    config['shared'] = {}
    config['shared']['config'] = {}
    config['shared']['config']['name'] = ''
    config['shared']['config']['fw_type'] = ''
    config['shared']['config']['version'] = ''
    config['shared']['config']['mgmtip'] = ''
    config['shared']['addresses'] = {}
    config['shared']['services'] = {}
    config['shared']['policies'] = {}  # return_policy
    config['shared']['nat'] = {}
    config['shared']['apps'] = {}
    config['shared']['addressmappings'] = {}
    config['shared']['servicemappings'] = {}
    config['shared']['logprofiles'] = {}

if options.web and 'cipreviewin' in form:
    if form['cipreviewin'].filename != '':
        options.cipreviewin = timestr + '.cipreview'
        open(options.cipreviewin, 'wb').write(form['cipreviewin'].file.read())

if options.web and 'readxls' in form:
    if form['readxls'].filename != '':
        log('readxls filename set')
        log('\'' + str(form['readxls'].filename) + '\'')
        options.readxls = "readxls.xlsx"
        open(options.readxls, 'wb').write(form['readxls'].file.read())

if options.web and 'load' in form:
    if form['load'].filename != '':
        log('load config filename set')
        log('\'' + str(form['load'].filename) + '\'')
        options.loadfile = "webtemp.config"

if options.includepolicies != ['all']:
    import os

    newlist = []
    for policy in options.includepolicies:
        if len(os.path.basename(policy)) > 0:
            if os.path.basename(policy[0]) == '@':
                for i in file_to_list(policy[1:]):
                    if i[0] != '#':
                        newlist.append(i.rstrip().lstrip())
            else:
                newlist.append(policy)
    options.includepolicies = newlist

if options.web and 'checkpointpol' in form and 'checkpointobj' in form and 'checkpointsvc' in form and 'checkpointnat' in form:
    if form['checkpointpol'].filename != '':
        log('checkpoint policy filename set')
        log('\'' + str(form['checkpointpol'].filename) + '\'')
        options.checkpointpol = "Security_Policy.xml"
        open(options.checkpointpol, 'wb').write(form['checkpointpol'].file.read())
        if form['checkpointobj'].filename != '':
            log('checkpoint object filename set')
            log(str(form['checkpointobj'].filename))
            options.checkpointobj = "network_objects.xml"
            open(options.checkpointobj, 'wb').write(form['checkpointobj'].file.read())
            if form['checkpointsvc'].filename != '':
                log('checkpoint service filename set')
                log(str(form['checkpointsvc'].filename))
                options.checkpointsvc = "services.xml"
                open(options.checkpointsvc, 'wb').write(form['checkpointsvc'].file.read())
                if form['checkpointnat'].filename != '':
                    log('checkpoint nat filename set')
                    log(str(form['checkpointnat'].filename))
                    options.checkpointnat = "NAT_Policy.xml"
                    open(options.checkpointnat, 'wb').write(form['checkpointnat'].file.read())
                    if not options.context:
                        options.context = [options.checkpointcontext]
                    for context in options.context:
                        contexts.append(context)
                    config[options.checkpointcontext] = load_checkpoint(secobj=options.checkpointpol,
                                                                        natobj=options.checkpointnat,
                                                                        svcobj=options.checkpointsvc,
                                                                        netobj=options.checkpointobj,
                                                                        routeobj=options.checkpointroute)
                    config['shared']['config'] = {}
                    config['shared']['config']['name'] = ''
                    config['shared']['config']['fw_type'] = ''
                    config['shared']['config']['version'] = ''
                    config['shared']['config']['mgmtip'] = ''
                    config['shared']['addresses'] = {}
                    config['shared']['services'] = {}
                    config['shared']['policies'] = {}  # return_policy
                    config['shared']['nat'] = {}
                    config['shared']['apps'] = {}
                    config['shared']['addressmappings'] = {}
                    config['shared']['servicemappings'] = {}
                    config['shared']['logprofiles'] = {}

if options.show_devicegroups:
    if options.loadconfig:
        for context in contexts:
            log(context)
    elif not options.panorama:
        log("ERROR! Panorama configuration not specified with -I or -P flags", level=logging.ERROR)
        exit(1)
    else:
        show_devicegroups(options.panorama)

if options.show_templates:
    if not options.panorama:
        log("ERROR! Panorama configuration not specified with -I or -P flags", level=logging.ERROR)
        exit(1)
    else:
        show_templates(options.panorama)

if options.checkpoint_api:
    # options.checkpoint_api='128.221.62.90'
    # options.context=['CMA-SBS2']
    if not options.web and (not options.username or not options.password):
        options.username, options.password = get_creds()
    # options.username='jmiller'
    # options.password='password'
    for context in options.context:
        config[context] = load_checkpoint_api(options.checkpoint_api, context, options.username, options.password)
        config['shared'] = {}
        config['shared']['config'] = {}
        config['shared']['config']['name'] = ''
        config['shared']['config']['fw_type'] = ''
        config['shared']['config']['version'] = ''
        config['shared']['config']['mgmtip'] = ''
        config['shared']['addresses'] = {}
        config['shared']['services'] = {}
        config['shared']['policies'] = {}  # return_policy
        config['shared']['nat'] = {}
        config['shared']['apps'] = {}
        config['shared']['addressmappings'] = {}
        config['shared']['servicemappings'] = {}
        config['shared']['logprofiles'] = {}

        contexts.append(context)

if options.checkpoint:  ## this was moved to loading before panorama due to init 'shared' to empty dictionaries

    if not options.context:
        options.context = [options.checkpointcontext]
    for context in options.context:
        contexts.append(context)

    if not options.checkpointpol: options.checkpointpol = "Security_Policy.xml"
    if not options.checkpointnat: options.checkpointnat = "NAT_Policy.xml"
    if not options.checkpointsvc: options.checkpointsvc = "services.xml"
    if not options.checkpointobj: options.checkpointobj = "network_objects.xml"
    config[options.checkpointcontext] = load_checkpoint(secobj=options.checkpointpol, natobj=options.checkpointnat,
                                                        svcobj=options.checkpointsvc, netobj=options.checkpointobj,
                                                        routeobj=options.checkpointroute)
    config['shared'] = {}
    config['shared']['config'] = {}
    config['shared']['config']['name'] = ''
    config['shared']['config']['fw_type'] = ''
    config['shared']['config']['version'] = ''
    config['shared']['config']['mgmtip'] = ''
    config['shared']['addresses'] = {}
    config['shared']['services'] = {}
    config['shared']['policies'] = {}  # return_policy
    config['shared']['nat'] = {}
    config['shared']['apps'] = {}
    config['shared']['addressmappings'] = {}
    config['shared']['servicemappings'] = {}
    config['shared']['logprofiles'] = {}

if options.panorama:

    config = load_xml(options.panorama)

    ## Add IPSet property to groups -- This has do be done outside load_xml because 'shared' objects are not defined until after returning and expand_address uses global config['shared'] dict

    from netaddr import IPSet

    for context in config:
        debug(context)
        for addr in config[context]['addresses']:
            if config[context]['addresses'][addr]['addrObjType'] == '8':
                config[context]['addresses'][addr]['IPSet'] = IPSet([])
                for groupmember in expand_address(config[context]['addresses'], addr,
                                                  config[context]['addressmappings']):
                    if groupmember in config[context]['addresses']:
                        for network in config[context]['addresses'][groupmember]['IPv4Networks']:
                            config[context]['addresses'][addr]['IPSet'].add(str(network))
                    elif groupmember in config['shared']['addresses']:
                        for network in config['shared']['addresses'][groupmember]['IPv4Networks']:
                            config[context]['addresses'][addr]['IPSet'].add(str(network))

    if not options.context:
        options.context = ['all']
    if str.lower(options.context[0]) == 'all':
        for device_groups in config:
            contexts.append(device_groups)
    else:
        contexts = options.context

if options.sonicwall:
    # log(options.sonicwall)
    tmpconfig = load_sonicwall(options.sonicwall, options.skip_disabled)  # CHANGEME boolean value for skip-disabled

    if tmpconfig:
        if options.context != '':
            tmpcontext = options.context[0]
        else:
            tmpcontext = tmpconfig['config']['name']
        config[tmpcontext] = tmpconfig
        if not options.context:
            options.context = [tmpcontext]
        for context in options.context:
            contexts.append(context)
        tmpconfig = None

        ## Initialize shared objects to empty

    else:
        log('Loading Sonicwall Config failed')

    config['shared'] = {}
    config['shared']['config'] = {}
    config['shared']['config']['name'] = ''
    config['shared']['config']['fw_type'] = ''
    config['shared']['config']['version'] = ''
    config['shared']['config']['mgmtip'] = ''
    config['shared']['addresses'] = {}
    config['shared']['services'] = {}
    config['shared']['policies'] = {}  # return_policy
    config['shared']['nat'] = {}
    config['shared']['apps'] = {}
    config['shared']['addressmappings'] = {}
    config['shared']['servicemappings'] = {}
    config['shared']['logprofiles'] = {}

if options.renamecontext:
    if 'sonicwall' in config:
        config[options.renamecontext] = config.pop('sonicwall')

if options.saveconfig:
    if len(config) > 1:  # only save if config has something more than shared
        log("!-- Saving config")
        import pickle

        outfile = open(options.saveconfig, 'wb')
        tmp = OrderedDict()
        tmp['config'] = config
        tmp['custom'] = customops
        result = pickle.dump(tmp, outfile)
        outfile.close()

if options.address:
    for context, parent, addr_name, addr_def in search_address(options.address, contexts):
        log('{},{},{},{}'.format(context, parent, addr_name, addr_def))

if options.exp_service:
    ## (DONE)- Do this for specified contexts
    ## Output for this should be better.  Perhaps printing a tree, or at least if each object is an address or group
    for service in options.exp_service:
        # log('')
        # log('-' * 120)
        for context in contexts:
            if 'servicemappings' in config[context]:
                services = expand_service(config[context]['services'], service, config[context]['servicemappings'],
                                          False)
                if services:
                    # log('Context: ' + context)
                    # log('-' * 120)
                    for item in services:
                        prot = get_prot_of(config[context]['services'], item)
                        portlist = get_ports_of(config[context]['services'], item)
                        log('{},{},{},{},{}'.format(context, service, item, prot, str(portlist)))

                        ## svcPortSet FIX -- output for this should either be port1, port1-port2 or a list for each item in the set

if options.ipaddr:
    find_ip_address(config, options.ipaddr, contexts)

if options.ipaddr:
    search_ip(options.ipaddr, contexts)

if options.exactipaddr:
    find_ip_address(config, options.exactipaddr, contexts, True)

if options.policysearch:
    for context in contexts:
        log('context: ' + context)
        if context != 'shared':
            find_ip_address_in_policy(config[context]['policies'], config[context]['addresses'],
                                      config[context]['addressmappings'], options.policysearch)
            # change "find_ip_address_in_policy" to only return results

# options.rulemodify='TACACS-SERVERS,drmplics01.drm.amer.dell.com,banplics01.blr.apac.dell.com,crkplics01.crk.emea.dell.com'

if options.rulematch:
    if options.web:
        set_web_tab('rulematch')
    find_matching_rules2(config, config['shared'], options.rulematch, contexts, options.rulemodify)
    # change "find_ip_address_in_policy" to only return results

# if options.rulematch and options.rulemodify:
# log('!-- Finding matching rules - and modifying')
# if options.web:
# set_web_tab('rulematch')
# find_matching_rules(config, config['shared'], options.rulematch, contexts, options.rulemodify)


## this is "test" code to generate html to show only the log profiles based on the selected devicegroup from a dropdown

if options.show_logprofiles:
    import json

    logprofiles = OrderedDict()

    log('''
<html>
    <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <script language="javascript" type="text/javascript">
    function dynamicdropdown(listindex)
    {
        switch (listindex)
        {
    ''')

    for context in contexts:
        log('        case "' + context + '" :')
        log('            document.getElementById("logprofile").options[' + str(0) + ']=new Option("None","none");')
        for idx, log in enumerate(config[context]['logprofiles']):
            log('document.getElementById("logprofile").options[' + str(
                idx + 1) + ']=new Option("' + log + '","' + log + '");')
        log('            break;')
    log('}')

    log('''
        return true;
    }
    </script>
    </head>
    <title>Dynamic Drop Down List</title>
    <body>
    <font size="4">
    <div class="category_div" id="category_div">Device-Group:
        <select id="Device-Group" name="Device-Group" onchange="javascript: dynamicdropdown(this.options[this.selectedIndex].value);">
        <option value="">Select Device-Group</option>
    ''')

    for context in contexts:
        log('<option value="' + context + '">' + context + '</option>')

    log('''
        </select>
    </div>
    <div class="sub_category_div" id="sub_category_div">Log Profile:
        <script type="text/javascript" language="JavaScript">
        document.write('<select name="logprofile" id="logprofile"><option value="">Select Logging Profile</option></select>')
        </script>
        <noscript>
        <select id="logprofile" name="logprofile">
<!--            <option value="open">OPEN</option>
            <option value="delivered">DELIVERED</option>
-->
         </select>
        </noscript>
    </div>
    </font>
    </body>
</html>

    ''')

if options.service:
    find_service(config, options.service, contexts)

if options.exactservice:
    find_service(config, options.exactservice, contexts, True)

if options.show_dupes or options.remove_dupes:
    # iterate through each of the selected contexts
    # do this before creating address/service mappings

    log("!-- Finding Duplicate Objects")
    for c in contexts:
        if config[c]['config']['fw_type'] == 'sonicwall':
            # duplicates=find_dupes(config['sonicwall'])  ## need to remove hardcoded contextname
            print(c)
            duplicates = find_dupes(config[c])
            break

if options.show_dupes:
    for index in duplicates['addresses']:
        log('{:60.60} : {:60.60}'.format(index, duplicates['addresses'][index]))

    for index in duplicates['services']:
        log('{:60.60} : {:60.60}'.format(index, duplicates['services'][index]))

if options.remove_dupes:
    log("!-- Renaming Duplicate Objects in Policies")
    replacements = remove_dupes(duplicates, c)

if options.show_unused:  ##FIXSHARED
    log("!-- Finding Unused Objects (Single-Pass)")
    for context in contexts:
        log(context)
        log('-' * 120)
        if context != "shared":
            unused = find_unused2(config[context], context)
            if len(unused["addresses"]) > 0 or len(unused["addressgroups"]) > 0:
                for address in unused["addresses"]:
                    log("address," + context + "," + address)
                for address in unused["addressgroups"]:
                    log("addressgroup," + context + "," + address)
                for service in unused["services"]:
                    log("service," + context + "," + service)
                for service in unused["servicegroups"]:
                    log("servicegroup," + context + "," + service)
                for address in unused["addresses"]:
                    create_address_obj('', '', '', 'checkpoint', 'cli',
                                       {'addresstype': config[context]['addresses'][address]['addrObjType'],
                                        'addressname': config[context]['addresses'][address]['addrObjId'],
                                        'ip1': config[context]['addresses'][address]['addrObjIp1'],
                                        'ip2': config[context]['addresses'][address]['addrObjIp2'],
                                        'color': config[context]['addresses'][address]['addrObjColor'],
                                        'comment': config[context]['addresses'][address]['addrObjComment']})
                    pass
                for address in unused["addressgroups"]:
                    create_address_obj('', '', '', 'checkpoint', 'cli',
                                       {'addresstype': config[context]['addresses'][address]['addrObjType'],
                                        'addressname': config[context]['addresses'][address]['addrObjId'],
                                        'ip1': config[context]['addresses'][address]['addrObjIp1'],
                                        'ip2': config[context]['addresses'][address]['addrObjIp2'],
                                        'color': config[context]['addresses'][address]['addrObjColor'],
                                        'comment': config[context]['addresses'][address]['addrObjComment'],
                                        'members': [x for x in config[context]['addressmappings'][address]]})
                    pass
                for service in unused["services"]:
                    create_service_obj('', '', '', 'checkpoint', 'cli',
                                       {'servicetype': config[context]['services'][service]['svcObjType'],
                                        'servicename': config[context]['services'][service]['svcObjId'],
                                        'port1': config[context]['services'][service]['svcObjPort1'],
                                        'port2': config[context]['services'][service]['svcObjPort2'],
                                        'protocol': config[context]['services'][service]['svcObjIpType'],
                                        'color': config[context]['services'][service]['svcObjColor'],
                                        'comment': config[context]['services'][service]['svcObjComment']})

                for service in unused["servicegroups"]:
                    create_service_obj('', '', '', 'checkpoint', 'cli',
                                       {'servicetype': config[context]['services'][service]['svcObjType'],
                                        'servicename': config[context]['services'][service]['svcObjId'],
                                        'color': config[context]['services'][service]['svcObjColor'],
                                        'comment': config[context]['services'][service]['svcObjComment'],
                                        'members': [x for x in config[context]['servicemappings'][service]]})

## CHANGEME - move to function

if options.remove_unused:

    # For now, only remove unused objects for the sonicwall context, as this is intended to be used for migration purposes only.
    # The show_unused routine will check against all contexts, for the sake of running reports.
    # The while loop is used to run multiple passes, until there is no change in the number of address+service objects, OR
    # there are no changes to the address mappings.  The first pass will likely not have any changes to the address mappings

    # address mappings are primarily a collection of address objects.  since those address objects are part of an address group,
    # on the first pass, they will not be considered unused, and the address group will remain unchanged.  however, on the first
    # pass, some address groups will be removed, which will then cause some address objects to be unused during the second
    # pass.  this will then result in the address mappings being modified.  i dont believe that on the first pass any mapping
    # could be modified, as all its members should be marked as being in use.

    tmpaddr = OrderedDict()
    tmpsvc = OrderedDict()
    tmpaddrmap = OrderedDict()
    tmpsvcmap = OrderedDict()

    import inflect  # had to be installed

    passstr = inflect.engine()

    for context in contexts:
        if config[context]['config']['fw_type'] == "sonicwall":
            start = 0
            passnum = 1
            while start != (len(config[context]['addresses']) + len(config[context]['services'])):
                start = len(config[context]['addresses']) + len(config[context]['services'])
                ## create dictionary of unused addresses, services, addressgroups and servicegroups
                log("!-- Finding Unused Objects - " + passstr.ordinal(passnum) + " pass")
                unused = find_unused(config[context], context)
                log('!-- Found ' + str(
                    len(unused['addresses']) + len(unused['addressgroups']) + len(unused['services']) + len(
                        unused['servicegroups'])) + ' Objects to be removed.')
                log("!-- Removing Unused Objects - " + passstr.ordinal(passnum) + " pass")
                ## update address objects

                for address in config[context]['addresses']:
                    if address in unused['addresses'] or address in unused['addressgroups']:
                        pass
                        log('removing address item : ' + address, level=logging.INFO)
                    else:
                        tmpaddr[address] = config[context]['addresses'][address]
                config[context]['addresses'] = tmpaddr

                # remove unused objects from address maps

                for address in config[context]['addressmappings']:
                    mapsize = len(config[context]['addressmappings'][address])
                    config[context]['addressmappings'][address] = list(
                        (set(config[context]['addressmappings'][address]) - set(unused["addresses"])) - set(
                            unused["addressgroups"]))
                    if mapsize != len(config[context]['addressmappings'][address]):
                        start = 0  # force another check since an group was modifed

                for service in config[context]['services']:
                    if service in unused["services"] or service in unused["servicegroups"]:
                        pass
                        log('removing service item : ' + service, level=logging.INFO)
                    else:
                        tmpsvc[service] = config[context]['services'][service]
                config[context]['services'] = tmpsvc

                for service in config[context]['servicemappings']:
                    mapsize = len(config[context]['servicemappings'][service])
                    config[context]['servicemappings'][service] = list(
                        (set(config[context]['servicemappings'][service]) - set(unused["services"])) - set(
                            unused["servicegroups"]))
                    if mapsize != len(config[context]['servicemappings'][service]):
                        start = 0  # force another check since an group was modifed

                passnum += 1

##  show objects with TCP in name, but defined as UDP and vice-versa

if options.show_mismatch:
    import re

    for context in contexts:
        for service in config[context]['services']:
            if re.findall('tcp', config[context]['services'][service]['svcObjId'].lower()) != []:
                if config[context]['services'][service]['svcObjIpType'] not in ['0', '6']:
                    log('{:40.40s} {:5.5s} {:10.10s} {:10.10s}'.format(config[context]['services'][service]['svcObjId'],
                                                                       config[context]['services'][service][
                                                                           'svcObjIpType'],
                                                                       config[context]['services'][service][
                                                                           'svcObjPort1'],
                                                                       config[context]['services'][service][
                                                                           'svcObjPort2']))
            if re.findall('udp', config[context]['services'][service]['svcObjId'].lower()) != []:
                if config[context]['services'][service]['svcObjIpType'] not in ['0', '17']:
                    log('{:40.40s} {:5.5s} {:10.10s} {:10.10s}'.format(config[context]['services'][service]['svcObjId'],
                                                                       config[context]['services'][service][
                                                                           'svcObjIpType'],
                                                                       config[context]['services'][service][
                                                                           'svcObjPort1'],
                                                                       config[context]['services'][service][
                                                                           'svcObjPort2']))

if options.outfile:  ## move to function CHANGEME

    log('!-- Building xml Configuration File')
    log('!-- Reading Interface Mappings')
    interface_map = load_interface_mappings(options.mappings)

    webtmp = options.web
    source_routes = False
    options.web = False
    for context in config:
        if config[context]['config']['fw_type'].lower() == 'sonicwall':
            create_config(config[context], interface_map, options.outfile, context)
            # create_config(config[context], interface_map, '/var/www/html/converted/outfile.xml', context)
            if 'routing' in config[context]:
                for route in config[context]['routing']:
                    if config[context]['routing'][route]['pbrObjSrc'] != '':
                        source_routes = True
                        break
            break  ## exit after first sonicwall fw_type is found
    options.web = webtmp

    if options.web:
        set_web_tab('outfile')
        if source_routes:
            log("          ********************************************************************************************************************************")
            log("          ********************************************************************************************************************************")
            log('')
            log("          ROUTES WITH SOURCE NETWORKS FOUND, THESE WILL NEED TO BE ADDED MANUALLY IN THE DEVICE-GROUP VIA A POLICY BASED FORWARDING RULE!")
            log('')
            log("          ********************************************************************************************************************************")
            log("          ********************************************************************************************************************************")
            log('')
            log('')
        log("Implementation commands")

    log("To load this configuration into Panorama : ")
    log("-------------------------------------------")
    log(" Via Panorama CLI: ")
    log("-------------------------------------------")
    log("scp import configuration from username@hostname/IP:PATH/FILENAME")
    log('load config partial from python.xml mode replace from-xpath \'/config/devices/entry[@name=\"localhost.localdomain\"]/device-group/entry[@name=\"' + customops.devicegroup_name + '\"]/address\' to-xpath \'/config/devices/entry[@name=\"localhost.localdomain\"]/device-group/entry[@name=\"' + customops.devicegroup_name + '\"]/address\'')
    log('load config partial from python.xml mode replace from-xpath \'/config/devices/entry[@name=\"localhost.localdomain\"]/device-group/entry[@name=\"' + customops.devicegroup_name + '\"]/address-group\' to-xpath \'/config/devices/entry[@name=\"localhost.localdomain\"]/device-group/entry[@name=\"' + customops.devicegroup_name + '\"]/address-group\'')
    log('load config partial from python.xml mode replace from-xpath \'/config/devices/entry[@name=\"localhost.localdomain\"]/device-group/entry[@name=\"' + customops.devicegroup_name + '\"]/service\' to-xpath \'/config/devices/entry[@name=\"localhost.localdomain\"]/device-group/entry[@name=\"' + customops.devicegroup_name + '\"]/service\'')
    log('load config partial from python.xml mode replace from-xpath \'/config/devices/entry[@name=\"localhost.localdomain\"]/device-group/entry[@name=\"' + customops.devicegroup_name + '\"]/service-group\' to-xpath \'/config/devices/entry[@name=\"localhost.localdomain\"]/device-group/entry[@name=\"' + customops.devicegroup_name + '\"]/service-group\'')
    log('load config partial from python.xml mode replace from-xpath \'/config/shared/log-settings\' to-xpath \'/config/devices/entry[@name=\"localhost.localdomain\"]/template/entry[@name=\"' + customops.devicegroup_name + '\"]/config/shared/log-settings\'')
    log('load config partial from python.xml mode replace from-xpath \'/config/log-settings\' to-xpath \'/config/devices/entry[@name=\"localhost.localdomain\"]/device-group/entry[@name=\"' + customops.devicegroup_name + '\"]/log-settings\'')
    log('load config partial from python.xml mode replace from-xpath \'/config/devices/entry[@name=\"localhost.localdomain\"]/device-group/entry[@name=\"' + customops.devicegroup_name + '\"]/profile-group\' to-xpath \'/config/devices/entry[@name=\"localhost.localdomain\"]/device-group/entry[@name=\"' + customops.devicegroup_name + '\"]/profile-group\'')
    log('load config partial from python.xml mode replace from-xpath \'/config/devices/entry[@name=\"localhost.localdomain\"]/device-group/entry[@name=\"' + customops.devicegroup_name + '\"]/pre-rulebase\' to-xpath \'/config/devices/entry[@name=\"localhost.localdomain\"]/device-group/entry[@name=\"' + customops.devicegroup_name + '\"]/pre-rulebase\'')
    log('load config partial from python.xml mode replace from-xpath \'/config/devices/entry[@name=\"localhost.localdomain\"]/network\' to-xpath \'/config/devices/entry[@name=\"localhost.localdomain\"]/template/entry[@name=\"' + customops.devicegroup_name + '\"]/config/devices/entry[@name=\"localhost.localdomain\"]/network\'')
    log('load config partial from python.xml mode replace from-xpath \'/config/devices/entry[@name=\"localhost.localdomain\"]/vsys/entry[@name=\'vsys1\']/import\' to-xpath \'/config/devices/entry[@name=\"localhost.localdomain\"]/template/entry[@name=\"' + customops.devicegroup_name + '\"]/config/devices/entry[@name=\"localhost.localdomain\"]/vsys/entry[@name=\'vsys1\']/import\'')
    log('load config partial from python.xml mode replace from-xpath \'/config/devices/entry[@name=\"localhost.localdomain\"]/vsys/entry[@name=\'vsys1\']/zone\' to-xpath \'/config/devices/entry[@name=\"localhost.localdomain\"]/template/entry[@name=\"' + customops.devicegroup_name + '\"]/config/devices/entry[@name=\"localhost.localdomain\"]/vsys/entry[@name=\'vsys1\']/zone\'')
    log('load config partial from python.xml mode replace from-xpath \'/config/devices/entry[@name=\"localhost.localdomain\"]/deviceconfig\' to-xpath \'/config/devices/entry[@name=\"localhost.localdomain\"]/template/entry[@name=\"' + customops.devicegroup_name + '\"]/config/devices/entry[@name=\"localhost.localdomain\"]/deviceconfig\'')

    ## define device-group and template names first
    import urllib.parse

    u = '%USERNAME%'
    p = '%PASSWORD%'
    h = '%PANORAMAIP%'
    options.devicetoadd = '00081C0000'

    ## update this with name of output file
    log("-------------------------------------------")
    log(" Via API : (Replace values between %'s)")
    log("-------------------------------------------")
    log("scp import configuration from username@hostname/IP:PATH/FILENAME")
    log('curl -u \'' + u + ':' + p + '\' -k --form file=@"' + options.outfile + '" \'https://' + h + '/api/?type=import&category=configuration\'')
    log('curl -u \'' + u + ':' + p + '\' -k \'https://' + h + '/api/?type=config&action=set&xpath=' + urllib.parse.quote_plus(
        "/config/devices/entry[@name='localhost.localdomain']/device-group") + "&element=<entry%20name=\"" + customops.devicegroup_name + "\"></entry>" + '\'')
    log('curl -u \'' + u + ':' + p + '\' -k \'https://' + h + '/api/?type=config&action=set&xpath=' + urllib.parse.quote_plus(
        "/config/devices/entry[@name='localhost.localdomain']/template") + "&element=<entry%20name=\"" + customops.devicegroup_name + "\"></entry>" + '\'')

    log('curl -u \'' + u + ':' + p + '\' -k \'https://' + h + '/api/?type=config&action=set&xpath=' + urllib.parse.quote_plus(
        "/config/devices/entry[@name='localhost.localdomain']/device-group/entry[@name=\"" + customops.devicegroup_name + "\"]") + "&element=<devices>" + options.devicetoadd + "</devices>" + '\'')
    log('curl -u \'' + u + ':' + p + '\' -k \'https://' + h + '/api/?type=config&action=set&xpath=' + urllib.parse.quote_plus(
        "/config/devices/entry[@name='localhost.localdomain']/template/entry[@name=\"" + customops.devicegroup_name + "\"]") + "&element=<devices>" + options.devicetoadd + "</devices>" + '\'')

    log('curl -u \'' + u + ':' + p + '\' -k \'https://' + h + '/api/?type=op&cmd=<load><config><partial><mode>replace</mode><from>bangalore.xml</from><from-xpath>' + urllib.parse.quote_plus(
        "/config/devices/entry[@name=\"localhost.localdomain\"]/device-group/entry[@name=\"" + customops.devicegroup_name + "\"]/address") + '</from-xpath><to-xpath>' + urllib.parse.quote_plus(
        "/config/devices/entry[@name=\"localhost.localdomain\"]/device-group/entry[@name=\"" + customops.devicegroup_name + "\"]/address") + '</to-xpath></partial></config></load>\'')
    log('curl -u \'' + u + ':' + p + '\' -k \'https://' + h + '/api/?type=op&cmd=<load><config><partial><mode>replace</mode><from>bangalore.xml</from><from-xpath>' + urllib.parse.quote_plus(
        "/config/devices/entry[@name=\"localhost.localdomain\"]/device-group/entry[@name=\"" + customops.devicegroup_name + "\"]/address-group") + '</from-xpath><to-xpath>' + urllib.parse.quote_plus(
        "/config/devices/entry[@name=\"localhost.localdomain\"]/device-group/entry[@name=\"" + customops.devicegroup_name + "\"]/address-group") + '</to-xpath></partial></config></load>\'')
    log('curl -u \'' + u + ':' + p + '\' -k \'https://' + h + '/api/?type=op&cmd=<load><config><partial><mode>replace</mode><from>bangalore.xml</from><from-xpath>' + urllib.parse.quote_plus(
        "/config/devices/entry[@name=\"localhost.localdomain\"]/device-group/entry[@name=\"" + customops.devicegroup_name + "\"]/service") + '</from-xpath><to-xpath>' + urllib.parse.quote_plus(
        "/config/devices/entry[@name=\"localhost.localdomain\"]/device-group/entry[@name=\"" + customops.devicegroup_name + "\"]/service") + '</to-xpath></partial></config></load>\'')
    log('curl -u \'' + u + ':' + p + '\' -k \'https://' + h + '/api/?type=op&cmd=<load><config><partial><mode>replace</mode><from>bangalore.xml</from><from-xpath>' + urllib.parse.quote_plus(
        "/config/devices/entry[@name=\"localhost.localdomain\"]/device-group/entry[@name=\"" + customops.devicegroup_name + "\"]/service-group") + '</from-xpath><to-xpath>' + urllib.parse.quote_plus(
        "/config/devices/entry[@name=\"localhost.localdomain\"]/device-group/entry[@name=\"" + customops.devicegroup_name + "\"]/service-group") + '</to-xpath></partial></config></load>\'')

    log('curl -u \'' + u + ':' + p + '\' -k \'https://' + h + '/api/?type=op&cmd=<load><config><partial><mode>replace</mode><from>bangalore.xml</from><from-xpath>' + urllib.parse.quote_plus(
        "/config/shared/log-settings") + '</from-xpath><to-xpath>' + urllib.parse.quote_plus(
        "/config/devices/entry[@name=\"localhost.localdomain\"]/template/entry[@name=\"" + customops.devicegroup_name + "\"]/config/shared/log-settings") + '</to-xpath></partial></config></load>\'')
    log('curl -u \'' + u + ':' + p + '\' -k \'https://' + h + '/api/?type=op&cmd=<load><config><partial><mode>replace</mode><from>bangalore.xml</from><from-xpath>' + urllib.parse.quote_plus(
        "/config/log-settings") + '</from-xpath><to-xpath>' + urllib.parse.quote_plus(
        "/config/devices/entry[@name=\"localhost.localdomain\"]/device-group/entry[@name=\"" + customops.devicegroup_name + "\"]/log-settings") + '</to-xpath></partial></config></load>\'')
    log('curl -u \'' + u + ':' + p + '\' -k \'https://' + h + '/api/?type=op&cmd=<load><config><partial><mode>replace</mode><from>bangalore.xml</from><from-xpath>' + urllib.parse.quote_plus(
        "/config/devices/entry[@name=\"localhost.localdomain\"]/device-group/entry[@name=\"" + customops.devicegroup_name + "\"]/profile-group") + '</from-xpath><to-xpath>' + urllib.parse.quote_plus(
        "/config/devices/entry[@name=\"localhost.localdomain\"]/device-group/entry[@name=\"" + customops.devicegroup_name + "\"]/profile-group") + '</to-xpath></partial></config></load>\'')
    log('curl -u \'' + u + ':' + p + '\' -k \'https://' + h + '/api/?type=op&cmd=<load><config><partial><mode>replace</mode><from>bangalore.xml</from><from-xpath>' + urllib.parse.quote_plus(
        "/config/devices/entry[@name=\"localhost.localdomain\"]/device-group/entry[@name=\"" + customops.devicegroup_name + "\"]/pre-rulebase") + '</from-xpath><to-xpath>' + urllib.parse.quote_plus(
        "/config/devices/entry[@name=\"localhost.localdomain\"]/device-group/entry[@name=\"" + customops.devicegroup_name + "\"]/pre-rulebase") + '</to-xpath></partial></config></load>\'')
    log('curl -u \'' + u + ':' + p + '\' -k \'https://' + h + '/api/?type=op&cmd=<load><config><partial><mode>replace</mode><from>bangalore.xml</from><from-xpath>' + urllib.parse.quote_plus(
        "/config/devices/entry[@name=\'localhost.localdomain\']/network") + '</from-xpath><to-xpath>' + urllib.parse.quote_plus(
        "/config/devices/entry[@name=\'localhost.localdomain\']/template/entry[@name=\'" + customops.devicegroup_name + "\']/config/devices/entry[@name=\'localhost.localdomain\']/network") + '</to-xpath></partial></config></load>\'')
    log('curl -u \'' + u + ':' + p + '\' -k \'https://' + h + '/api/?type=op&cmd=<load><config><partial><mode>replace</mode><from>bangalore.xml</from><from-xpath>' + urllib.parse.quote_plus(
        "/config/devices/entry[@name=\'localhost.localdomain\']/vsys/entry[@name=\'vsys1\']/import") + '</from-xpath><to-xpath>' + urllib.parse.quote_plus(
        "/config/devices/entry[@name=\'localhost.localdomain\']/template/entry[@name=\'" + customops.devicegroup_name + "\']/config/devices/entry[@name=\'localhost.localdomain\']/vsys/entry[@name=\'vsys1\']/import") + '</to-xpath></partial></config></load>\'')
    log('curl -u \'' + u + ':' + p + '\' -k \'https://' + h + '/api/?type=op&cmd=<load><config><partial><mode>replace</mode><from>bangalore.xml</from><from-xpath>' + urllib.parse.quote_plus(
        "/config/devices/entry[@name=\'localhost.localdomain\']/vsys/entry[@name=\'vsys1\']/zone") + '</from-xpath><to-xpath>' + urllib.parse.quote_plus(
        "/config/devices/entry[@name=\'localhost.localdomain\']/template/entry[@name=\'" + customops.devicegroup_name + "\']/config/devices/entry[@name=\'localhost.localdomain\']/vsys/entry[@name=\'vsys1\']/zone") + '</to-xpath></partial></config></load>\'')
    log('curl -u \'' + u + ':' + p + '\' -k \'https://' + h + '/api/?type=op&cmd=<load><config><partial><mode>replace</mode><from>bangalore.xml</from><from-xpath>' + urllib.parse.quote_plus(
        "/config/devices/entry[@name=\'localhost.localdomain\']/deviceconfig") + '</from-xpath><to-xpath>' + urllib.parse.quote_plus(
        "/config/devices/entry[@name=\"localhost.localdomain\"]/template/entry[@name=\"" + customops.devicegroup_name + "\"]/config/devices/entry[@name=\"localhost.localdomain\"]/deviceconfig") + '</to-xpath></partial></config></load>\'')
    # log ('curl -u \'' + u + ':' + p + '\' -k \'https://' + h + '/api/?type=op&cmd=<load><config><partial><mode>replace</mode><from>bangalore.xml</from><from-xpath>' + urllib.parse.quote_plus("") + '</from-xpath><to-xpath>' + urllib.parse.quote_plus("") + '</to-xpath></partial></config></load>\'')

    if options.web:
        log("</textarea>")

        log("<br><a href=\"/converted/outfile.xml\" download>Download Config</a>")
        log('''
<style>
.container {
  width: 500px;
  clear: both;
}

.container input {
  width: 100%;
  clear: both;
}

</style>

<div class="container">

<form action="/lab/cgi-bin/migrate.py" method="post" id="firewall">
    <input type="hidden" id="devicegroup" name="devicegroup" value="''' + customops.devicegroup_name + '''"> 
    <input type="hidden" id="pushfile" name="pushfile" value="../../converted/outfile.xml">
    <label>Panorama IP Address</label>
    <input id="puship" name="puship"/><br><br>
    <label>Username</label>
    <input id="pushusername" name="pushusername"/><br><br>
    <label>Password</label>
    <input id="pushpassword" type="password" name="pushpassword"/><br><br>
    <label>Device to add to template/device-group</label>
    <input id="devicestoadd" name="devicestoadd"/><br><br>
    <input type="checkbox" name="pushnotemplate" value="true" hidden> Do not create/push template
    
    <input type="hidden" name="push" value="true"/>''')
        if not options.userid:
            log('''<input type="hidden" name="skip-userid" checked value="true"/>''')

        # if not options.userid: log(' checked')
        # log(''' value="true"/>
        log('''
    <!-- <input type="checkbox" name="pan8" value="true" checked="checked"> Panorama 8.x</input><br><br> -->
    <input type="submit" name="Submit" value="Submit"  class="submit"/>

</form>
</div>

''')
        import sys

if options.dump_config:
    dump_config(config, contexts)
    if options.web:
        import shutil

        set_web_tab('Download')
        for context in contexts:
            shutil.move('/var/www/html/lab/cgi-bin/' + context + '.xlsx',
                        '/var/www/html/dumpconfig/' + context + '.xlsx')
            if context.lower() != 'shared':
                log('<a href="/dumpconfig/' + context + '.xlsx">Download ' + context + '</a>')

if options.tuplefile:
    log('!-- Creating tuples')
    log(options.tuplezone)
    create_tuples(config, options.tuplefile, options.tuplezone, contexts, options.policynames)

## push a sonicwall migrated config to panorama

if options.push:
    import requests
    import urllib.parse
    from requests.auth import HTTPDigestAuth
    import re

    if options.web:
        set_web_tab('push')

    urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
    pushsession = requests.Session()
    pushsession.mount(options.puship, DESAdapter())
    urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
    if options.outfile:
        log(options.outfile)
        options.pushfile = options.outfile

    command = 'https://' + options.puship + '/api/?type=op&cmd=<show><system><info></info></system></show>'
    response = pushsession.post(command, verify=False, headers={'authorization': "Basic " + base64.b64encode(
        '{}:{}'.format(options.username, options.password).encode()).decode()})
    swver = re.search(r"\<sw-version\>(.*)\</sw-version\>", response.text, flags=re.MULTILINE)
    # log(response.text)
    if swver != None:
        if swver.group(1)[0] in ['8', '9']:
            options.pan8 = True
            log('Panorama 8 or 9 detected')
        elif swver.group(1)[0] not in ['8', '9']:
            options.pan8 = False
            log('Panorama 7 detected')
    fileonly = options.pushfile.split('/')[-1]
    command = 'https://' + options.puship + '/api/?type=import&category=configuration'
    log(command)
    configfile = {'file': open(options.pushfile, 'rb')}
    response = pushsession.post(command, verify=False, files=configfile, headers={
        'authorization': "Basic " + base64.b64encode(
            '{}:{}'.format(options.username, options.password).encode()).decode()})
    # log (response.text)
    pushcommands = [('https://' + options.puship + '/api/?type=config&action=set&xpath=' + urllib.parse.quote_plus(
        "/config/devices/entry[@name='localhost.localdomain']/device-group") + "&element=<entry%20name=\"" + customops.devicegroup_name + '\"></entry>',
                     'Creating Device Group JEFF')]
    if not options.pushnotemplate:
        pushcommands.append((
                            'https://' + options.puship + '/api/?type=config&action=set&xpath=' + urllib.parse.quote_plus(
                                "/config/devices/entry[@name='localhost.localdomain']/template") + "&element=<entry%20name=\"" + customops.devicegroup_name + "\"></entry>",
                            'Creating Template'))

    if options.pan8 and not options.pushnotemplate:
        pushcommands.append((
                            'https://' + options.puship + '/api/?type=config&action=set&xpath=' + urllib.parse.quote_plus(
                                "/config/devices/entry[@name='localhost.localdomain']/template-stack") + "&element=<entry%20name=\"" + customops.devicegroup_name + "_Stack\"></entry>",
                            'Creating Template Stack'))
        ## ADD TEMPLATE TO TEMPLATE-STACK
    else:
        # pushcommands.append()
        pass

    for device in options.devicetoadd.split(','):
        pushcommands.append((
                            'https://' + options.puship + '/api/?type=config&action=set&xpath=' + '/config/mgt-config' + "&element=<devices><entry name=\'" + device + "\'/></devices>",
                            'Adding device "' + device + '" to Panorama'))
        pushcommands.append((
                            'https://' + options.puship + '/api/?type=config&action=set&xpath=' + urllib.parse.quote_plus(
                                "/config/devices/entry[@name='localhost.localdomain']/device-group/entry[@name=\"" + customops.devicegroup_name + "\"]") + "&element=<devices><entry name=\'" + device + "\'/></devices>",
                            'Adding device "' + device + '" to device-group'))
        if not options.pushnotemplate:
            if options.pan8:
                pushcommands.append((
                                    'https://' + options.puship + '/api/?type=config&action=set&xpath=' + urllib.parse.quote_plus(
                                        "/config/devices/entry[@name='localhost.localdomain']/template-stack/entry[@name=\"" + customops.devicegroup_name + "_Stack\"]") + "&element=<devices><entry name=\'" + device + "\'/></devices>",
                                    'Adding device "' + device + '" to template stack'))
            else:
                pushcommands.append((
                                    'https://' + options.puship + '/api/?type=config&action=set&xpath=' + urllib.parse.quote_plus(
                                        "/config/devices/entry[@name='localhost.localdomain']/template/entry[@name=\"" + customops.devicegroup_name + "\"]") + "&element=<devices><entry name=\'" + device + "\'/></devices>",
                                    'Adding device "' + device + '" to template'))
            pushcommands.append((
                'https://' + options.puship + '/api/?type=config&action=set&xpath=' + urllib.parse.quote_plus(
                    "/config/devices/entry[@name=\"localhost.localdomain\"]/template/entry[@name=\"" + customops.devicegroup_name + "\"]") + "&element=<settings/>",
                                'Setting vsys mode'))

    pushcommands.append((
                        'https://' + options.puship + '/api/?type=op&cmd=<load><config><partial><mode>replace</mode><from>' + fileonly + '</from><from-xpath>' + urllib.parse.quote_plus(
                            "/config/devices/entry[@name=\"localhost.localdomain\"]/device-group/entry[@name=\"" + customops.devicegroup_name + "\"]/address") + '</from-xpath><to-xpath>' + urllib.parse.quote_plus(
                            "/config/devices/entry[@name=\"localhost.localdomain\"]/device-group/entry[@name=\"" + customops.devicegroup_name + "\"]/address") + '</to-xpath></partial></config></load>',
                        'Importing Address objects'))
    pushcommands.append((
                        'https://' + options.puship + '/api/?type=op&cmd=<load><config><partial><mode>replace</mode><from>' + fileonly + '</from><from-xpath>' + urllib.parse.quote_plus(
                            "/config/devices/entry[@name=\"localhost.localdomain\"]/device-group/entry[@name=\"" + customops.devicegroup_name + "\"]/address-group") + '</from-xpath><to-xpath>' + urllib.parse.quote_plus(
                            "/config/devices/entry[@name=\"localhost.localdomain\"]/device-group/entry[@name=\"" + customops.devicegroup_name + "\"]/address-group") + '</to-xpath></partial></config></load>',
                        'Importing Address Group objects'))
    pushcommands.append((
                        'https://' + options.puship + '/api/?type=op&cmd=<load><config><partial><mode>replace</mode><from>' + fileonly + '</from><from-xpath>' + urllib.parse.quote_plus(
                            "/config/devices/entry[@name=\"localhost.localdomain\"]/device-group/entry[@name=\"" + customops.devicegroup_name + "\"]/service") + '</from-xpath><to-xpath>' + urllib.parse.quote_plus(
                            "/config/devices/entry[@name=\"localhost.localdomain\"]/device-group/entry[@name=\"" + customops.devicegroup_name + "\"]/service") + '</to-xpath></partial></config></load>',
                        'Importing Service objects'))
    pushcommands.append((
                        'https://' + options.puship + '/api/?type=op&cmd=<load><config><partial><mode>replace</mode><from>' + fileonly + '</from><from-xpath>' + urllib.parse.quote_plus(
                            "/config/devices/entry[@name=\"localhost.localdomain\"]/device-group/entry[@name=\"" + customops.devicegroup_name + "\"]/service-group") + '</from-xpath><to-xpath>' + urllib.parse.quote_plus(
                            "/config/devices/entry[@name=\"localhost.localdomain\"]/device-group/entry[@name=\"" + customops.devicegroup_name + "\"]/service-group") + '</to-xpath></partial></config></load>',
                        'Importing Service Group objects'))
    pushcommands.append((
                        'https://' + options.puship + '/api/?type=op&cmd=<load><config><partial><mode>replace</mode><from>' + fileonly + '</from><from-xpath>' + urllib.parse.quote_plus(
                            "/config/shared/log-settings") + '</from-xpath><to-xpath>' + urllib.parse.quote_plus(
                            "/config/devices/entry[@name=\"localhost.localdomain\"]/template/entry[@name=\"" + customops.devicegroup_name + "\"]/config/shared/log-settings") + '</to-xpath></partial></config></load>',
                        'Creating Template Log settings'))
    if options.pan8:
        pushcommands.append((
                            'https://' + options.puship + '/api/?type=op&cmd=<load><config><partial><mode>replace</mode><from>' + fileonly + '</from><from-xpath>' + urllib.parse.quote_plus(
                                "/config/pan8/log-settings") + '</from-xpath><to-xpath>' + urllib.parse.quote_plus(
                                "/config/devices/entry[@name=\"localhost.localdomain\"]/device-group/entry[@name=\"" + customops.devicegroup_name + "\"]/log-settings") + '</to-xpath></partial></config></load>',
                            'Creating Device-Group Log settings for Pan8'))
    else:
        pushcommands.append((
                            'https://' + options.puship + '/api/?type=op&cmd=<load><config><partial><mode>replace</mode><from>' + fileonly + '</from><from-xpath>' + urllib.parse.quote_plus(
                                "/config/pan7/log-settings") + '</from-xpath><to-xpath>' + urllib.parse.quote_plus(
                                "/config/devices/entry[@name=\"localhost.localdomain\"]/device-group/entry[@name=\"" + customops.devicegroup_name + "\"]/log-settings") + '</to-xpath></partial></config></load>',
                            'Creating Device-Group Log settings for Pan7'))
    pushcommands.append((
                        'https://' + options.puship + '/api/?type=op&cmd=<load><config><partial><mode>replace</mode><from>' + fileonly + '</from><from-xpath>' + urllib.parse.quote_plus(
                            "/config/devices/entry[@name=\"localhost.localdomain\"]/device-group/entry[@name=\"" + customops.devicegroup_name + "\"]/profile-group") + '</from-xpath><to-xpath>' + urllib.parse.quote_plus(
                            "/config/devices/entry[@name=\"localhost.localdomain\"]/device-group/entry[@name=\"" + customops.devicegroup_name + "\"]/profile-group") + '</to-xpath></partial></config></load>',
                        'Creating Security Profile Group'))
    pushcommands.append((
                        'https://' + options.puship + '/api/?type=op&cmd=<load><config><partial><mode>replace</mode><from>' + fileonly + '</from><from-xpath>' + urllib.parse.quote_plus(
                            "/config/devices/entry[@name=\"localhost.localdomain\"]/device-group/entry[@name=\"" + customops.devicegroup_name + "\"]/pre-rulebase") + '</from-xpath><to-xpath>' + urllib.parse.quote_plus(
                            "/config/devices/entry[@name=\"localhost.localdomain\"]/device-group/entry[@name=\"" + customops.devicegroup_name + "\"]/pre-rulebase") + '</to-xpath></partial></config></load>',
                        'Importing Pre-Rules (Security and NAT)'))
    # pushcommands.append(('https://' + options.puship + '/api/?type=op&cmd=<load><config><partial><mode>replace</mode><from>' + fileonly + '</from><from-xpath>' + urllib.parse.quote_plus("/config/devices/entry[@name=\"localhost.localdomain\"]/device-group/entry[@name=\"" + customops.devicegroup_name + "\"]/pre-rulebase") + '</from-xpath><to-xpath>' + urllib.parse.quote_plus("/config/devices/entry[@name=\"localhost.localdomain\"]/device-group/entry[@name=\"" + customops.devicegroup_name + "\"]/pre-rulebase") + '</to-xpath></partial></config></load>', 'Importing NAT Rules'))
    if not options.pushnotemplate:
        pushcommands.append((
                            'https://' + options.puship + '/api/?type=op&cmd=<load><config><partial><mode>replace</mode><from>' + fileonly + '</from><from-xpath>' + urllib.parse.quote_plus(
                                "/config/devices/entry[@name=\'localhost.localdomain\']/network") + '</from-xpath><to-xpath>' + urllib.parse.quote_plus(
                                "/config/devices/entry[@name=\'localhost.localdomain\']/template/entry[@name=\'" + customops.devicegroup_name + "\']/config/devices/entry[@name=\'localhost.localdomain\']/network") + '</to-xpath></partial></config></load>',
                            'Importing Network Configuration'))
        pushcommands.append((
                            'https://' + options.puship + '/api/?type=op&cmd=<load><config><partial><mode>replace</mode><from>' + fileonly + '</from><from-xpath>' + urllib.parse.quote_plus(
                                "/config/devices/entry[@name=\'localhost.localdomain\']/vsys/entry[@name=\'vsys1\']/import") + '</from-xpath><to-xpath>' + urllib.parse.quote_plus(
                                "/config/devices/entry[@name=\'localhost.localdomain\']/template/entry[@name=\'" + customops.devicegroup_name + "\']/config/devices/entry[@name=\'localhost.localdomain\']/vsys/entry[@name=\'vsys1\']/import") + '</to-xpath></partial></config></load>',
                            'Creating "imports" section'))
        if options.userid:
            pushcommands.append((
                                'https://' + options.puship + '/api/?type=op&cmd=<load><config><partial><mode>replace</mode><from>' + fileonly + '</from><from-xpath>' + urllib.parse.quote_plus(
                                    "/config/devices/entry[@name=\'localhost.localdomain\']/vsys/entry[@name=\'vsys1\']/user-id-agent") + '</from-xpath><to-xpath>' + urllib.parse.quote_plus(
                                    "/config/devices/entry[@name=\'localhost.localdomain\']/template/entry[@name=\'" + customops.devicegroup_name + "\']/config/devices/entry[@name=\'localhost.localdomain\']/vsys/entry[@name=\'vsys1\']/user-id-agent") + '</to-xpath></partial></config></load>',
                                'Creating User-ID Agent configuration'))
        pushcommands.append((
                            'https://' + options.puship + '/api/?type=op&cmd=<load><config><partial><mode>replace</mode><from>' + fileonly + '</from><from-xpath>' + urllib.parse.quote_plus(
                                "/config/devices/entry[@name=\'localhost.localdomain\']/vsys/entry[@name=\'vsys1\']/zone") + '</from-xpath><to-xpath>' + urllib.parse.quote_plus(
                                "/config/devices/entry[@name=\'localhost.localdomain\']/template/entry[@name=\'" + customops.devicegroup_name + "\']/config/devices/entry[@name=\'localhost.localdomain\']/vsys/entry[@name=\'vsys1\']/zone") + '</to-xpath></partial></config></load>',
                            'Importing Zones'))
        pushcommands.append((
                            'https://' + options.puship + '/api/?type=op&cmd=<load><config><partial><mode>replace</mode><from>' + fileonly + '</from><from-xpath>' + urllib.parse.quote_plus(
                                "/config/devices/entry[@name=\'localhost.localdomain\']/deviceconfig") + '</from-xpath><to-xpath>' + urllib.parse.quote_plus(
                                "/config/devices/entry[@name=\"localhost.localdomain\"]/template/entry[@name=\"" + customops.devicegroup_name + "\"]/config/devices/entry[@name=\"localhost.localdomain\"]/deviceconfig") + '</to-xpath></partial></config></load>',
                            'Importing Deviceconfig'))
        pushcommands.append((
            'https://' + options.puship + '/api/?type=config&action=set&xpath=' + urllib.parse.quote_plus(
                                "/config/devices/entry[@name=\"localhost.localdomain\"]/template/entry[@name=\"" + customops.devicegroup_name + "\"]/settings") + "&element=<default-vsys>vsys1</default-vsys>",
                            'Setting default vsys for template to vsys1'))
        if options.pan8:
            pushcommands.append((
                                'https://' + options.puship + '/api/?type=config&action=set&xpath=' + urllib.parse.quote_plus(
                                    "/config/devices/entry[@name=\"localhost.localdomain\"]/template-stack/entry[@name=\"" + customops.devicegroup_name + "_Stack\"]/templates") + "&element=<member>" + customops.devicegroup_name + "</member>",
                                'Assign template to template-stack'))
    '''<request cmd="set" obj="/config/devices/entry[@name='localhost.localdomain']/template/entry[@name='BGL4 Services Segmentation']/settings" cookie="3251106346790311"><default-vsys>vsys1</default-vsys></request>'''

    log('!-- Importing configuration to Panorama device: ' + options.puship)
    sys.stdout.flush()
    import re

    for command, desc in pushcommands:
        log(desc)
        sys.stdout.flush()
        response = pushsession.get(command, verify=False, headers={'authorization': "Basic " + base64.b64encode(
            '{}:{}'.format(options.username, options.password).encode()).decode()}, timeout=300)
        if len(re.findall('success', response.text)) == 0:
            log('', level=logging.ERROR)
            log("!-- Error pushing command : ", level=logging.ERROR)
            log(command, level=logging.ERROR)
            log(response.text, level=logging.ERROR)
            sys.stdout.flush()
            exit(1)
        else:
            log('--> Success!')
            sys.stdout.flush()
    log('!-- Importing completed')

if options.inversematch:
    import re
    import requests
    from urllib.parse import quote as url_quote, unquote as url_unquote

    '''
    if options.inversesingle:
        inverse_results={}
        for network in options.inversematch:
            log('!-- Performing Inverse Matching for single network : ' + network )
            inverse_results.update(inverse_match(network))
    else:        
    '''
    log('!-- Performing Inverse Matching networks : ' + str(options.inversematch))
    inverse_results = inverse_match(options.inversematch)

if options.cipload:

    import pickle

    log("!-- Loading ChangeIP matches")
    try:
        infile = open(options.cipload, 'rb')
        change_results = pickle.load(infile)
        infile.close()
    except:
        log('Error loading saved ChangeIP file - Exiting script')
        change_results = None

if options.cipmatch:
    import re
    import requests
    from urllib.parse import quote as url_quote, unquote as url_unquote

    log('!-- Performing ChangeIP Search')
    change_results = cip_match4(options.cipmatch)
    cip_report2(change_results, options.cipshowskipped)
    if options.cipsave:
        log("!-- Saving ChangeIP matches")
        if options.cipsave == '%TIMESTAMP%':
            options.cipsave = timestr + '.cipsave'
        import pickle

        outfile = open(options.cipsave, 'wb')
        result = (pickle.dump(change_results, outfile))
        outfile.close()
    cip_match_reviewout(change_results)

if options.cipsubmit:
    set_web_tab('submitchanges')
    if options.cipsubmit == '%TIMESTAMP%':
        tmpstr = timestr
    else:
        tmpstr = options.cipsubmit
    log('''NEXT STEPS:

    DO NOT CLOSE THIS WINDOW!!!  The Submit form below is needed to complete your work and is unique to this search.

    ------------------------
    Copy review data into Excel:
        Click on the "Review" tab. 
        Copy and paste the entire "textarea" box into a blank Excel spreadsheet.
        In Excel, select column A.
        On the menu bar, click on "Data" and then "Text to Columns"
        Selected Delimited. Click Next.
        Select _ONLY_ "Comma" for delimiter.  Click Finish

    Reviewing the data:
        Each line contains a proposal for a new address object to be created.
        The mID (matchID) can be used to find more details in the report.
        There are times when a new address object with a duplicate name will be proposed.
            These should be reviewed, in particular for their color and commments value.
        The only fields that should be changed are "color" "comment" "new_addr" and "skip".
        If needed, you should be able to reorder the rows by any column (NOT TESTED)
        If the first character of the skip field is set to "y" that match will not be processed.
            The new address object will not be created.
            The related group and policy matches are not modified.
        When you are done reviewing and making changes, save this as a CSV file.
    
    Submit your changes to get dbedit commands:

        Return to the ChangeIP tool. 
        Return to the Submit tab.
        Click "Choose File" next to Review File.
        Select the .CSV file you saved in the previous step
        Click Submit

    ''')
    log('</textarea><br>')

    log('''<form enctype="multipart/form-data" action="/lab/cgi-bin/migrate.py" method="post" id="changeip" target="_blank">
    
    <input type="checkbox" hidden name="debug" value="true" checked ><br>
    <input type="checkbox" hidden name="cipreview" value="true" checked ><br>
    <input hidden name="cipload" value="''' + tmpstr + '''.cipsave"><br>
    <input type="checkbox" hidden name="cipdbedit" value="true" checked ><br>
    <table><tr><td>Review File</td><td><input type="file" id="cipreviewin" name="cipreviewin"/><br></td></tr></table>
    <input type="submit" name="Submit" value="Submit"  class="submit"/>
    </form>''')

if options.cipreviewin:
    if options.web: set_web_tab('reviewin')
    change_results = cip_match_reviewin(options.cipreviewin, change_results)
    cip_report2(change_results, options.cipshowskipped)

if options.cipdbedit:
    if options.web: set_web_tab('commands')
    cip_match_dbedit(change_results)

if options.cipswedit:
    if options.web: set_web_tab('commands')
    cip_match_dbedit(change_results, options.sonicwallip, 'webui', showresults=True)

if options.inverseload:  # CHANGEME move inverse save and load to config save/load as config['context']['matches']
    import pickle

    log("!-- Loading inversematches")
    infile = open(options.inverseload, 'rb')
    inverse_results = pickle.load(infile)
    infile.close()

    ## generate list of contexts
    contexts = []
    if not options.context:
        for context in inverse_results:
            contexts.append(context)
    else:
        contexts = options.context

if options.inversematch or options.inverseload:

    if options.inversedisable and options.inversedelete:
        log('Can not perform inverse disable and delete in a single pass')
        exit(1)  ## change this to a return once this is made into a function
    inverse_cmds = OrderedDict()

    if options.inversedisable or options.inversedelete:
        inverse_cmds['rules'], stats = inverse_rule_cleanup(inverse_results)
        for context in contexts:
            if context in stats:
                inverse_results[context]['policy_cleanup_stats'] = stats[context]
            else:
                inverse_results[context]['policy_cleanup_stats'] = [None, None, None, None]

    if options.inverseaddressdelete:
        inverse_cmds['addresses'], stats = inverse_address_cleanup(inverse_results)
        for context in contexts:
            if context in stats:
                inverse_results[context]['address_cleanup_stats'] = stats[context]
            else:
                inverse_results[context]['address_cleanup_stats'] = [None, None, None]

    log('-' * 180)
    log('Effected Policies')
    log('-' * 180)
    for context in contexts:
        for ep in inverse_results[context]['effected_policies']:
            log(ep)
    log('-' * 180)
    if options.inverseexecute == '':
        if options.sonicwallip:
            options.inverseexecute = options.sonicwallip
        elif options.panoramaip:
            options.inverseexecute = options.panoramaip

    if options.web:
        set_web_tab('command')
        inverse_newexec(options.username, options.password, '', inverse_cmds, noexec=True)

## inverse_exec has been replaced with newexec, so the following function can most likely be removed - the method to exec has been completely redone.

if options.inverseexecute != None and options.inversematch:
    if options.web:
        set_web_tab('exec')
    inverse_newexec(options.username, options.password, options.inverseexecute, inverse_cmds)
elif options.inverseexecute == '' and options.inversematch:
    log('Target IP Address Needed')

    ## Find objects related to an address object

## --inversestats

if options.inversestats:  # work in progress as I am still determining what stats to collect

    if options.web: set_web_tab('stats')

    try:
        for context in contexts:
            log('-' * 180)
            log(context)
            log('-' * 180)
            log('Policy Stats    : {:10} {:10} {:10}'.format(*inverse_results[context]['policy_stats']))
            log('Address Stats   : {:10} {:10} {:10}'.format(*inverse_results[context]['addr_stats']))
            log('Policy Cleanup  : {:10} {:10} {:10} {:10}'.format(*inverse_results[context]['policy_cleanup_stats']))
            # log('Address Cleanup : {addresses:10} {policies:10} {groups:10}'.format(**inverse_results[context]['address_cleanup_stats']))
            # log('Policy Cleanup : {:10} {:10} {:10} {:10}'.format(*inverse_results[context]['policy_cleanup_stats']))

    except:
        pass

if options.readxls:
    shared_base = ''
    devgroup_base = ''

    log('')
    log('Reading XLS file')
    if not options.zonemaps:
        log('--zonemap option must be specified if using --readxls option')

    else:
        import pandas as pd

        import urllib
        import requests
        import re
        # import ipaddress
        from netaddr import IPSet, IPRange, IPNetwork, IPAddress

        df = pd.read_excel(options.readxls)
        pushcommands = []
        panoip = options.panoramaip
        log_profile = options.logprofile

        new_objects = OrderedDict()
        new_objects['services'] = OrderedDict()
        new_objects['addresses'] = OrderedDict()
        header_found = False
        rule_index = 0

        zone_map = {}

        for zonemap in options.zonemaps:
            zonemap = zonemap.replace(', ', ',').replace(' ,', ',')
            xls, fwzone, policytext = zonemap.split(',')
            zone_map[xls.lower()] = {}
            zone_map[xls.lower()]['fwzone'] = fwzone
            zone_map[xls.lower()]['policytext'] = policytext
            # debug(xls, fwzone, policytext) \
 \
        policynames = {}
        for context in contexts:
            policynames[context] = []
            for policy in config[context]['policies']:
                policynames[context].append(config[context]['policies'][policy]['policyName'])

        if options.readxls_shared:
            object_base = "/config/shared"
            config_dict = config['shared']
        else:
            object_base = "/config/devices/entry[@name='localhost.localdomain']/device-group/entry[@name='" + context + "']"
            config_dict = config[context]
        prerule_base = "/config/devices/entry[@name='localhost.localdomain']/device-group/entry[@name='" + context + "']"

        if options.web: set_web_tab('ReadXLS')
        sys.stdout.flush()
        for index, row in df.iterrows():
            src_zone = str(row[2]).rstrip().lstrip().lower()
            src_group = str(row[3]).rstrip().lstrip()
            src_groups = [x.rstrip().lstrip() for x in
                          str(row[3]).rstrip().lstrip().replace('\r', '').replace('\t', '').split('\n')]
            src_ips = [x.rstrip().lstrip() for x in
                       str(row[4]).rstrip().lstrip().replace('\r', '').replace('\t', '').split('\n')]
            src_dns = [x.rstrip().lstrip() for x in
                       str(row[6]).rstrip().lstrip().replace('\r', '').replace('\t', '').split('\n')]
            dst_zone = str(row[8]).rstrip().lstrip().lower()
            dst_group = str(row[9]).rstrip().lstrip()
            dst_groups = [x.rstrip().lstrip() for x in \
                          str(row[9]).rstrip().lstrip().replace('\r', '').replace('\t', '').split('\n')]
            dst_ips = [x.rstrip().lstrip() for x in \
                       str(row[10]).rstrip().lstrip().replace('\r', '').replace('\t', '').split('\n')]
            dst_dns = [x.rstrip().lstrip() for x in
                       str(row[12]).rstrip().lstrip().replace('\r', '').replace('\t', '').split('\n')]
            dst_ports = str(row[15]).rstrip().lstrip().replace(' ', '').replace('\n', ',').replace('\r', '').replace(
                '\t', '').split(',')

            if header_found == True:

                ## while the use of context is "safe" within the if statement below, I should likely ensure that the context is correct based on options.context

                ## create addresses before processing rules
                if src_zone.lower() == 'address':  ## also add support to expand group
                    log('Address group creation requested')
                    if len(src_groups) != 1:
                        log('Source Group column must contain only 1 name')
                    else:
                        if src_group.lower() in [x.lower() for x in
                                                 config[context]['addresses']] or src_group.lower() in [y.lower() for y
                                                                                                        in config[
                                                                                                            'shared'][
                                                                                                            'addresses']] or src_group.lower() in [
                            z.lower() for z in new_objects['addresses']]:
                            log('Address group already exists in config')
                        else:
                            log('Creating address group : ' + src_group)
                            rule_srcs = []
                            for index1, src_ip in enumerate(src_ips):
                                src_ip_found = False
                                for address in config[context]['addresses']:
                                    if config[context]['addresses'][address]['addrObjIp1'] == src_ip:
                                        log('Source IP found in device objects')
                                        src_ip_found = address
                                        break
                                if src_ip_found == False:
                                    for address in config['shared']['addresses']:
                                        if config['shared']['addresses'][address]['addrObjIp1'] == src_ip:
                                            log('Source IP found in shared objects')
                                            src_ip_found = address
                                if src_ip_found == False:
                                    for address in new_objects['addresses']:
                                        if new_objects['addresses'][address]['addrObjIp1'] == src_ip:
                                            log('Source IP found in newly added objects')
                                            src_ip_found = address
                                if src_ip_found == False:
                                    if src_ip in ['1']:  # ['','*','nan']:
                                        src_ip_found = 'any'
                                    else:
                                        try:
                                            tmp = IPAddress(src_ip)
                                            new_addr_obj = src_dns[index1] + '-' + src_ip  # 'H-'+src_ip
                                            index2 = 1
                                            while new_addr_obj in config_dict['addresses']:
                                                new_addr_obj = src_dns[index1] + '-' + src_ip + '_' + str(index2)
                                                index2 += 1
                                            # log(new_addr_obj)
                                            new_objects['addresses'][new_addr_obj] = {}
                                            new_objects['addresses'][new_addr_obj]['addrObjIp1'] = src_ip
                                            new_objects['addresses'][new_addr_obj]['addrObjIp2'] = '255.255.255.255'
                                            new_objects['addresses'][new_addr_obj]['addrObjId'] = new_addr_obj
                                            new_objects['addresses'][new_addr_obj]['addrObjIdDisp'] = new_addr_obj
                                            new_objects['addresses'][new_addr_obj][
                                                'addrObjComment'] = 'Created for VirtuStream Project'
                                            new_objects['addresses'][new_addr_obj]['addrObjType'] = '1'  # host
                                            new_objects['addresses'][new_addr_obj]['addrObjZone'] = ''  # placeholder
                                            new_objects['addresses'][new_addr_obj][
                                                'addrObjProperties'] = ''  # placeholder
                                            if options.pushobjects: \
                                                ## add address object
                                                pushcommands.append((
                                                                    'https://' + panoip + '/api/?type=config&action=set&xpath=' + urllib.parse.quote_plus(
                                                                        object_base + "/address/entry[@name='" + new_addr_obj + "']") + '&element=<ip-netmask>' + src_ip + '/' + str(
                                                                        netmask_to_cidr(
                                                                            '255.255.255.255')) + '</ip-netmask><description>Created for VirtuStream Project - PROPEL</description>',
                                                                    'Adding address ' + new_addr_obj))
                                                pushcommands2.append(('create_address',
                                                                      {'addressname': new_addr_obj, 'ip1': src_ip,
                                                                       'ip2': '255.255.255.255', 'addresstype': '1',
                                                                       'zone': None, 'color': 'black', \
                                                                       'comment': 'Created for VirtuStream Project - PROPEL'}))
                                            src_ip_found = new_addr_obj
                                            log('Creating new source address object: ' + new_addr_obj)
                                        except Exception as e:
                                            ## not a valid ip address
                                            log(e)
                                            log('Invalid IP address : ' + src_ip)
                                if src_ip_found: \
                                    rule_srcs.append(src_ip_found)
                            new_objects['addresses'][src_group] = {}
                            new_objects['addresses'][src_group]['addrObjType'] = '8'
                            new_objects['addresses'][src_group]['addrObjComment'] = 'Created for VirtuStream Project'
                            new_objects['addresses'][src_group]['addrObjIdDisp'] = src_group
                            new_objects['addresses'][src_group]['addrObjIp1'] = src_ip
                            new_objects['addresses'][src_group]['addrObjIp2'] = '255.255.255.255'
                            new_objects['addresses'][src_group]['addrObjType'] = '1'  # host
                            new_objects['addresses'][src_group]['addrObjZone'] = ''  # placeholder
                            new_objects['addresses'][src_group]['addrObjProperties'] = ''  # placeholder
                            if options.pushobjects:
                                ## add address group
                                pushcommands.append((
                                                    'https://' + panoip + '/api/?type=config&action=set&xpath=' + urllib.parse.quote_plus(
                                                        object_base + "/address-group/entry[@name='" + src_group + "']") + '&element=<static></static>',
                                                    'Adding group ' + src_group))
                            ## Add group members to group
                            for src in rule_srcs:
                                log('Adding member to group : ' + src_group + ' : ' + src)
                                if options.pushobjects:
                                    ## add address group members
                                    pushcommands.append((
                                                        'https://' + panoip + '/api/?type=config&action=set&xpath=' + urllib.parse.quote_plus(
                                                            object_base + "/address-group/entry[@name='" + src_group + "']/static") + '&element=<member>' + src + '</member>',
                                                        'Adding group member : ' + src))
                            rule_srcs = [src_group]

                elif src_zone.lower() not in [y.lower() for y in zone_map] or dst_zone.lower() not in [x.lower() for x
                                                                                                       in zone_map]:
                    log('Source or Destination zone not found in map - SKIPPING row ' + str(index))
                    # else:
                    # == len(src_dns.split('\n')))
                elif len(src_dns) != len(src_ips):
                    log('Number of Source IPs does not match numer of source DNS names given - SKIPPING ROW ' + str(
                        index))
                elif len(dst_ips) != len(dst_dns): \
                    log('Number of Source IPs does not match numer of source DNS names given - SKIPPING ROW ' + str(
                        index)) \
                    # print(index, dst_ports)
                    # print('"index:{:5.5s}" "s_group:{:20.20s}" "s_dns{:20.20s}" "s_ips{:20.20s}" "dst_grp:{:20.20s}" "dst_dns:{:20.20s}" "dst_ips:{:20.20s}" "dst_svc:{:20.20s}"'.format(str(index), src_group, src_dns[0], src_ips[0], dst_group, dst_dns[0], dst_ips[0], dst_ports[0]))
                else: \
 \
                    for context in contexts:
                        # log(config[context]['zones'])
                        rule_dsts = []
                        rule_srcs = []
                        rule_svcs = []
                        if len(src_groups) > 1:
                            log('Source group contains more than 1 member')
                            tmp_group = []
                            for src_grp in src_groups:
                                if src_grp.lower() in [x.lower() for x in
                                                       config[context]['addresses']] or src_grp.lower() in [y.lower()
                                                                                                            for y in
                                                                                                            config[
                                                                                                                                                                      'shared'][
                                                                                                                'addresses']] or src_grp.lower() in [
                                    z.lower() for z in new_objects['addresses']]:
                                    log('Source {} found in current config'.format(src_grp))
                                    rule_srcs.append(src_grp)
                                else:
                                    log('ERROR - Source group {} not found in current config'.format(src_grp))

                        elif src_group.lower() in [x.lower() for x in config[context][
                            'addresses']] or src_group == 'any' or src_group.lower() in [y.lower() for y in \
                                                                                         config['shared'][
                                                                                             'addresses']] or src_group.lower() in [
                            z.lower() for z in new_objects['addresses']]:
                            ## Use existing group
                            log('Source group found')
                            if src_group.lower() in [x.lower() for x in
                                                     config[context]['addresses']] and src_group not in config[context][
                                'addresses']:
                                for x in config[context]['addresses']:
                                    if src_group.lower() == x.lower():
                                        src_group = x
                                        break
                            if src_group.lower() in [x.lower() for x in
                                                     config['shared']['addresses']] and src_group not in \
                                    config['shared']['addresses']:
                                for x in config['shared']['addresses']:
                                    if src_group.lower() == x.lower():
                                        src_group = x
                                        break \
                            rule_srcs.append(src_group)
                        else:
                            ## first check should be to see if by any chance there is an existing group that matches the given IP list exactly and use that (may not do this as the group was not explicitly requested and future changes to that group would effect this rule, perhaps unintentionally)
                            ## build a list of address objects to either a) include in a new group or b) use directly in the rule
                            log('Source group NOT found')

                            for index1, src_ip in enumerate(src_ips):
                                src_ip_found = False
                                for address in config[context]['addresses']:
                                    if config[context]['addresses'][address]['addrObjIp1'] == src_ip:
                                        log('Source IP found in device objects')
                                        src_ip_found = address
                                        break
                                if src_ip_found == False:
                                    for address in config['shared']['addresses']:
                                        if config['shared']['addresses'][address]['addrObjIp1'] == src_ip:
                                            log('Source IP found in shared objects')
                                            src_ip_found = address
                                if src_ip_found == False:
                                    for address in new_objects['addresses']:
                                        if new_objects['addresses'][address]['addrObjIp1'] == src_ip:
                                            log('Source IP found in newly added objects')
                                            src_ip_found = address
                                if src_ip_found == False:
                                    if src_ip in ['1']:  # ['','*','nan']:
                                        src_ip_found = 'any'
                                    else:
                                        try:
                                            tmp = IPAddress(src_ip)
                                            new_addr_obj = src_dns[index1] + '-' + src_ip  # 'H-'+src_ip
                                            index2 = 1
                                            while new_addr_obj in config_dict['addresses']:
                                                new_addr_obj = src_dns[index1] + '-' + src_ip + '_' + str(index2)
                                                index2 += 1
                                            # log(new_addr_obj)
                                            new_objects['addresses'][new_addr_obj] = {}
                                            new_objects['addresses'][new_addr_obj]['addrObjIp1'] = src_ip
                                            new_objects['addresses'][new_addr_obj]['addrObjIp2'] = '255.255.255.255'
                                            new_objects['addresses'][new_addr_obj]['addrObjId'] = new_addr_obj
                                            new_objects['addresses'][new_addr_obj]['addrObjIdDisp'] = new_addr_obj
                                            new_objects['addresses'][new_addr_obj][
                                                'addrObjComment'] = 'Created for VirtuStream Project'
                                            new_objects['addresses'][new_addr_obj]['addrObjType'] = '1'  # host
                                            new_objects['addresses'][new_addr_obj]['addrObjZone'] = ''  # placeholder
                                            new_objects['addresses'][new_addr_obj][
                                                'addrObjProperties'] = ''  # placeholder
                                            if options.pushobjects:
                                                ## add address
                                                pushcommands.append((
                                                                    'https://' + panoip + '/api/?type=config&action=set&xpath=' + urllib.parse.quote_plus(
                                                                        object_base + "/address/entry[@name='" + new_addr_obj + "']") + '&element=<ip-netmask>' + src_ip + '/' + str(
                                                                        netmask_to_cidr(
                                                                            '255.255.255.255')) + '</ip-netmask><description>Created for VirtuStream Project - PROPEL</description>',
                                                                    'Adding address ' + new_addr_obj))
                                                pushcommands2.append(('create_address',
                                                                      {'addressname': new_addr_obj, 'ip1': src_ip,
                                                                       'ip2': '255.255.255.255', 'addresstype': '1',
                                                                       'zone': src_zone, 'color': 'black',
                                                                       'comment': 'Created for VirtuStream Project - PROPEL'}))
                                            src_ip_found = new_addr_obj
                                            log('Creating new source address object: ' + new_addr_obj)
                                        except Exception as e:
                                            ## not a valid ip address
                                            log(e)
                                            log('Invalid IP address : ' + src_ip)
                                if src_ip_found:
                                    rule_srcs.append(src_ip_found)
                                # Create New Group
                            if src_group.lower() not in ['*', '', 'nan'] and len(
                                    re.findall('n/a', src_group, flags=re.IGNORECASE)) == 0:
                                ## create new group with members
                                log('Creating new source group : ' + src_group)
                                new_objects['addresses'][src_group] = {}
                                new_objects['addresses'][src_group]['addrObjType'] = '8'
                                new_objects['addresses'][src_group][
                                    'addrObjComment'] = 'Created for VirtuStream Project'
                                new_objects['addresses'][src_group]['addrObjIdDisp'] = src_group
                                new_objects['addresses'][src_group]['addrObjIp1'] = src_ip
                                new_objects['addresses'][src_group]['addrObjIp2'] = '255.255.255.255'
                                new_objects['addresses'][src_group]['addrObjType'] = '1'  # host
                                new_objects['addresses'][src_group]['addrObjZone'] = ''  # placeholder
                                new_objects['addresses'][src_group]['addrObjProperties'] = ''  # placeholder
                                if options.pushobjects: \
                                    ## add address group
                                    pushcommands.append((
                                                        'https://' + panoip + '/api/?type=config&action=set&xpath=' + urllib.parse.quote_plus(
                                                            object_base + "/address-group/entry[@name='" + src_group + "']") + '&element=<static></static>',
                                                        'Adding group ' + src_group))
                                ## Add group members to group
                                member_list = []
                                for src in rule_srcs:
                                    log('Adding member to group : ' + src_group + ' : ' + src)
                                    memberlist.append(src)
                                    if options.pushobjects:
                                        ## add address group members
                                        pushcommands.append((
                                                            'https://' + panoip + '/api/?type=config&action=set&xpath=' + urllib.parse.quote_plus(
                                                                object_base + "/address-group/entry[@name='" + src_group + "']/static") + '&element=<member>' + src + '</member>',
                                                            'Adding group member : ' + src))
                                if options.pushobjects:
                                    pushcommands2.append(('create_address',
                                                          {'addressname': src_group, 'addresstype': '8', 'zone': None,
                                                           'color': 'black', 'members': member_list,
                                                           'comment': 'Created via ReadXLS Script'}))
                                rule_srcs = [src_group]
                            else: \
                                log('Using Src IP objects directly in rule')
                            ## Use Src IPs in rule
                            pass
                        if len(dst_groups) > 1:
                            log('Destination group contains more than 1 member')
                            tmp_group = []
                            for dst_grp in dst_groups:
                                if dst_grp.lower() in [x.lower() for x in
                                                       config[context]['addresses']] or dst_grp.lower() in [y.lower()
                                                                                                            for y in
                                                                                                            config[
                                                                                                                'shared'][
                                                                                                                'addresses']] or dst_grp.lower() in [
                                    z.lower() for z in new_objects['addresses']]:
                                    log('Destination {} found in current config'.format(dst_grp))
                                    rule_dsts.append(dst_grp)
                                else:
                                    log('ERROR - Destination group {} not found in current config'.format(dst_grp))
                        if dst_group.lower() in [x.lower() for x in config[context][
                            'addresses']] or dst_group == 'any' or dst_group.lower() in [y.lower() for y in
                                                                                         config['shared'][
                                                                                             'addresses']] or dst_group.lower() in [
                            z.lower() for z in new_objects['addresses']]:
                            ## Use existing group
                            log('Destination group found')
                            if dst_group.lower() in [x.lower() for x in
                                                     config[context]['addresses']] and dst_group not in config[context][
                                'addresses']:
                                for x in config[context]['addresses']:
                                    if dst_group.lower() == x.lower():
                                        dst_group = x
                                        break
                            if dst_group.lower() in [x.lower() for x in
                                                     config['shared']['addresses']] and dst_group not in \
                                    config['shared']['addresses']:
                                for x in config['shared']['addresses']:
                                    if dst_group.lower() == x.lower():
                                        dst_group = x
                                        break \
                            rule_dsts.append(dst_group)
                        else:
                            log('Dest group NOT found')
                            for index1, dst_ip in enumerate(dst_ips):
                                dst_ip_found = False
                                for address in config[context]['addresses']:
                                    if config[context]['addresses'][address]['addrObjIp1'] == dst_ip:
                                        dst_ip_found = address
                                        log('Dest IP found in device address objects')
                                        break
                                if dst_ip_found == False:
                                    for address in config['shared']['addresses']:
                                        if config['shared']['addresses'][address]['addrObjIp1'] == dst_ip:
                                            dst_ip_found = address
                                            log('Dest IP found in shared objects')
                                if dst_ip_found == False:
                                    for address in new_objects['addresses']:
                                        if new_objects['addresses'][address]['addrObjIp1'] == dst_ip:
                                            dst_ip_found = address
                                            log('Dest IP found in newly added objects')
                                if dst_ip_found == False:
                                    if dst_ip in []:  # ['','*','nan']:
                                        dst_ip_found = 'any'
                                    else:
                                        try:
                                            tmp = IPAddress(dst_ip)
                                            new_addr_obj = dst_dns[index1] + '-' + dst_ip  # 'H-'+src_ip
                                            index2 = 1
                                            while new_addr_obj in config_dict['addresses']:
                                                new_addr_obj = dst_dns[index1] + '-' + dst_ip + '_' + str(index2)
                                                index2 += 1
                                            # log(new_addr_obj)
                                            new_objects['addresses'][new_addr_obj] = {}
                                            new_objects['addresses'][new_addr_obj]['addrObjIp1'] = dst_ip
                                            new_objects['addresses'][new_addr_obj]['addrObjIp2'] = '255.255.255.255'
                                            new_objects['addresses'][new_addr_obj]['addrObjId'] = new_addr_obj
                                            new_objects['addresses'][new_addr_obj]['addrObjIdDisp'] = new_addr_obj
                                            new_objects['addresses'][new_addr_obj][
                                                'addrObjComment'] = 'Created for VirtuStream Project'
                                            new_objects['addresses'][new_addr_obj]['addrObjType'] = '1'  # host
                                            new_objects['addresses'][new_addr_obj]['addrObjZone'] = ''  # placeholder
                                            new_objects['addresses'][new_addr_obj][
                                                'addrObjProperties'] = ''  # placeholder
                                            if options.pushobjects: \
                                                ## add address
                                                pushcommands.append((
                                                                    'https://' + panoip + '/api/?type=config&action=set&xpath=' + urllib.parse.quote_plus(
                                                                        object_base + "/address/entry[@name='" + new_addr_obj + "']") + '&element=<ip-netmask>' + dst_ip + '/' + str(
                                                                        netmask_to_cidr(
                                                                            '255.255.255.255')) + '</ip-netmask><description>Created for VirtuStream Project - PROPEL</description>',
                                                                    'Adding address ' + new_addr_obj))
                                                pushcommands2.append(('create_address',
                                                                      {'addressname': new_addr_obj, 'ip1': dst_ip,
                                                                       'ip2': '255.255.255.255', 'addresstype': '1',
                                                                       'zone': dst_zone, 'color': 'black',
                                                                       'comment': 'Created for VirtuStream Project - PROPEL'}))
                                            dst_ip_found = new_addr_obj
                                            log('Creating new address object : ' + new_addr_obj)
                                        except Exception as e:
                                            log(e)
                                            log('Invalid dest IP : ' + dst_ip)
                                if dst_ip_found:
                                    rule_dsts.append(dst_ip_found)
                                else:
                                    ## Use Dst IPs in rule
                                    log('Using Dst IP objects directly in rule')
                                    pass
                            # Create New Group
                            if dst_group.lower() not in ['*', '', 'nan'] and len(
                                    re.findall('n/a', src_group, flags=re.IGNORECASE)) == 0:
                                ## create new group with members
                                log('Creating new dest group : ' + dst_group)
                                if options.pushobjects: \
                                    ## add address group
                                    pushcommands.append((
                                                        'https://' + panoip + '/api/?type=config&action=set&xpath=' + urllib.parse.quote_plus(
                                                            object_base + "/address-group/entry[@name='" + dst_group + "']") + '&element=<static></static>',
                                                        'Adding group ' + dst_group))
                                member_list = []
                                for dst in rule_dsts:
                                    log('Adding member to group : ' + dst_group + ' : ' + dst)
                                    if options.pushobjects: \
                                        ## add address group members
                                        pushcommands.append((
                                                            'https://' + panoip + '/api/?type=config&action=set&xpath=' + urllib.parse.quote_plus(
                                                                object_base + "/address-group/entry[@name='" + dst_group + "']/static") + '&element=<member>' + dst + '</member>',
                                                            'Adding group member' + dst))
                                        member_list.append(dst)
                                if options.pushobjects:
                                    pushcommands2.append(('create_address',
                                                          {'addressname': dst_group, 'addresstype': '8', 'zone': None,
                                                           'color': 'black', 'members': member_list,
                                                           'comment': 'Created via ReadXLS Script'}))

                                rule_dsts = [dst_group]

            for port in dst_ports:
                if port != '':
                    ports = port.split('-')
                                if len(ports) > 2:
                                    # print('Bad ports format for :' + port)
                                    exit(1)
                                dst_port_found = False
                                for service in config[context]['services']:
                                    if config[context]['services'][service]['svcObjIpType'] == '6':
                                        if config[context]['services'][service]['svcObjType'] == '1':
                                            if len(ports) == 1:
                                                if config[context]['services'][service]['svcObjPort1'] == ports[0] and \
                                                        config[context]['services'][service]['svcObjPort2'] == ports[0]:
                                                    # print('service port found in context: ' + service)
                                                    dst_port_found = service
                                            elif len(ports) == 2:
                                                if config[context]['services'][service]['svcObjPort1'] == ports[0] and \
                                                        config[context]['services'][service]['svcObjPort2'] == ports[1]:
                                                    # print('service range found in context: ' + service)
                                                    dst_port_found = service
                                        ## svcPortSet FIX
                                if dst_port_found == False:
                                    for service in config['shared']['services']:
                                        if config['shared']['services'][service]['svcObjIpType'] == '6':
                                            if config['shared']['services'][service]['svcObjType'] == '1':
                                                if len(ports) == 1:
                                                    if config['shared']['services'][service]['svcObjPort1'] == ports[
                                                        0] and config['shared']['services'][service]['svcObjPort2'] == \
                                                            ports[0]:
                                                        # print('service port found in shared: ' + service)
                                                        dst_port_found = service
                                                elif len(ports) == 2:
                                                    if config['shared']['services'][service]['svcObjPort1'] == ports[
                                                        0] and config['shared']['services'][service]['svcObjPort2'] == \
                                                            ports[1]:
                                                        # print('service range found in shared: ' + service)
                                                        dst_port_found = service
                                            ## svcPortSet FIX
                                if dst_port_found == False:
                                    for service in new_objects['services']:
                                        if new_objects['services'][service]['svcObjIpType'] == '6':
                                            if new_objects['services'][service]['svcObjType'] == '1':
                                                if len(ports) == 1:
                                                    if new_objects['services'][service]['svcObjPort1'] == ports[0] and \
                                                            new_objects['services'][service]['svcObjPort2'] == ports[0]:
                                                        # print('service port found in new_obj: ' + service)
                                                        dst_port_found = service
                                                elif len(ports) == 2:
                                                    if new_objects['services'][service]['svcObjPort1'] == ports[0] and \
                                                            new_objects['services'][service]['svcObjPort2'] == ports[1]:
                                                        # print('service range found in new_obj: ' + service)
                                                        dst_port_found = service
                                            ## svcPortSet FIX
                    if dst_port_found == False:
                        # debug(str(ports))
                        if len(ports) == 1:
                                        new_port_obj = 'TCP_' + ports[0]
                                        index2 = 1
                                        while new_port_obj in config_dict['services']:
                                            new_port_obj = 'TCP_' + ports[0] + "_" + str(index2)
                                            index2 += 1
                                        new_objects['services'][new_port_obj] = {}
                                        new_objects['services'][new_port_obj]['svcObjPort1'] = ports[0]
                                        new_objects['services'][new_port_obj]['svcObjPort2'] = ports[0]
                                    elif len(ports) == 2:
                                        new_port_obj = 'TCP_' + ports[0] + '-' + ports[1]
                                        index2 = 1
                                        while new_port_obj in config_dict['services']:
                                            new_port_obj = 'TCP_' + ports[0] + '-' + ports[1] + "_" + str(index2)
                                            index2 += 1
                                        new_objects['services'][new_port_obj] = {}
                                        new_objects['services'][new_port_obj]['svcObjPort1'] = ports[0]
                                        new_objects['services'][new_port_obj]['svcObjPort2'] = ports[1]
                        # print('Port object not found, creating : ' + new_port_obj)

                                    new_objects['services'][new_port_obj]['svcObjType'] = '1'
                                    new_objects['services'][new_port_obj]['svcObjIpType'] = '6'
                                    new_objects['services'][new_port_obj]['svcObjId'] = new_port_obj
                                    new_objects['services'][new_port_obj][
                                        'svcObjComment'] = 'Created for VirtuStream Project'
                                    dst_port_found = new_port_obj
                                    if len(ports) == 1:
                                        if options.pushobjects:
                                            ## add service
                                            pushcommands.append((
                                                                'https://' + panoip + '/api/?type=config&action=set&xpath=' + urllib.parse.quote_plus(
                                                                    object_base + "/service/entry[@name='" + new_port_obj + "']") + '&element=<protocol><tcp><port>' +
                                                                new_objects['services'][new_port_obj][
                                                                    'svcObjPort1'] + '</port></tcp></protocol>',
                                                                'Adding service ' + new_port_obj))
                                            pushcommands2.append(('create_service', {'servicename': new_port_obj,
                                                                                     'port1': new_objects['services'][
                                                                                         new_port_obj]['svcObjPort1'],
                                                                                     'servicetype': '1',
                                                                                     'color': 'black',
                                                                                     'comment': 'Created for VirtuStream Project - PROPEL'}))
                                    elif len(ports) == 2:
                                        if options.pushobjects:
                                            ## add service range
                                            pushcommands.append((
                                                'https://' + panoip + '/api/?type=config&action=set&xpath=' + urllib.parse.quote_plus(
                                                    object_base + "/service/entry[@name='" + new_port_obj + "']") + '&element=<protocol><tcp><port>' +
                                                new_objects['services'][new_port_obj][
                                                    'svcObjPort1'] + '-' +
                                                new_objects['services'][new_port_obj][
                                                    'svcObjPort2'] + '</port></tcp></protocol>',
                                                                'Adding service ' + new_port_obj))
                                            pushcommands2.append(('create_service', {'servicename': new_port_obj,
                                                                                     'port1': new_objects['services'][
                                                                                         new_port_obj]['svcObjPort1'],
                                                                                     'port2': new_objects['services'][
                                                                                         new_port_obj]['svcObjPort2'],
                                                                                     'servicetype': '1',
                                                                                     'color': 'black',
                                                                                     'comment': 'Created for VirtuStream Project - PROPEL'}))
                                rule_svcs.append(dst_port_found)
                        # print('New Rule : ' + str(rule_srcs) + ' : ' + str(rule_dsts) + ': ' + str(rule_svcs))
                        # print('-' * 120)
                        if len(rule_srcs) > 0 and len(rule_dsts) > 0 and len(rule_svcs) > 0:
                            rule_index = 1
                            rule_base = zone_map[src_zone]['policytext'] + '-to-' + zone_map[dst_zone][
                                'policytext'] + '-'
                            while rule_base.lower() + str(rule_index) in [x.lower() for x in policynames[context]]:
                                rule_index += 1
                            policynames[context].append(rule_base + str(rule_index))
                            log(' New Rule  : ' + rule_base + str(rule_index))
                            log('  Sources  : ' + str(rule_srcs))
                            log('Src Groups : ' + str(src_groups))
                            log('    Dests  : ' + str(rule_dsts))
                            log('Dst Groups : ' + str(dst_groups))
                            log(' Services  : ' + str(rule_svcs))
                            log('-' * 120)
                            # apistring = 'https://' + firewallip + '/api/?key=apikey&type=config&action=set&key=keyvalue&xpath=xpath-value&element='
                            apistring = '<source>'
                            # if rule_srcs==[src_group]:
                            # apistring+= = '<member>' + src_group + '</member>'
                            # else:
                            for source in rule_srcs:
                                if source:
                                    apistring += '<member>' + source + '</member>'
                            apistring += '</source><destination>'
                            for dest in rule_dsts:
                                if dest:
                                    apistring += '<member>' + dest + '</member>'
                            apistring += '</destination>'
                            # apistring += '<destination><member>' + dst_group + '</member></destination>'
                            apistring += '<service>'
                            for svc in rule_svcs:
                                apistring += '<member>' + svc + '</member>'
                            apistring += '</service>'
                            apistring += '<application><member>any</member></application>'
                            apistring += '<action>allow</action>'
                            apistring += '<source-user><member>any</member></source-user>'
                            # apistring += '<option><disable-server-response-inspection>yes-or-no</disable-server-response-inspection></option>'
                            # apistring += '<negate-source>yes-or-no</negate-source>'
                            # apistring += '<negate-destination>yes-or-no</negate-destination>'
                            apistring += '<disabled>yes</disabled>' \
                            apistring += '<log-start>no</log-start>'
                            apistring += '<log-end>yes</log-end>'
                            apistring += '<log-setting>' + log_profile + '</log-setting>'
                            apistring += '<profile-setting><group><member>' + options.securityprofile + '</member></group></profile-setting>'
                            apistring += '<tag><member>' + options.ruletag + '</member></tag>' \
 \
                            apistring += '<description>Auto-Generated rule for VirtuStream</description>' \
                            apistring += '<from><member>' + zone_map[src_zone]['fwzone'] + '</member></from>'
                            apistring += '<to><member>' + zone_map[dst_zone]['fwzone'] + '</member></to>'
                            # print(apistring)
                            if options.pushrules:
                                ## add rule
                                pushcommands.append((
                                                    'https://' + panoip + '/api/?type=config&action=set&xpath=' + urllib.parse.quote_plus(
                                                        prerule_base + "/pre-rulebase/security/rules/entry[@name='" + rule_base + str(
                                                            rule_index) + "']") + "&element=" + apistring,
                                                    'Adding rule ' + rule_base + str(rule_index)))
                                pushcommands2.append(('create_address', {'addressname': foundaddr['new_addr'],
                                                                         'ip1': str(foundaddr['new_ip1']),
                                                                         'ip2': str(foundaddr['new_ip2']),
                                                                         'addresstype': foundaddr['type'],
                                                                         'zone': foundaddr['zone'], 'color': dbcolor,
                                                                         'comment': foundaddr['comment']}))
                            rule_index += 1
                        else:
                            log('Source, Destination or Services not set - SKIPPING row : ' + str(index))
            if src_group == 'Source Group':
                header_found = True

        if not options.web:
            options.pushusername, options.pushpassword = get_creds()
        else:
            options.pushusername = options.username
            options.pushpassword = options.password

        pushsession = requests.Session()
        pushsession.mount(panoip, DESAdapter())
        urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

        if options.pushobjects or options.pushrules:
            set_web_tab('exec')
            for command, desc in pushcommands:
                log(desc)
                sys.stdout.flush()
                response = pushsession.get(command, verify=False, headers={'authorization': "Basic " + base64.b64encode(
                    '{}:{}'.format(options.username, options.password).encode()).decode()})
                if len(re.findall('success', response.text)) == 0:
                    log('', level=logging.ERROR)
                    log("!-- Error pushing command : ", level=logging.ERROR)
                    log(command, level=logging.ERROR)
                    log(response.text, level=logging.ERROR)
                    sys.stdout.flush()
                    exit(1)
                else:
                    pass
                    # log('--> Success!')
                # exec_fw_command('10.215.16.60', change[context]['fw_type'], [ pushcommands ],syntax='webui'))
        else:
            log('Command execution not enabled')

    ## create groups that dont currently exist - and then use that in new rules

    ## limitations :    currently only works with hosts for address objects (need to add split '/' to handle masks)
    ##                  all services are treated as TCP - to change this, the input format will need to change

    '''    if type(df.at[row,col])==str:
        if ',' in df.at[row,col]:
            for index,celldata in enumerate(df.at[row,col].split(',')):
            print (index, celldata)
        elif '\n' in df.at[row,col]:
            for index,celldata in enumerate(df.at[row,col].split('\n')):
            print (index, celldata)
        else: print (df.at[row,col])
    '''

if options.nick:

    import xml.etree.ElementTree as et
    import urllib
    #    import ipaddress
    #    from collections import OrderedDict
    #    import ipaddress
    import re

    #    from netaddr import IPSet

    panorama = et.parse(options.nick)
    root = panorama.getroot()

    for context in options.context:
        log('!-- Modifying Device-Group : ' + context)

        logprofiles = []
        for logs in root.findall(
                './devices/entry/device-group/entry[@name=\'' + context + '\']/log-settings/profiles/entry'):
            logprofiles.append(logs.get('name'))
        log('-' * 100)
        log('Available Log Profiles')
        log('-' * 100)
        for logprofile in logprofiles:
            log(logprofile)

        log('-' * 100)
        log('Policies')
        log('-' * 100)
        policy_list = root.findall(
            './devices/entry/device-group/entry[@name=\'' + context + '\']/pre-rulebase/security/rules/entry')
        for policy in policy_list:
            log(policy.get('name'))

        panoip = '10.215.19.132'
        panoip = '10.215.18.25'
        new_logprofile = 'AMER-Dell-Standard-Logging'
        # new_logprofile='Splunk'
        pushcommands = []

        options.pushusername, options.pushpassword = get_creds()

        pushsession = requests.Session()
        pushsession.mount(panoip, DESAdapter())
        urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

        for context in options.context:
            for policy in policy_list:
                # pushcommands.append(('https://' + options.puship + '/api/?type=config&action=set&xpath=' + urllib.parse.quote_plus("/config/devices/entry[@name='localhost.localdomain']/device-group/entry[@name=\"" + customops.devicegroup_name + "\"]") + "&element=<devices><entry name=\'" + device + "\'/></devices>", 'Adding device "' + device + '" to device-group'))
                pushcommands.append((
                                    'https://' + panoip + '/api/?type=config&action=set&xpath=' + urllib.parse.quote_plus(
                                        "/config/devices/entry[@name='localhost.localdomain']/device-group/entry[@name='" + context + "']/pre-rulebase/security/rules/entry[@name='" + policy.get(
                                            'name') + "']") + "&element=<log-setting>" + new_logprofile + "</log-setting><log-start>no</log-start><log-end>yes</log-end>",
                                    'Modifying policy "' + policy.get(
                                        'name') + '" to log at session end using log profile ' + new_logprofile))

            for command, desc in pushcommands:
                log(desc)
                sys.stdout.flush()
                response = pushsession.get(command, verify=False, headers={'authorization': "Basic " + base64.b64encode(
                    '{}:{}'.format(options.username, options.password).encode()).decode()})
                if len(re.findall('success', response.text)) == 0:
                    log('', level=logging.ERROR)
                    log("!-- Error pushing command : ", level=logging.ERROR)
                    log(command, level=logging.ERROR)
                    log(response.text, level=logging.ERROR)
                    sys.stdout.flush()
                    exit(1)
                else:
                    pass
                    # log('--> Success!')
                    # sys.stdout.flush()

            # return_policy = load_policies(policy_list)
'''

## build routine to get route for ip address
## build routine to get zone based on next hope dest

from netaddr import *
longestmatch={}
route_to_check='143.166.0.0/16'
for context in contexts:

    if config[context]['config']['fw_type'] in ['paloalto', 'panorama']:
        longestmatch['length']=0
        longestmatch['dest']=''
        longestmatch['metric']=0
    
        if len(config[context]['vrouters']) > 0: print(context)
        for vrouter in config[context]['vrouters']:
            #print('  ' + vrouter)
            for static in config[context]['vrouters'][vrouter]:
                #print ('    ' + static)
                #print ('      Destination : ' + config[context]['vrouters'][vrouter][static]['destination'])
                for nexthop in config[context]['vrouters'][vrouter][static]['nexthops']:
                    #print ('          Nexthop : ' + nexthop)
                    #if IPSet([IPNetwork('143.166.0.0/16')]) in IPSet([IPNetwork(config[context]['vrouters'][vrouter][static]['destination'])]):
                    if IPNetwork(route_to_check) in IPSet([config[context]['vrouters'][vrouter][static]['destination']]):
                        #print ('            ROUTE MATCH : ' + nexthop)
                        network, mask = config[context]['vrouters'][vrouter][static]['destination'].split('/')
                        if int(mask) > longestmatch['length']: 
                            longestmatch['length']=int(mask)
                            longestmatch['destination']=config[context]['vrouters'][vrouter][static]['destination']
                            longestmatch['metric']=0
                            longestmatch['nexthop']=nexthop
        if longestmatch['length'] > 0:
            print('LONGEST MATCH : ' + longestmatch['destination'])

    ## ['pbrObjId', 'pbrObjProperties', 'pbrObjSrc', 'pbrObjDst', 'pbrObjSvc', 'pbrObjGw', 'pbrObjIface', 'pbrObjIfaceName', 'pbrObjMetric', 'pbrObjPriority', 'pbrObjProbe', 'pbrObjComment']
        
    if config[context]['config']['fw_type'] in ['sonicwall']:
        longestmatch['length']=0
        longestmatch['dest']=''
        for route in config[context]['routing']:
            print(route)
            print(config[context]['routing'][route]['pbrObjDst'])
            #  expand_address(address_dict, address_object, address_map, inc_group=False)
            #for address in expand_address(config[context]['routing'][route]['pbrObjDst']
            print(config[context]['routing'][route]['pbrObjGw'])
            #print(config[context]['routing'])
            #print(config[context]['routing'])
            #print(config[context]['routing'])

    #print(config[context]['vrouters'])
'''


def address_to_ipset(address, context):
    from netaddr import IPSet, IPRange, IPNetwork, IPAddress
    import ipaddress

    returnset = None

    ## return none for unsupported address types
    pass
    if address.lower() in ['', 'any']:
        returnset = IPSet(['0.0.0.0/0'])
    elif address in config[context]['addresses']:
        if config[context]['addresses'][address]['addrObjType'] in ['1', '99']:
            returnset = IPSet([IPAddress(config[context]['addresses'][address]['addrObjIp1'])])
        elif config[context]['addresses'][address]['addrObjType'] == '2':
            returnset = IPSet(IPRange(config[context]['addresses'][address]['addrObjIp1'],
                                      config[context]['addresses'][address]['addrObjIp2']))
        elif config[context]['addresses'][address]['addrObjType'] == '4':
            returnset = IPSet([IPNetwork(config[context]['addresses'][address]['addrObjIp1'] + '/' + str(
                netmask_to_cidr(config[context]['addresses'][address]['addrObjIp2'])))])
        elif config[context]['addresses'][address]['addrObjType'] == '8':  # group
            returnset = IPSet([])
            #  def expand_address(address_dict, address_object, address_map, inc_group=False):
            for member in expand_address(config[context]['addresses'], address, config[context]['addressmappings']):
                if member.lower() in ['', 'any']:
                    returnset = IPSet(['0.0.0.0/0'])
                elif member in config[context]['addresses']:
                    if config[context]['addresses'][member]['addrObjType'] in ['1', '99']:
                        returnset.add(IPAddress(config[context]['addresses'][member]['addrObjIp1']))
                    elif config[context]['addresses'][member]['addrObjType'] == '2':
                        returnset.add(IPRange(config[context]['addresses'][member]['addrObjIp1'],
                                              config[context]['addresses'][member]['addrObjIp2']))
                    elif config[context]['addresses'][member]['addrObjType'] == '4':
                        # returnset.add(IPSet([IPNetwork(config[context]['addresses'][member]['addrObjIp1'] + '/' + str(netmask_to_cidr(config[context]['addresses'][member]['addrObjIp2'])))]))
                        # debug('adding network to ipset' + config[context]['addresses'][member]['addrObjIp1'] + '/' + str(netmask_to_cidr(config[context]['addresses'][member]['addrObjIp2'])))
                        returnset.add(IPNetwork(config[context]['addresses'][member]['addrObjIp1'] + '/' + str(
                            netmask_to_cidr(config[context]['addresses'][member]['addrObjIp2']))))
                    else:
                        debug(config[context]['addresses'][member]['addrObjType'])

                # print('MEMBER : ' + member)
        else:
            returnset = 'address type : ' + config[context]['addresses'][address]['addrObjType']


    elif config[context]['config']['fw_type'].lower() in ['paloalto', 'panorama']:
        if address in config['shared']['addresses']:
            returnset = 'None'
    else:
        returnset = address

    ## does address exist in given context?
    ## if not, and its a palo/pano device, does it exist in shared?
    ## if address is host/network/range - return ipset value or object
    ## if address is group loop through expand_address_object
    ## does address exist in given context?
    ## if not, and its a palo/pano device, does it exist in shared?
    ## if address is host/network/range - return ipset value or object

    return returnset


if not True:  # options.movecheckpoint:

    import copy

    config = {}
    config['source'] = load_checkpoint(secobj=options.checkpointpol, natobj=options.checkpointnat,
                                       svcobj=options.checkpointsvc, netobj=options.checkpointobj)
    # config['dest']=load_checkpoint(secobj=options.destcheckpointpol, natobj=options.destcheckpointnat, svcobj=options.destcheckpointsvc, netobj=options.destcheckpointobj)
    config['dest'] = load_checkpoint(secobj='labs_Security.xml', natobj='labs_NAT.xml', svcobj='labs_services.xml',
                                     netobj='labs_network_objects.xml')
    ## verify that all sources, dests and services have been loaded - some address types are not loaded and can not be moved
    policy_to_move = '##Israel-CoE-AFCC'
    config['shared'] = {}
    config['shared']['addresses'] = {}
    config['shared']['addressmappings'] = {}
    config['shared']['servicemappings'] = {}
    config['shared']['services'] = {}
    config['shared']['policies'] = {}
    config['shared']['nat'] = {}
    config['shared']['config'] = {}
    # config['shared']['']={}

    config['new'] = {}
    config['new']['policies'] = OrderedDict()
    config['new']['addresses'] = OrderedDict()
    config['new']['services'] = OrderedDict()
    config['new']['addressmappings'] = {}
    config['new']['servicemappings'] = {}

    ## sanity check - print list of policy address/service objects that were not loaded via load_checkpoint
    for context in ['source', 'dest']:
        for policy in config[context]['policies']:

            for source in config[context]['policies'][policy]['policySrcNet']:

                if source not in config[context]['addresses'] and source.lower() != 'any':
                    print(source)

            for dest in config[context]['policies'][policy]['policyDstNet']:
                if dest not in config[context]['addresses'] and dest.lower() != 'any':
                    print(dest)

            for service in config[context]['policies'][policy]['policyDstSvc']:
                if service not in config[context]['services'] and service.lower() != 'any':
                    debug(service)

        ## Create svcSet property for every service group
        for service in config[context]['services']:
            if service.lower() not in ['', 'any'] and config[context]['services'][service]['svcObjType'] == '2':
                if 'svcSet' not in config[context]['services'][service]:
                    config[context]['services'][service]['svcSet'] = []
                    for member in expand_service(config[context]['services'], service,
                                                 config[context]['servicemappings']):
                        config[context]['services'][service]['svcSet'].append((config[context]['services'][member][
                                                                                   'svcObjIpType'],
                                                                               config[context]['services'][member][
                                                                                   'svcObjPort1'],
                                                                               config[context]['services'][member][
                                                                                   'svcObjPort2']))
                config[context]['services'][service]['svcSet'].sort(key=lambda tup: (tup[0], tup[1], tup[2]))
                # debug(config[context]['services'][service]['svcSet'])

    group_searched_list = []

    for policy in config['source']['policies']:
        if config['source']['policies'][policy]['policyName'] == policy_to_move:
            config['new']['policies'][policy] = copy.deepcopy(config['source']['policies'][policy])
            config['new']['policies'][policy]['policySrcNet'] = []  # Initialize new policy config to empty
            config['new']['policies'][policy]['policyDstNet'] = []
            config['new']['policies'][policy]['policyDstSvc'] = []

            for sources in config['source']['policies'][policy]['policySrcNet']:  # do everything but groups for now.
                if sources.lower() != 'any':
                    if config['source']['addresses'][sources]['addrObjType'] in ['8']:
                        # def expand_address(address_dict, address_object, address_map, inc_group=False):
                        source_list = expand_address(config['source']['addresses'], sources,
                                                     config['source']['addressmappings'], inc_group=True)
                    else:
                        source_list = [sources]
                    for source in source_list:
                        if source in config['source']['addresses'] and source.lower() != 'any' and source not in \
                                config['new']['addresses']:
                            source_match = False
                            for dest in config['dest']['addresses']:
                                if config['source']['addresses'][source]['addrObjType'] in ['1', '2', '4']:
                                    if config['source']['addresses'][source]['addrObjIp1'] == \
                                            config['dest']['addresses'][dest]['addrObjIp1'] and \
                                            config['source']['addresses'][source]['addrObjIp2'] == \
                                            config['dest']['addresses'][dest]['addrObjIp2']:
                                        source_match = config['dest']['addresses'][dest]
                                        break
                                if config['source']['addresses'][source]['addrObjType'] in ['8']:
                                    if config['dest']['addresses'][dest]['addrObjType'] == '8':
                                        if 'IPSet' not in config['source']['addresses'][
                                            source]:  # since this should be added during loading policy, this should never be false
                                            debug('IPSet not found in source')
                                        elif 'IPSet' not in config['source']['addresses'][
                                            source]:  # since this should be added during loading policy, this should never be false
                                            debug('IPSet not found in dest')
                                        elif config['source']['addresses'][source]['IPSet'] == \
                                                config['dest']['addresses'][dest]['IPSet']:
                                            source_match = config['dest']['addresses'][dest]
                                            break
                            if source_match:
                                break
                        elif sources in config['new']['addresses']:
                            source_match = config['new']['addresses'][sources]
                            ## BLOCK 1
                            ## Currently exact group matches are never found - should add group matching back into routine above
                        if not source_match:
                            config['new']['addresses'][source] = copy.deepcopy(config['source']['addresses'][source])
                            if config['new']['addresses'][source]['addrObjId'] in config['dest']['addresses']:
                                config['new']['addresses'][source]['addrObjId'] += '_NEW'
                            config['new']['addresses'][source]['addrObjIsNew'] = True
                            if config['new']['addresses'][sources]['addrObjId'] not in \
                                    config['new']['policies'][policy]['policySrcNet']:
                                config['new']['policies'][policy]['policySrcNet'].append(
                                    config['new']['addresses'][sources]['addrObjId'])
                            log('Adding new object type {:3.3s}      : {}'.format(
                                config['source']['addresses'][source]['addrObjType'],
                                config['new']['addresses'][source]['addrObjId']))
                        elif source_match != 'group':
                            log('Match found Type   : {:3.3s} Source : {:50.50s} Destination : {:50.50s}'.format(
                                config['source']['addresses'][source]['addrObjType'], source,
                                source_match['addrObjId']))
                            config['new']['addresses'][source] = copy.deepcopy(config['dest']['addresses'][dest])
                            config['new']['addresses'][source]['addrObjIsNew'] = False
                            if source in config['source']['policies'][policy][
                                'policySrcNet']:  ## not in config['new']['policies'][policy]['policySrcNet']:
                                config['new']['policies'][policy]['policySrcNet'].append(source_match['addrObjId'])
                                pass
                        elif source.lower() == 'any':
                            log('Source Any')
                            config['new']['policies'][policy]['policySrcNet'] = ['Any']
            ## do destinations
            for destinations in config['source']['policies'][policy][
                'policyDstNet']:  # do everything but groups for now.
                if destinations.lower() != 'any':
                    if config['source']['addresses'][destinations]['addrObjType'] in ['8']:
                        # def expand_address(address_dict, address_object, address_map, inc_group=False):
                        destination_list = expand_address(config['source']['addresses'], destinations,
                                                          config['source']['addressmappings'], inc_group=True)
                    else:
                        destination_list = [destinations]
                    for destination in destination_list:
                        if destination in config['source'][
                            'addresses'] and destination.lower() != 'any' and destination not in config['new'][
                            'addresses']:
                            destination_match = False
                            for dest in config['dest']['addresses']:
                                if config['source']['addresses'][destination]['addrObjType'] in ['1', '2', '4']:
                                    if config['source']['addresses'][destination]['addrObjIp1'] == \
                                            config['dest']['addresses'][dest]['addrObjIp1'] and \
                                            config['source']['addresses'][destination]['addrObjIp2'] == \
                                            config['dest']['addresses'][dest]['addrObjIp2']:
                                        destination_match = config['dest']['addresses'][dest]
                                        break
                                if config['source']['addresses'][destination]['addrObjType'] in ['8']:
                                    if config['dest']['addresses'][dest]['addrObjType'] == '8':
                                        if 'IPSet' not in config['source']['addresses'][
                                            destination]:  # since this should be added during loading policy, this should never be false
                                            debug('IPSet not found in source')
                                        elif 'IPSet' not in config['source']['addresses'][
                                            destination]:  # since this should be added during loading policy, this should never be false
                                            debug('IPSet not found in dest')
                                        elif config['source']['addresses'][destination]['IPSet'] == \
                                                config['dest']['addresses'][dest]['IPSet']:
                                            destination_match = config['dest']['addresses'][dest]
                                            break
                            if destination_match:
                                break

                            ## Currently exact group matches are never found - should add group matching back into routine above
                            if not destination_match:
                                # log('No match found for              : {}'.format(source))
                                config['new']['addresses'][destination] = copy.deepcopy(
                                    config['source']['addresses'][destination])
                                if config['new']['addresses'][destination]['addrObjId'] in config['dest']['addresses']:
                                    config['new']['addresses'][destination]['addrObjId'] += '_NEW'
                                config['new']['addresses'][destination]['addrObjIsNew'] = True
                                if config['new']['addresses'][destinations]['addrObjId'] not in \
                                        config['new']['policies'][policy]['policyDstNet']:
                                    config['new']['policies'][policy]['policyDstNet'].append(
                                        config['new']['addresses'][destination]['addrObjId'])
                                log('Adding new object type {:3.3s}      : {}'.format(
                                    config['source']['addresses'][destination]['addrObjType'],
                                    config['new']['addresses'][destination]['addrObjId']))
                            elif destination_match != 'group':
                                log('Match found Type   : {:3.3s} Source : {:50.50s} Destination : {:50.50s}'.format(
                                    config['source']['addresses'][destination]['addrObjType'], destination,
                                    destination_match['addrObjId']))
                                config['new']['addresses'][destination] = copy.deepcopy(
                                    config['dest']['addresses'][dest])
                                config['new']['addresses'][destination]['addrObjIsNew'] = False
                                if destination in config['source']['policies'][policy]['policyDstNet']:
                                    config['new']['policies'][policy]['policyDstNet'].append(
                                        destination_match['addrObjId'])
                        elif destination.lower() == 'any':
                            log('Destination Any')
                            config['new']['policies'][policy]['policyDstNet'] = ['Any']

if options.movecheckpoint:

    import copy

    config = {}
    config['source'] = load_checkpoint(secobj=options.checkpointpol, natobj=options.checkpointnat,
                                       svcobj=options.checkpointsvc, netobj=options.checkpointobj)
    # config['dest']=load_checkpoint(secobj=options.destcheckpointpol, natobj=options.destcheckpointnat, svcobj=options.destcheckpointsvc, netobj=options.destcheckpointobj)
    config['dest'] = load_checkpoint(secobj='labs_Security.xml', natobj='labs_NAT.xml', svcobj='labs_services.xml',
                                     netobj='labs_network_objects.xml')
    ## verify that all sources, dests and services have been loaded - some address types are not loaded and can not be moved
    policy_to_move = '##Israel-CoE-AFCC'

    config['shared'] = {}
    config['shared']['addresses'] = {}
    config['shared']['addressmappings'] = {}
    config['shared']['servicemappings'] = {}
    config['shared']['services'] = {}
    config['shared']['policies'] = {}
    config['shared']['nat'] = {}
    config['shared']['config'] = {}
    # config['shared']['']={}

    config['new'] = {}
    config['new']['policies'] = OrderedDict()
    config['new']['addresses'] = OrderedDict()
    config['new']['services'] = OrderedDict()
    config['new']['addressmappings'] = {}
    config['new']['servicemappings'] = {}

    all_addresses = []
    all_services = []

    ## Create svcSet property for every service group

    for context in ['source', 'dest']:
        for policy in config[context]['policies']:
            for service in config[context]['services']:
                if service.lower() not in ['', 'any'] and config[context]['services'][service]['svcObjType'] == '2':
                    if 'svcSet' not in config[context]['services'][service]:
                        config[context]['services'][service]['svcSet'] = []
                        for member in expand_service(config[context]['services'], service,
                                                     config[context]['servicemappings']):
                            config[context]['services'][service]['svcSet'].append((config[context]['services'][member][
                                                                                       'svcObjIpType'],
                                                                                   config[context]['services'][member][
                                                                                       'svcObjPort1'],
                                                                                   config[context]['services'][member][
                                                                                       'svcObjPort2']))
                    config[context]['services'][service]['svcSet'].sort(key=lambda tup: (tup[0], tup[1], tup[2]))

    ## build list of all address objects used in policies

    for policy in config['source']['policies']:
        if config['source']['policies'][policy]['policyName'] == policy_to_move:
            config['new']['policies'][policy] = copy.deepcopy(config['source']['policies'][policy])
            for member in config['source']['policies'][policy]['policySrcNet']:  # do everything but groups for now.
                if member.lower() != 'any':
                    if config['source']['addresses'][member]['addrObjType'] in ['8']:
                        source_list = expand_address(config['source']['addresses'], member,
                                                     config['source']['addressmappings'], inc_group=True)
                        source_list.extend([member])  # make sure parent group is included in list
                    else:
                        source_list = [member]
                    for source in source_list:
                        if source not in all_addresses: all_addresses.append(source)
            for member in config['source']['policies'][policy]['policyDstNet']:  # do everything but groups for now.
                if member.lower() != 'any':
                    if config['source']['addresses'][member]['addrObjType'] in ['8']:
                        dest_list = expand_address(config['source']['addresses'], member,
                                                   config['source']['addressmappings'], inc_group=True)
                        dest_list.extend([member])  # make sure parent group is included in list
                    else:
                        dest_list = [member]
                    for dest in dest_list:
                        if dest not in all_addresses: all_addresses.append(dest)
            for member in config['source']['policies'][policy]['policyDstSvc']:  # do everything but groups for now.
                if member.lower() != 'any':
                    if config['source']['services'][member]['svcObjType'] in ['2']:
                        service_list = expand_service(config['source']['services'], member,
                                                      config['source']['servicemappings'], inc_group=True)
                        service_list.extend([member])  # make sure parent group is included in list
                    else:
                        service_list = [member]
                    for dest in service_list:
                        if dest not in all_services: all_services.append(dest)

    ## create new address objects and source_to_new mappings

    move_map = {}
    rev_map = {}

    for source in all_addresses:
        source_match = False
        if source.lower() in [x.lower() for x in config['source']['addresses']]:
            # if source not in config['new']['addresses']: ## if address is in new dict, it was already searched, no need to do it again
            for dest in config['dest']['addresses']:
                if config['source']['addresses'][source]['addrObjType'] != '8':
                    if config['dest']['addresses'][dest]['addrObjType'] != '8':
                        if config['source']['addresses'][source]['addrObjIp1'] == config['dest']['addresses'][dest][
                            'addrObjIp1'] and config['source']['addresses'][source]['addrObjIp2'] == \
                                config['dest']['addresses'][dest]['addrObjIp2']:
                            log('      address match    {:50.50s} {:50.50s} '.format(source, dest))
                            config['new']['addresses'][dest] = copy.deepcopy(config['dest']['addresses'][dest])
                            source_match = True
                            move_map[source] = dest
                            rev_map[dest] = source
                            break
                elif config['source']['addresses'][source]['addrObjType'] in ['8']:
                    if config['dest']['addresses'][dest]['addrObjType'] in ['8']:
                        if config['source']['addresses'][source]['IPSet'] == config['dest']['addresses'][dest]['IPSet']:
                            log('address group match    {:50.50s} {:50.50s} : '.format(source, dest))
                            config['new']['addresses'][dest] = copy.deepcopy(config['dest']['addresses'][dest])
                            source_match = True
                            move_map[source] = dest
                            rev_map[dest] = source
                            break
        if not source_match:
            # debug([x.lower() for x in config['dest']['addresses']])
            if source.lower() in [x.lower() for x in config['dest']['addresses']]:
                new_key = source + '_NEW'
            else:
                new_key = source
            log(' no match found for     {:50.50s} {:50.50s}'.format(source, new_key))
            move_map[source] = new_key
            rev_map[new_key] = source
            config['new']['addresses'][new_key] = copy.deepcopy(config['source']['addresses'][source])
            config['new']['addresses'][new_key]['addrObjId'] = new_key

    for source in all_services:
        source_match = False
        if source not in config['source']['services']:
            debug('Service not found in config : ' + source)
        if source not in config['new'][
            'services']:  ## if address is in new dict, it was already searched, no need to do it again
            for dest in config['dest']['services']:
                if config['source']['services'][source]['svcObjType'] != '2':
                    if config['dest']['services'][dest]['svcObjType'] != '2':
                        if config['source']['services'][source]['svcObjPort1'] == config['dest']['services'][dest][
                            'svcObjPort1'] and config['source']['services'][source]['svcObjPort2'] == \
                                config['dest']['services'][dest]['svcObjPort2'] and \
                                config['source']['services'][source]['svcObjIpType'] == \
                                config['dest']['services'][dest]['svcObjIpType']:
                            log('      service match    {:50.50s} {:50.50s} '.format(source, dest))
                            config['new']['services'][dest] = copy.deepcopy(config['dest']['services'][dest])
                            source_match = True
                            move_map[source] = dest
                            rev_map[dest] = source
                            break
                elif config['source']['services'][source]['svcObjType'] in ['2']:
                    if config['dest']['services'][dest]['svcObjType'] in ['2']:
                        if config['source']['services'][source]['svcSet'] == config['dest']['services'][dest]['svcSet']:
                            log('service group match    {:50.50s} {:50.50s} : '.format(source, dest))
                            config['new']['services'][dest] = copy.deepcopy(config['dest']['services'][dest])
                            source_match = True
                            move_map[source] = dest
                            rev_map[dest] = source
                            break
        if not source_match:
            if source.lower() in [x.lower() for x in config['dest']['services']]:
                new_key = source + '_NEW'
            else:
                new_key = source
            log(' no svc match found for  {:50.50s} {:50.50s}'.format(source, new_key))
            move_map[source] = new_key
            rev_map[new_key] = source
            config['new']['services'][new_key] = copy.deepcopy(config['source']['services'][source])
            config['new']['services'][new_key]['svcObjId'] = new_key

    ## create new addressmappings

    ## source to new mappings -- use a IsNew key in source?

    for mapping in config['source']['addressmappings']:
        # if move_map[mapping] in config['new']['addresses']:
        if mapping in move_map:
            log('-' * 100)
            log('address group {} needs to be updated'.format(mapping))
            config['new']['addressmappings'][move_map[mapping]] = []
            for member in config['source']['addressmappings'][mapping]:
                config['new']['addressmappings'][move_map[mapping]].append(move_map[member])
                log(member, move_map[member])

    for mapping in config['source']['servicemappings']:
        # if move_map[mapping] in config['new']['addresses']:
        if mapping in move_map:
            log('-' * 100)
            log('service group {} needs to be updated'.format(mapping))
            config['new']['servicemappings'][move_map[mapping]] = []
            for member in config['source']['servicemappings'][mapping]:
                config['new']['servicemappings'][move_map[mapping]].append(move_map[member])
                log(member, move_map[member])

                ## create new DstNet and SrcNet lists for policies

    for policy in config['source']['policies']:
        if config['source']['policies'][policy]['policyName'] == policy_to_move:
            config['new']['policies'][policy]['policySrcNet'] = []
            config['new']['policies'][policy]['policyDstNet'] = []
            config['new']['policies'][policy]['policyDstSvc'] = []
            for member in config['source']['policies'][policy]['policySrcNet']:
                if member.lower() == 'any':
                    config['new']['policies'][policy]['policySrcNet'].append('Any')
                else:
                    config['new']['policies'][policy]['policySrcNet'].append(move_map[member])
            for member in config['source']['policies'][policy]['policyDstNet']:
                if member.lower() == 'any':
                    config['new']['policies'][policy]['policyDstNet'].append('Any')
                else:
                    config['new']['policies'][policy]['policyDstNet'].append(move_map[member])
            for member in config['source']['policies'][policy]['policyDstSvc']:
                # print(member)
                if member.lower() == 'any':
                    config['new']['policies'][policy]['policyDstSvc'].append('Any')
                else:
                    config['new']['policies'][policy]['policyDstSvc'].append(move_map[member])
            # config['new']['policies'][policy]['policyDstSvc']=copy.deepcopy(config['source']['policies'][policy]['policyDstSvc'])
            if len(config['new']['policies'][policy]['policySrcNet']) != len(
                    config['source']['policies'][policy]['policySrcNet']):
                print('length of SrcNet does not match')
            if len(config['new']['policies'][policy]['policyDstNet']) != len(
                    config['source']['policies'][policy]['policyDstNet']):
                print('length of DstNet does not match')
    for mapping in config['new']['addressmappings']:
        if len(config['new']['addressmappings'][mapping]) != len(config['source']['addressmappings'][rev_map[mapping]]):
            print('-' * 100)
            print(mapping + 'does not match ' + rev_map[mapping])

    ## Build dbedit commands

    print('## building dbedit commands')
    for address in config['new']['addresses']:
        if address not in config['dest']['addresses']:
            # print('create address type {} : {}'.format(config['new']['addresses'][address]['addrObjType'], address))
            if config['new']['addresses'][address]['addrObjType'] == '1':
                log('create host_plain ' + address)
            elif config['new']['addresses'][address]['addrObjType'] == '2':
                log('create address_range ' + address)
            elif config['new']['addresses'][address]['addrObjType'] == '4':
                log('create network ' + address)
            elif config['new']['addresses'][address]['addrObjType'] == '8':
                log('create network_object_group ' + address)
            elif config['new']['addresses'][address]['addrObjType'] == '99':
                log('create host_ckp ' + address)
            else:
                debug('dont know how to create object type : ' + config['new']['addresses'][address]['addrObjType'])

    for service in config['new']['services']:
        if service not in config['dest']['services']:
            # print('create service type {} : {}'.format(config['new']['services'][service]['svcObjType'], service))
            if config['new']['services'][service]['svcObjType'] == '1':
                if config['new']['services'][service]['svcObjIpType'] == '6':
                    log('create tcp_service ' + service)
                elif config['new']['services'][service]['svcObjIpType'] == '17':
                    log('create udp_service ' + service)
                else:
                    debug('unknown service type : "' + config['new']['services'][service]['svcObjIpType'] + '"')
            if config['new']['services'][service]['svcObjType'] == '2':
                log('create service_group ' + service)
    log('create firewall_policy ' + policy_to_move)
    log('update_all')
    ## Modify object properties

    for address in config['new']['addresses']:
        if address not in config['dest']['addresses']:
            # print('create address type {} : {}'.format(config['new']['addresses'][address]['addrObjType'], address))
            if config['new']['addresses'][address]['addrObjType'] == '1':
                log('modify network_objects ' + address + ' ipaddr ' + config['new']['addresses'][address][
                    'addrObjIp1'])
                log('modify network_objects ' + address + ' comments "' + config['new']['addresses'][address][
                    'addrObjComment'] + '"')
                log('modify network_objects ' + address + ' color ' + config['new']['addresses'][address][
                    'addrObjColor'])
            elif config['new']['addresses'][address]['addrObjType'] == '2':
                log('modify network_objects ' + address + ' ipaddr_first ' + config['new']['addresses'][address][
                    'addrObjIp1'])
                log('modify network_objects ' + address + ' ipaddr_last ' + config['new']['addresses'][address][
                    'addrObjIp2'])
                log('modify network_objects ' + address + ' comments "' + config['new']['addresses'][address][
                    'addrObjComment'] + '"')
                log('modify network_objects ' + address + ' color ' + config['new']['addresses'][address][
                    'addrObjColor']) \
            elif config['new']['addresses'][address]['addrObjType'] == '4':
                log('modify network_objects ' + address + ' ipaddr ' + config['new']['addresses'][address][
                    'addrObjIp1'])
                log('modify network_objects ' + address + ' netmask ' + config['new']['addresses'][address][
                    'addrObjIp2'])
                log('modify network_objects ' + address + ' comments "' + config['new']['addresses'][address][
                    'addrObjComment'] + '"')
                log('modify network_objects ' + address + ' color ' + config['new']['addresses'][address][
                    'addrObjColor'])
            elif config['new']['addresses'][address]['addrObjType'] == '8':
                log('modify network_objects ' + address + ' comments "' + config['new']['addresses'][address][
                    'addrObjComment'] + '"')
                log('modify network_objects ' + address + ' color ' + config['new']['addresses'][address][
                    'addrObjColor'])
                # log('modify network_objects ' + address)
            elif config['new']['addresses'][address]['addrObjType'] == '99':
                # log('modify network_objects ' + address)
                pass  # do nothing for now

    for service in config['new']['services']:
        if service not in config['dest']['services']:
            # print('create service type {} : {}'.format(config['new']['services'][service]['svcObjType'], service))
            if config['new']['services'][service]['svcObjType'] == '1':
                log('modify services ' + service + ' color ' + config['new']['services'][service]['svcObjColor'])
                log('modify services ' + service + ' port ' + config['new']['services'][service]['svcObjPort1'])
                log('modify services ' + service + ' comments "' + config['new']['services'][service][
                    'svcObjComment'] + '"')
            if config['new']['services'][service]['svcObjType'] == '2':
                # log('modify services ' + service + ' port ' + config['new']['services'][service]['svcObjPort1'])
                log('modify services ' + service + ' comments "' + config['new']['services'][service][
                    'svcObjComment'] + '"')

    '''
    DEBUG: dont know how to create object type : 99
    create address type 99 : CLM-SBS2-prd01
    DEBUG: dont know how to create object type : 99
    create address type 99 : CLM-SBS2-prd02
    DEBUG: dont know how to create object type : 99
    create address type 99 : CLM-SBS2-prd03
    DEBUG: dont know how to create object type : 99
    create address type 99 : CLM-SBS2-prd04
    DEBUG: dont know how to create object type : 99

    '''
    for address in config['new']['addresses']:
        if address not in config['dest']['addresses']:
            if config['new']['addresses'][address]['addrObjType'] == '8':
                for member in config['new']['addressmappings'][address]:
                    log('addelement network_objects ' + address + ' \'\' network_objects:' + member)

    for service in config['new']['services']:
        if service not in config['dest']['services']:
            if config['new']['services'][service]['svcObjType'] == '2':
                for member in config['new']['servicemappings'][service]:
                    log('addelement services ' + service + ' \'\' services:' + member)

    index = 0
    for policy in config['new']['policies']:
        # print ('creating policy : ' + str(policy))

        if config['new']['policies'][policy]['policyEnabled'] == '1':
            disabled = 'false'
        else:
            disabled = 'true'
        if config['new']['policies'][policy]['policyAction'] == '0':
            action = 'drop_action:deny'
        elif config['new']['policies'][policy]['policyAction'] == '1':
            action = 'drop_action:drop'
        elif config['new']['policies'][policy]['policyAction'] == '3':  ## changeme
            # action='drop_action:drop'
            pass
        else:  # config['new']['policies'][policy]['policyAction']=='2':
            action = 'accept_action:accept'

        log('addelement fw_policies ' + policy_to_move + ' rule security_rule')
        # log('update fw_policies ' + policy_to_move)
        # log('update')
        log('modify fw_policies ' + policy_to_move + ' rule:' + str(index) + ':comments "' +
            config['new']['policies'][policy]['policyComment'] + '"')
        log('modify fw_policies ' + policy_to_move + ' rule:' + str(index) + ':disabled ' + disabled)
        log('addelement fw_policies ' + policy_to_move + ' rule:' + str(index) + ':action ' + action)
        for source in config['new']['policies'][policy]['policySrcNet']:
            if source.lower() != 'any': log("addelement fw_policies " + policy_to_move + " rule:" + str(
                index) + ":src:'' network_objects:" + source)
        for dest in config['new']['policies'][policy]['policyDstNet']:
            if dest.lower() != 'any': log(
                "addelement fw_policies " + policy_to_move + " rule:" + str(index) + ":dst:'' network_objects:" + dest)
        for service in config['new']['policies'][policy]['policyDstSvc']:
            if service.lower() != 'any': log(
                "addelement fw_policies " + policy_to_move + " rule:" + str(index) + ":services:'' services:" + service)
        index += 1

    log('update_all')

    ## not implemented:
    ## service colors
    ## policy colors

    # config['new']['services']=copy.deepcopy(config['source']['services'])  ## temp so that i can dump the config
    # config['new']['servicemappings']=copy.deepcopy(config['source']['servicemappings'])

    # config['new']['addressmappings']=config['source']['addressmappings']
    # config['new']['addresses']=config['source']['addresses']
    ## config['new']=config['source'] - this produced identical tuple files

    # dump_config(config, ['source', 'new'])
    create_tuples(config, 'source.tup', 'all', ['source'], policy_to_move)
    create_tuples(config, 'new.tup', 'all', ['new'], policy_to_move)

if options.emcroute:

    import urllib
    import ipaddress
    import netaddr

    for member in options.emcroute[1].split(','):  # verify all specified subnets are valid
        try:
            tmp = ipaddress.IPv4Network(member)
        except Exception as e:
            debug('Problem with specified destination network -- {}'.format(e))
            debug('Fatal error -- Exiting')
            exit(1)

    for i in config:
        matched_route = False
        if i != 'shared':
            if 'routing' in config[i]:
                for route in config[i]['routing']:
                    if config[i]['routing'][route]['pbrObjDst'] != '':  # destination = any
                        if ipaddress.IPv4Network(options.emcroute[0]) in \
                                config[i]['addresses'][config[i]['routing'][route]['pbrObjDst']]['IPv4Networks']:
                            pass
                        sources = expand_address(config[i]['addresses'], config[i]['routing'][route]['pbrObjSrc'],
                                                 config[i]['addressmappings'])
                        dests = expand_address(config[i]['addresses'], config[i]['routing'][route]['pbrObjDst'],
                                               config[i]['addressmappings'])
                        if config[i]['routing'][route]['pbrObjGw'] != '':
                            gw = config[i]['addresses'][config[i]['routing'][route]['pbrObjGw']]['addrObjIp1']
                        else:
                            gw = 'Blank'
                        maxlen = max(set([len(sources), len(dests)]))

                        for line in range(0, maxlen):
                            if len(sources) == 0:
                                source = 'any'
                            elif line < len(sources):
                                source = sources[line]
                            else:
                                source = ''
                            if len(dests) == 0:
                                dest = 'any'
                            elif line < len(dests):
                                dest = dests[line]
                            else:
                                dest = ''
                            if line == 0:
                                name = urllib.parse.unquote(config[i]['routing'][route]['pbrObjId'])
                                iface = urllib.parse.unquote(config[i]['routing'][route]['pbrObjIfaceName'])
                            else:
                                name = ''
                                iface = ''
                            if source == '' or source == 'any':  # only match if source is any/blank
                                if dest in config[i]['addresses']:
                                    if ipaddress.IPv4Network(options.emcroute[0]) in config[i]['addresses'][dest][
                                        'IPv4Networks']:
                                        log("EMC-Public-Internal" in expand_address(config[i]['addresses'],
                                                                                    config[i]['routing'][route][
                                                                                        'pbrObjDst'],
                                                                                    config[i]['addressmappings'],
                                                                                    inc_group=True))
                                        matched_route = config[i]['routing'][route]
                                        break
                if matched_route:
                    dstzone = config[i]['addresses'][expand_address(config[i]['addresses'], matched_route['pbrObjDst'],
                                                                    config[i]['addressmappings'])[0]]['addrObjZone']
                    group_name = "EMC-Public-Internal"
                    gindex = 1
                    while group_name in config[i]['addresses']:
                        group_name = "EMC-Public-Internal_" + str(gindex)
                        gindex += 1
                    gindex = 0
                    group_members = OrderedDict()
                    # log ('Creating Group : ' + group_name)
                    for member in options.emcroute[1].split(
                            ','):  # consider searching for existing network objects first
                        # log(options.emcroute[0])
                        # log(member)
                        network, mask = member.split('/')
                        group_members[gindex] = {}
                        group_members[gindex]['name'] = 'N-' + network + '-' + mask
                        mindex = 1
                        while group_members[gindex]['name'] == 'N-' + network + '-' + mask in config[i]['addresses']:
                            group_members[gindex]['name'] = 'N-' + network + '-' + mask + '_' + str(mindex)
                            mindex += 1
                        group_members[gindex]['ip1'] = network
                        group_members[gindex]['ip2'] = cidr_to_netmask(mask)
                        group_members[gindex]['zone'] = dstzone
                        # log('Adding Group Member : ' + group_members[gindex]['name'])
                        gindex += 1
                    log('configure')
                    for idx in group_members:
                        log('address-object ipv4 "' + group_members[idx]['name'] + '" network ' + group_members[idx][
                            'ip1'] + ' ' + group_members[idx]['ip2'] + ' zone ' + group_members[idx]['zone'])
                    log('commit')
                    log('address-group ipv4 "' + group_name + '"')
                    for idx in group_members:
                        log('address-object ipv4 "' + group_members[idx]['name'] + '"')
                    log('commit')
                    log('exit')
                    # modify route via group membership, or add a new rule?
                    # log(matched_route['pbrObjDst'])
                    # log(config[i]['addresses'][matched_route['pbrObjDst']])
                    if config[i]['addresses'][matched_route['pbrObjDst']]['addrObjType'] == '8':
                        log('address-group ipv4 "' + matched_route['pbrObjDst'] + '"')
                        log('address-group ipv4 "' + group_name + '"')
                        log('commit')
                        log('exit')
                    else:
                        if matched_route['pbrObjGw'] in config[i][
                            'addresses']:  ## if dst gw object exists in addresses, add it using name paramter
                            log('routing')
                            log('policy interface {} metric 1 source any destination group "{}" service any gateway name "{}"'.format(
                                urllib.parse.unquote(matched_route['pbrObjIfaceName'])[3:], group_name,
                                urllib.parse.unquote(matched_route['pbrObjGw'])))
                            log('comment "EMC-Public-Internal route addition via script - jeff_miller2"')
                            log('commit')
                            log('exit')
                        else:  # otherwise add the destination as if it is an ip address
                            log('routing')
                            log('policy interface {} metric 1 source any destination group "{}" service any gateway host "{}"'.format(
                                urllib.parse.unquote(matched_route['pbrObjIfaceName'])[3:], group_name,
                                urllib.parse.unquote(matched_route['pbrObjGw'])))
                            log('comment "EMC-Public-Internal route addition via script - jeff_miller2"')
                            log('commit')
                            log('exit')
                    break  # matched address found, changes made, exit loop
                    # print('{:30.30s} {:30.30s} {:30.30s} {:30.30s} {:30.30s}'.format(name, iface, source, dest, gw ))
                    # print ('=' *150)

if options.batch:
    for cmd in options.batch:
        if cmd[0] == "@":
            cmd = file_to_list(cmd[1:])
        log(cmd)

if options.gordon:
    configfilename = "config_python.txt"

    import re
    import urllib
    import os

    if not os.path.isfile(
            configfilename):  # if file does not exist, exit with error to let calling script know something went wrong
        exit(1)
    with open(configfilename) as working_file:

        config = working_file.read()
        firewallname = re.findall('firewallName=.*', config)[0].split('=')[1]
        for x in re.findall(r'userObjId.*', config):
            username = x.split('=')[1]
            print(firewallname + ',' + urllib.parse.unquote(username), end='')
            groupnums = re.findall(r'uo_atomToGrp.*' + username, config)
            for idx, groupnum in enumerate(groupnums):
                # print(groupnum.split('=')[0].split('_')[-1])
                group = re.findall(r'uo_grpToGrp_' + groupnum.split('=')[0].split('_')[-1] + '=.*', config)
                if idx == 0:
                    print(',' + urllib.parse.unquote(group[0].split('=')[1]), end='')
                else:
                    print('|' + urllib.parse.unquote(group[0].split('=')[1]), end='')
            print('')

if options.management:
    from urllib.parse import unquote as url_unquote

    for context in config:
        if context != 'shared':
            # log ('=' * 180)
            # log (config[context]['config']['name'])
            '''
            for route in config[context]['routing']:
                if config[context]['routing'][route]['pbrObjDst'] in ['0.0.0.0', '']:
                    log('Default Gateway "[' + config[context]['routing'][route]['pbrObjDst'] + ']" : "' + url_unquote(config[context]['routing'][route]['pbrObjGw']) + '" - ')
                    if config[context]['routing'][route]['pbrObjGw']!='':
                        log(config[context]['addresses'][config[context]['routing'][route]['pbrObjGw']]['addrObjIp1'])
                        def_gw=config[context]['addresses'][config[context]['routing'][route]['pbrObjGw']]['addrObjIp1']
            '''
            log('-' * 180)
            # log('{:20.20s} {:20.20s} {:20.20s} {:20.20s} {:20.20s} {:20.20s} {:20.20s} {:20.20s} {:20.20s} {:20.20s} '.format('Interface', 'Type', 'IP', 'Zone', 'HTTP', 'HTTPS', 'SSH', 'PING', 'SNMP'))
            log('{:s},{:s},{:s},{:s},{:s},{:s},{:s},{:s},{:s},{:s}'.format('Firewall', 'Interface', 'Type', 'IP',
                                                                           'Zone', 'HTTP', 'HTTPS', 'SSH', 'PING',
                                                                           'SNMP'))
            log('-' * 180)

            for interface in config[context]['interfaces']:
                # log(config[context]['interfaces'][interface])
                if config[context]['interfaces'][interface]['portShutdown'].lower() == 'off' and \
                        config[context]['interfaces'][interface]['iface_type'] in ['6', '7', '17', '1']:
                    if config[context]['interfaces'][interface]['iface_type'] in ['6', '7']:
                        tmp_ip = config[context]['interfaces'][interface]['iface_lan_ip']
                    elif config[context]['interfaces'][interface]['iface_type'] in ['1']:
                        tmp_ip = config[context]['interfaces'][interface]['iface_static_ip']
                    elif config[context]['interfaces'][interface]['iface_type'] in ['17']:
                        tmp_ip = config[context]['interfaces'][interface]['iface_mgmt_ip']
                    # log('{:20.20s} {:20.20s} {:20.20s} {:20.20s} {:20.20s} {:20.20s} {:20.20s} {:20.20s} {:20.20s} {:20.20s} '.format(
                    log('{:s},{:s},{:s},{:s},{:s},{:s},{:s},{:s},{:s},{:s}'.format(
                        config[context]['config']['name'],
                        config[context]['interfaces'][interface]['iface_name'],
                        config[context]['interfaces'][interface]['iface_type'],
                        tmp_ip,
                        config[context]['interfaces'][interface]['interface_Zone'],
                        str(config[context]['interfaces'][interface]['iface_http_mgmt'] == '1'),
                        str(config[context]['interfaces'][interface]['iface_https_mgmt'] == '1'),
                        str(config[context]['interfaces'][interface]['iface_ssh_mgmt'] == '1'),
                        str(config[context]['interfaces'][interface]['iface_ping_mgmt'] == '1'),
                        str(config[context]['interfaces'][interface]['iface_snmp_mgmt'] == '1')))
if options.sw_get_tsr:
    import sonicwall as sw

    for target in options.grouptargets:
        sw.get_tsr(target, options.username, options.password)


# if options.sw_upload_fw or options.sw_backup:

def sw_firmware(target):
    fw_info = {'name': 'unknown',
               'ip': 'unknown',
               'model': 'unknown',
               'firmware': 'unknown',
               'rom': 'unknown',
               'connections': 'unknown',
               'rulecount': 'unknown',
               'message': 'unknown'
               }

    config = get_sonicwall_exp(target)

    '''
    exp_config=get_sw_config_https(target, None, options.username, options.password)
    tmpconfig=None
    if exp_config: 
        memory_config=convert_exp_file('', None, exp_config.encode())
        exp_config=None # free up memory 
        if memory_config:
            tmpconfig=load_sonicwall('', True, memory_config)
            memory_config=None  # free up memory

    if tmpconfig:
        if options.context !='':
            tmpcontext=options.context[0]
        else:
            tmpcontext=tmpconfig['config']['name']
        config[tmpcontext] = tmpconfig
        if not options.context:
            options.context = [tmpcontext]
        for context in options.context:
            contexts.append(context)
        tmpconfig=None  # free up memory
    '''

    fw_info['ip'] = target

    target_version = "6.5.4.7"
    # target_version = "6.1.1"
    target_rom_vers = ('5.4.1.0', '5.4.1.2', '5.4.0.13')
    firmware_set = (  # use this if upgrading from 6.1.1.9
        ('9600', '/opt/scripts/sw_supermassive-9600_eng_6.2.5.4_6.2.5_1n_1201575.sig'),
        ('9400', '/opt/scripts/sw_supermassive-9400_eng_6.2.5.4_6.2.5_1n_1201575.sig'),
        # ('9400', '../sw_supermassive-9400_eng_6.5.4.4_6.5.4_44n_1201471.sig'),
        ('5600', '/opt/scripts/sw_nsa-5600_eng_6.2.5.4_6.2.5_1n_1201575.sig')
    )

    firmware_set = (  # use this if upgrading from 6.2.5.x
        ('9600', '../sw_supermassive-9600__eng_6.5.4.7-83n.sig'),
        ('9400', '../sw_supermassive-9400__eng_6.5.4.7-83n.sig'),
        # ('9400', '../sw_supermassive-9400_eng_6.5.4.4_6.5.4_44n_1201471.sig'),
        ('5600', '../sw_nsa-5600__eng_6.5.4.7-83n.sig')
    )

    firmware_set = (  # use this if upgrading from 6.5.4.x
        ('9600', '../../sw_supermassive-9600__eng_6.5.4.8-89n.sig'),
        ('9400', '../../sw_supermassive-9400__eng_6.5.4.8-89n.sig'),
        # ('9400', '../sw_supermassive-9400_eng_6.5.4.4_6.5.4_44n_1201471.sig'),
        ('5600', '../../sw_nsa-5600__eng_6.5.4.8-89n.sig')
    )

    import re

    if not options.web and (options.username == None or options.password == None):
        options.username, options.password = get_creds()

    import sonicwall as sw
    sonicwallfound = False
    firmware_file = False
    for context in config:
        if config[context]['config']['fw_type'] == 'sonicwall':
            sonicwallfound = True
            if sonicwallfound:
                session = requests.Session()
                session.mount('https://' + target, sw.DESAdapter())

                response = sw.do_login(session, options.username, options.password, target,
                                       True)  ## need to be in config mode to request reboot
                response = sw.get_url(session, 'https://' + target + '/systemStatusView.html',
                                      timeout=options.timeout_sw_webui)
                systemStatusObjects = re.sub(r', ', ',', re.sub(r'\'', '',
                                                                re.sub(r'.*systemStatusObject\((.*?)\);.*', r'\1',
                                                                       response.text, flags=re.DOTALL))).split(',')
                debug(systemStatusObjects)
                fw_info['rom'] = systemStatusObjects[7]
                if fw_info['rom'] in target_rom_vers:
                    fw_info['firmware'] = config[context]['config']['version']
                    log('!-- Appliance on approved ROM version : ', fw_info['rom'])
                    if re.findall(target_version, fw_info['firmware']):
                        log('!-- Firmware contains string ' + target_version)

                        if options.sw_backup:
                            log("!-- Creating backup : " + target)
                            sw_backup = sw.backup(target, options.username, options.password)
                            if sw_backup:
                                if sw_backup == 'not_active':
                                    fw_info['message'] = '!-- Backup skipped - not active appliance : ' + target
                                    log(fw_info['message'])
                                else:
                                    fw_info['message'] = '!-- Backup creation successful : ' + target
                                    log(fw_info['message'])
                            else:
                                fw_info['message'] = '!-- Backup creation failed  : ' + target
                                log(fw_info['message'])
                                # exit(2)
                        else:
                            pass
                            # if sw_backup=='bypass':
                            # log('!-- Backup skipped - doing firmware upload only : ' + target)
                        if options.sw_upload_fw:
                            for model, filename in firmware_set:
                                fw_info['model'] = config[context]['config']['fw_model']
                                if re.findall(r'' + model, fw_info['model']):
                                    firmware_file = filename
                                    fw_info[
                                        'message'] = '!-- Model matching RegEx ' + model + ' -- using firmware file : ' + filename
                                    log(fw_info['message'])
                                    break
                            if firmware_file:
                                fw_info['message'] = '!-- Uploading SonicWall firmware to device : ' + target
                                log(fw_info['message'])
                                sw_firmware = sw.upload_firmware(target, options.username, options.password,
                                                                 firmware_file)
                                if sw_firmware:
                                    if sw_firmware == True:
                                        fw_info['message'] = '!-- Firmware upload successful : ' + target
                                        log(fw_info['message'])
                                    elif sw_firmware == 'not_active':
                                        fw_info['message'] = '!-- Firmware skipped - not active appliance : ' + target
                                        log(fw_info['message'])
                                else:
                                    fw_info['message'] = '!-- Firmware upload failed : ' + target
                                    log(fw_info['message'])
                                    exit(1)
                            else:
                                fw_info['message'] = '!-- No firmware match for model : ' + fw_info[
                                    'model'] + ' : ' + target
                                log(fw_info['message'])
                                # fw_info['message']='!-- Firmware uploadeskipped  (no firmware file) : ' + target
                                # debug(fw_info['message'])
                    else:
                        fw_info['message'] = '!-- Skipping, current firmware is ' + fw_info['firmware'] + ' : ' + target
                        log(fw_info['message'])
                else:
                    fw_info['message'] = '!-- Skipping appliance on ROM version : ', fw_info['rom']
                    log(fw_info['message'])


            else:
                fw_info[
                    'message'] = '!-- ERROR!  No sonicwall configuration loaded - Password/Connectivity/Conversion issue : ' + target
                exit(3)
            break

        '''
        for key in fw_info:
            log(key+',', end='')
        log('')
        for key in fw_info:
            log(fw_info[key]+',', end='')
        log('')
        '''

    # else:
    #    log('ERROR: To use the --sw_upload_fw or -sw_backup options, you must specify the target ip using the -p option')


if options.sw_upload_fw or options.sw_backup:
    def run_parallel(targets, max_proc=48):
        from multiprocessing import Pool

        pool = Pool(processes=max_proc)
        pool.map(sw_firmware, targets)  # , chunksize=5)
        pool.close()


    #
    run_parallel(options.grouptargets)

if options.sw_failover:

    import requests
    import sonicwall as sw
    import re
    import json

    # host = options.sw_reboot
    # target_version = "6.5.4.8"  # Only upgrade firewalls not on 6.5.4.8
    # target_version = "6.1.1"

    if not options.web and (options.username == None or options.password == None):
        options.username, options.password = get_creds()

    for host in options.grouptargets:
        try:
            log('!-- Force failover requested for : ' + host)

            post_headers = defaultdict(dict)
            post_headers['Connection'] = 'Keep-Alive'
            post_headers[
                'User-Agent'] = 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.115 Safari/537.36'
            post_headers['Referer'] = 'https://' + host + '/haAdvancedConfig.html'
            post_headers['Origin'] = 'https://' + host
            post_headers['Accept'] = 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8'
            post_headers['Accept-Encoding'] = 'gzip, deflate, br'
            post_headers['Accept-Language'] = 'en-US,en;q=0.5'
            post_headers['Host'] = host
            post_headers['Upgrade-Insecure-Requests'] = '1'

            session = requests.Session()
            session.mount('https://' + host, sw.DESAdapter())

            response = sw.do_login(session, options.username, options.password, host,
                                   True)  ## need to be in config mode to request reboot

            # response=sw.get_url(session, 'https://' + host + '/getJsonData.json?_=1566657857&dataSet=alertStatus')
            # log(response.text)
            # resp_json=json.loads(response.text)
            # active=(resp_json['svrrpNodeState'].lower()=='active' or resp_json['svrrpHaMode'].lower()=='standalone')

            # if active:

            response = sw.get_url(session, 'https://' + host + '/haAdvancedConfig.html')
            csrf = re.findall(r'csrfToken.*"', response.text)[0].split('value=')[1].split('"')[1]

            # response=sw.get_url(session, 'https://' + host + '/systemStatusView.html', timeout=options.timeout_sw_webui)
            # systemStatusObjects=re.sub(r', ', ',', re.sub(r'\'', '', re.sub(r'.*systemStatusObject\((.*?)\);.*',r'\1', response.text, flags=re.DOTALL))).split(',')
            # firmwareversion=systemStatusObjects[5]
            # log('{},{}'.format(firmwareversion, target_version))

            # content=OrderedDict([('csrfToken', (None, csrf)), ('cgiaction', (None, 'None')), ('file', (None, 'Upload'))])
            content = {'csrfToken': csrf,
                       'cgiaction': 'forceHaFailover',
                       # 'cbox_diag': '',
                       # 'cbox_fwAutoUpdate': '',
                       # 'cbox_fwAutoDownload': '',
                       # 'cbox_fipsMode': '',
                       # 'cbox_ndppMode': ''
                       }

            command = 'https://' + host + '/main.cgi'  # ?csrfToken=' + csrf + '&cgiaction=none&file=upload&cbox_diag=&cbox_fwAutoUpdate=&cbox_fwAutoDownload=&cbox_fipsMode=&cbox_ndppMode='
            log('!-- Sending failover command')

            response = session.post(command, verify=False, data=content,
                                    timeout=options.timeout_sw_webui_post)  # , headers=post_headers)
            debug(response.text)
        except Exception as e:
            log(e)

if options.sw_reboot:

    import requests
    import sonicwall as sw
    import re
    import json

    # host = options.sw_reboot
    target_version = "6.5.4.8"  # Only upgrade firewalls not on 6.5.4.8
    # target_version = "6.1.1"

    if not options.web and (options.username == None or options.password == None):
        options.username, options.password = get_creds()

    for host in options.grouptargets:

        log('!-- Reboot with uploaded firmware requested for : ' + host)

        post_headers = defaultdict(dict)
        post_headers['Connection'] = 'Keep-Alive'
        post_headers[
            'User-Agent'] = 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.115 Safari/537.36'
        post_headers['Referer'] = 'https://' + host + '/systemSettingsView.html'
        post_headers['Origin'] = 'https://' + host
        post_headers['Accept'] = 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8'
        post_headers['Accept-Encoding'] = 'gzip, deflate, br'
        post_headers['Accept-Language'] = 'en-US,en;q=0.5'
        post_headers['Host'] = host
        post_headers['Upgrade-Insecure-Requests'] = '1'

        session = requests.Session()
        session.mount('https://' + host, sw.DESAdapter())

        response = sw.do_login(session, options.username, options.password, host,
                               True)  ## need to be in config mode to request reboot

        response = sw.get_url(session, 'https://' + host + '/getJsonData.json?_=1566657857&dataSet=alertStatus')
        # log(response.text)
        resp_json = json.loads(response.text)
        active = (resp_json['svrrpNodeState'].lower() == 'active' or resp_json['svrrpHaMode'].lower() == 'standalone')

        if active:
            response = sw.get_url(session, 'https://' + host + '/systemSettingsView.html')
            csrf = re.findall(r'csrfToken.*"', response.text)[0].split('value=')[1].split('"')[1]
            response = sw.get_url(session, 'https://' + host + '/systemStatusView.html',
                                  timeout=options.timeout_sw_webui)
            systemStatusObjects = re.sub(r', ', ',', re.sub(r'\'', '',
                                                            re.sub(r'.*systemStatusObject\((.*?)\);.*', r'\1',
                                                                   response.text, flags=re.DOTALL))).split(',')
            firmwareversion = systemStatusObjects[5]
            log('{},{}'.format(firmwareversion, target_version))
            if len(re.findall(target_version, firmwareversion)) == 0:
                # content=OrderedDict([('csrfToken', (None, csrf)), ('cgiaction', (None, 'None')), ('file', (None, 'Upload'))])
                content = {'csrfToken': csrf,
                           'cgiaction': 'none',
                           'file': 'upload',
                           'cbox_diag': '',
                           'cbox_fwAutoUpdate': '',
                           'cbox_fwAutoDownload': '',
                           'cbox_fipsMode': '',
                           'cbox_ndppMode': ''}

                command = 'https://' + host + '/boot.cgi'  # ?csrfToken=' + csrf + '&cgiaction=none&file=upload&cbox_diag=&cbox_fwAutoUpdate=&cbox_fwAutoDownload=&cbox_fipsMode=&cbox_ndppMode='
                log('!-- Sending reboot command')
                try:
                    response = session.post(command, verify=False, data=content,
                                            timeout=options.timeout_sw_webui_post)  # , headers=post_headers)
                    debug(response.text)
                except Exception as e:
                    log(e)
            else:
                log('!-- Skipping reboot request, already on {}'.format(target_version))
                exit(1)
        else:
            log('!-- Skipping reboot request - not active appliance : ' + host)
            exit(1)
        # print(command)
        # print(csrf)


def sw_audit(target):
    # print(target)
    import requests
    import sonicwall as sw
    import re

    # for context in config:
    #    if 'config' in config[context]:
    #        if config[context]['config']['fw_type']=='sonicwall':
    #            sw_context=context
    #            sw_version=config[context]['config']['version']
    #            break

    try:
        sw_version = 'Skipped'
        sw_context = 'Skipped'
        # if sw_context:
        # print(target, end=',')
        # print(sw_version, end=',')
        session = requests.Session()
        session.mount('https://' + target, sw.DESAdapter())
        response = sw.do_login(session, options.username, options.password, target, False,
                               timeout=options.timeout_sw_webui_login)
        # log('RESPONSE', response)
        if response:
            response = sw.get_url(session, 'https://' + target + '/systemSettingsView.html',
                                  timeout=options.timeout_sw_webui)
            if len(re.findall(r'Backup Settings were.*', response.text)) > 0:
                last_backup = re.sub(r'.*Backup Settings were created (.*?) (.*?) (.*?) (.*?) ([0-9]*).*',
                                     r'\1 \2 \3 \4 \5', response.text, flags=re.DOTALL)
                nobackup = False
            else:
                last_backup = 'No Backup'
                nobackup = True
            if len(re.findall(r'>Uploaded Firmware<.*', response.text)) > 0:
                uploaded_firmware = re.findall(r'SonicOS.*?<', re.findall(r'>Uploaded Firmware<.*', response.text)[0])[
                                        0][:-1]
                noimage = False
            elif len(re.findall(r'>Uploaded Firmware - <b>New!<.*', response.text)) > 0:
                uploaded_firmware = \
                re.findall(r'SonicOS.*?<', re.findall(r'>Uploaded Firmware - <b>New!<.*', response.text)[0])[0][:-1]
                noimage = False
            else:
                uploaded_firmware = 'No Uploaded Image'
                noimage = True
            response = sw.get_url(session, 'https://' + target + '/systemStatusView.html',
                                  timeout=options.timeout_sw_webui)
            systemStatusObjects = re.sub(r', ', ',', re.sub(r'\'', '',
                                                            re.sub(r'.*systemStatusObject\((.*?)\);.*', r'\1',
                                                                   response.text, flags=re.DOTALL))).split(',')
            # log(response.text)
            # log(systemStatusObjects)
            model = systemStatusObjects[0]
            serial = systemStatusObjects[2]
            firmwareversion = systemStatusObjects[5]
            sonicrom = systemStatusObjects[7]
            safemode = systemStatusObjects[8]
            systemtime = systemStatusObjects[13]
            uptime = systemStatusObjects[14]
            lastmodified = systemStatusObjects[19]

            # if len(systemStatusObjects) <35:
            #    print(sonicrom, end=',')
            #    print(safemode, end=',')
            print('{},{},{},{},{},{},OK'.format(target, firmwareversion, last_backup, uploaded_firmware, sonicrom,
                                                safemode))
            sw.do_logout(session, target)
            # print('OK', end='')
        # else:
        #    print(target,',Unknown,Unknown,Unknown,Unknown,Login Failed', end='')
        else:
            print('{},Unknown,Unknown,Unknown,Unknown,Unknown,Login Failed'.format(target))
        # print('')
        return
    except:
        print('{},Unknown,Unknown,Unknown,Unknown,Unknown,Exception - Login Failed'.format(target))

    # def sw_audit(target):
    #    print(target)


if options.sw_audit:
    def run_parallel(targets, max_proc=48):
        from multiprocessing import Pool

        pool = Pool(processes=max_proc)
        ##log('Starting Pool')
        pool.map(sw_audit, targets)  # , chunksize=5)
        # pool.wait(60)
        # log('Closing Pool')
        pool.close()


    #  Enhance these routines to allow user configurable options to be output.
    #  Support output of JSON, HTML, XML and CSV
    #  Get values from SNMP, config and HTML
    #  Update these routines to not use findall with indexes to avoid errors.
    #  Move other existing audit routines here

    # lastbackup, uploadedfirmware, SonicROM, SafeMode, firmwareversion, ha status
    # users, interface mgmt profile
    #
    #
    run_parallel(options.grouptargets)

if options.secureid:
    lastpolicy = {}
    hosts = {
        'ausulamgapp01.us.dell.com': '10.161.8.52',
        'ausulamgapp02.us.dell.com': '10.161.8.53',
        'ausplamgapp01.us.dell.com': '10.178.159.211',
        'ausplamgapp02.us.dell.com': '10.178.159.212',
        'ausplamgapp03.us.dell.com': '10.178.162.55',
        'ausplamgapp04.us.dell.com': '10.178.162.56'

    }
    ips = {
        '10.161.8.52': {'name': 'ausulamgapp01.us.dell.com', 'new': True},
        '10.161.8.53': {'name': 'ausulamgapp02.us.dell.com', 'new': True},
        '10.178.159.211': {'name': 'ausplamgapp01.us.dell.com', 'new': True},
        '10.178.159.212': {'name': 'ausplamgapp02.us.dell.com', 'new': True},
        '10.178.162.55': {'name': 'ausplamgapp03.us.dell.com', 'new': True},
        '10.178.162.56': {'name': 'ausplamgapp04.us.dell.com', 'new': True}
    }

    services = ['tcp/5500', 'udp/5500']
    ## make service additions flexible

    group_name = 'SecureID_servers'
    exec_fw_command('', 'sonicwall', [('create_address',
                                       {'addressname': group_name, 'addresstype': '8', 'zone': 'LAN', 'color': 'green',
                                        'members': [], 'comments': 'CHG0183856/RITM3158515/TASK5367017'})],
                    syntax='cli')
    # exec_fw_command('10.215.16.60', 'sonicwall', [('create_address', {'addressname': 'test_host', 'ip1': '10.10.10.10', 'ip2' : '255.255.255.255', 'addresstype': '1', 'zone': 'LAN', 'color': 'black'})], syntax='webui')

    '''
    log('create network_object_group ' + group_name)
    log('modify network_objects ' + group_name + ' comments "CHG0183856/RITM3158515/TASK5367017"')             
    log('modify network_objects ' + group_name + ' color ' + 'green')
    '''

    # ['svcObjId', 'svcObjType', 'svcObjProperties', 'svcObjIpType', 'svcObjPort1', 'svcObjPort2', 'svcObjManagement', 'svcObjHigherPrecedence', 'svcObjComment']

    udp_service = None
    tcp_service = None

    for context in contexts:
        for service in config[context]['services']:
            if config[context]['services'][service]['svcObjType'] == '1':  ## Service Object
                if config[context]['services'][service]['svcObjIpType'] == '6' and config[context]['services'][service][
                    'svcObjPort1'] == '5500' and config[context]['services'][service]['svcObjPort2'] == '5500':
                    tcp_service = config[context]['services'][service]['svcObjId']
                if config[context]['services'][service]['svcObjIpType'] == '17' and \
                        config[context]['services'][service]['svcObjPort1'] == '5500' and \
                        config[context]['services'][service]['svcObjPort2'] == '5500':
                    udp_service = config[context]['services'][service]['svcObjId']
                if tcp_service and udp_service:
                    break  # udp and tcp service found, exit loop
        for ip in ips:
            while ips[ip]['name'].lower() in [x.lower() for x in config[context]['addresses']]:
                ips[ip]['name'] = ips[ip]['name'] + '-new'
        for address in config[context]['addresses']:
            for ip in ips:
                if config[context]['addresses'][address]['addrObjType'] == '1':  # address is a host

                    if config[context]['addresses'][address]['addrObjIp1'] == ip:
                        # print('Address object with this IP exists, using : ' + config[context]['addresses'][address]['addrObjId'])
                        ips[ip]['name'] = config[context]['addresses'][address]['addrObjId']
                        ips[ip]['new'] = False
                        break

    service_name = 'SecureID'

    for ip in ips:
        if ips[ip]['new']:
            exec_fw_command('', 'checkpoint', [('create_address',
                                                {'addressname': ips[ip]['name'], 'ip1': ip, 'ip2': '255.255.255.255',
                                                 'addresstype': 'host',
                                                 'comment': 'comments "CHG0183856/RITM3158515/TASK5367017"',
                                                 'zone': 'LAN', 'color': 'green'})], syntax='cli')
            # log('create host_plain ' + ips[ip]['name'])
            # log('modify network_objects ' + ips[ip]['name'] + ' ipaddr ' + ip)
            # log('modify network_objects ' + ips[ip]['name'] + ' comments "CHG0183856/RITM3158515/TASK5367017"')
            # log('modify network_objects ' + ips[ip]['name'] + ' color ' + 'green')
            # log('update_all')
        exec_fw_command('', 'checkpoint', [
            ('modify_address', {'addressname': group_name, 'members': [ips[ip]['name']], 'action': 'addmembers'})],
                        syntax='cli')
        # log('addelement network_objects ' + group_name + ' \'\' network_objects:' + ips[ip]['name'])

    policy_len = {}
    for context in contexts:
        for policy in config[context]['policies']:  # get last policy number
            if config[context]['policies'][policy]['policyName'] not in policy_len and context != 'shared':
                policy_len[config[context]['policies'][policy]['policyName']] = config[context]['config']['policylen'][
                    config[context]['policies'][policy]['policyName']]

    for policy in policy_len:
        indexstr = policy_len[policy]
        exec_fw_command('', 'checkpoint', [('create_rule', {'policyname': policy,
                                                            'comment': 'comments "CHG0183856/RITM3158515/TASK5367017"',
                                                            'policynum': indexstr, 'sources': ['Any'],
                                                            'dests': [group_name],
                                                            'services': [tcp_service, udp_service],
                                                            'polaction': 'allow'})], syntax='cli')
        '''
        log('addelement fw_policies ' + policy + ' rule security_rule')
        log('modify fw_policies ' + policy + ' rule:' + indexstr + ':comments "CHG0183856/RITM3158515/TASK5367017"')
        log('modify fw_policies ' + policy + ' rule:' + indexstr + ':disabled false')
        log('addelement fw_policies ' + policy + ' rule:' + indexstr + ':action accept_action:accept')
        log("addelement fw_policies " + policy + " rule:" + indexstr + ":src:'' globals:" + 'Any')
        log("addelement fw_policies " + policy + " rule:" + indexstr + ":dst:'' network_objects:" + group_name)
        log("addelement fw_policies " + policy + " rule:" + indexstr + ":services:'' services:" + tcp_service)
        log("addelement fw_policies " + policy + " rule:" + indexstr + ":services:'' services:" + udp_service)
        '''
    log('update_all')

# options.groupfind=True

# if options.groupfind:

# options.groupmaster=False


# def modify_address_obj() - move modifcations of address objects here.


if options.groupmaster:
    ## a condition exists where adding addresses to a subgroup may fail:
    ## example
    ## group1 contains subgroup1 and subgroup2, which contains addresses 1.1.1.1 and 2.2.2.2, respectively.
    ## group2 contains subgroup1 and subgroup3, which contains addresses 1.1.1.1 and 3.3.3.3, respectively.

    ## issue 1: if a new subgroup is added, to contain the address 3.3.3.3 it will create the subgroup and it will work for group1, but then the subgroup can not be added for group2 since it will overlap
    ## issue 2: if the address 2.2.2.2 is the new address to be added, it will not be added to the subgroup when processing group 1.  if other address additions are created so that a subgroup is created, then it can not be added to group2 as it will overlap
    ## if there are no other addresses added, the subgroup will be processed when handling group2.  if there are no issues the subgroup will then be created, but only added for group2.
    ## this will be an issue if group memberships somehow get out of sync due to inconsistent manual manipulation of the groups. the proper way to handle this will likely to do a check upfront of all the possible overlap issues first

    ## will the above be fixed by just reloading the config for each master group? (or adding the config items to the dictionary)

    import re
    import ipaddress
    import sonicwall as sw
    from netaddr import IPSet, IPRange, IPNetwork

    # import time

    # options.grouptargets=['10.215.16.60']
    # options.groupaddresses=['1.1.1.1', '2.2.2.0/32', '1.2.3.0/23', '2.2.2.2/33', '3.3.3.0/2/3', 'a.b.c.d/24', '10.2.3.4/32', '10.2.3.0/24', '1.1.1.0/24']
    # options.groupmaster=['CSIRT_GROUP']
    # options.username='admin'
    # options.password='snowflake'
    # options.groupusemaster=False
    ## validate target IPs
    ## validate addresses to add

    ## get sonicwall config

    ## addresses should contain subgroup name, rather than master name, as subgroup will not always be unique
    ## address creation should be skipped is the subgroup was already processed.

    for target in options.grouptargets:
        subgroupcreated = False
        if not options.web and (options.username == None or options.password == None):
            options.username, options.password = get_creds()
        tmpconfig = None
        cmds = []
        if target == 'checkpoint':
            fw_type = 'checkpoint'
        else:
            fw_type = get_fw_type(target)
            log('!-- Firewall detection : {}'.format(fw_type))
            if fw_type == 'sonicwall':
                config = get_sonicwall_exp(target)
                '''
                exp_config=get_sw_config_https(target, None, options.username, options.password)
                if exp_config: 
                    memory_config=convert_exp_file('', None, exp_config.encode())
                    exp_config=None # free up memory 
                    if memory_config: 
                        tmpconfig=load_sonicwall('', True, memory_config)
                        memory_config=None  # free up memory

                if tmpconfig:
                    tmpcontext=tmpconfig['config']['name']
                    config[tmpcontext] = tmpconfig
                    if not options.context:
                        options.context = [tmpcontext]
                    for context in options.context:
                        contexts.append(context)
                    tmpconfig=None  # free up memory
                '''
                ## set up session for config changes

                session = requests.Session()
                session.mount('https://' + target, sw.DESAdapter())
                response = sw.do_login(session, options.username, options.password, target, True)

            context = list(config)[0]

            if response:
                ## address objects ARE CASE SENSITIVE

                ## make sure master group exists
                ## get zone used in first master group object (sonicwall only)
                ## for each address:
                # if address is already contained within the master group, if so, skip it
                # determine if address object already exists, if so, use it, else create a new one.
                # add existing object or new object name to list

                ## determine name of subgroup
                ## create subgroup with members of address object list
                ## add subgroup to master group

                ## make sure none of the groupaddresses are dupes or overlaps
                addedsubgroups = []
                for groupmaster in options.groupmaster:  # split groupmaster into master group and subgroup
                    try:
                        groupmaster, subgroupname = groupmaster.split(',')
                    except:
                        subgroupname = None
                    ## should i reload the config for each groupmaster object to get updated objects?

                    if groupmaster in config[context]['addresses']:
                        mastermembers = expand_address(config[context]['addresses'], groupmaster,
                                                       config[context]['addressmappings'])
                        if len(mastermembers) > 0:
                            addresszone = config[context]['addresses'][mastermembers[0]]['addrObjZone']
                            log('!-- Using master group {} which includes an address object in zone {}'.format(
                                groupmaster, addresszone))
                            subgroupindex = 1
                            if subgroupname == None:
                                subgroupname = groupmaster
                            while subgroupname + '-' + str(subgroupindex) in config[context]['addresses']:
                                subgroupindex += 1
                            subgroupname = subgroupname + '-' + str(subgroupindex)
                            if options.groupusemaster:
                                log('!-- Using master group name : {}'.format(groupmaster))
                            else:
                                log('!-- Using subgroup name : {}'.format(subgroupname))

                            addresslist = []
                            addipset = IPSet([])
                            for address in options.groupaddresses:
                                badaddress = False
                                if len(re.findall('/', address)) == 1:
                                    network, mask = address.split('/')
                                elif len(re.findall('-', address)) == 1:  # address object is a range
                                    # log('range found')
                                    network, mask = address.split('-')
                                elif len(re.findall('/', address)) == 0:
                                    network = address
                                    mask = '32'
                                else:
                                    log('!-- Skipping {} - Invalid netmask'.format(address))
                                    badaddress = True
                                if not badaddress:
                                    try:
                                        tmpaddr = ipaddress.IPv4Network(network + '/' + str(mask))
                                        tmpaddr = IPNetwork(network + '/' + str(mask))
                                    except Exception as e:
                                        try:
                                            log(network, mask)
                                            tmpaddr = IPRange(network, mask)
                                        except:
                                            log('!-- Skipping {} - {}'.format(address, e))
                                            badaddress = True
                                if not badaddress:
                                    # if len(IPSet([network+'/'+str(mask)]) & config[context]['addresses'][groupmaster]['IPSet'])==0:
                                    if len(IPSet(list(tmpaddr)) & config[context]['addresses'][groupmaster][
                                        'IPSet']) == 0:
                                        # log(network)
                                        # if len(IPSet([network+'/'+str(mask)]) & addipset)==0:
                                        if len(IPSet(list(tmpaddr)) & addipset) == 0:
                                            addresslist.append((network, mask))
                                            # addipset.add(network+'/'+str(mask))
                                            # log(tmpaddr)
                                            addipset.add(tmpaddr)
                                        else:
                                            log('!-- Skipping {} - Overlaps with another new address - Target: {}'.format(
                                                address, target))
                                    else:
                                        log('!-- Skipping {} - Overlaps with existing group member - Target: {}'.format(
                                            address, target))

                            # for network,mask in addresslist:
                            #    print('{}-{}-{}'.format(groupmaster,network,mask))
                            # exit(1)

                            if subgroupname not in addedsubgroups:
                                for network, mask in addresslist:
                                    if mask == '32':
                                        addresstype = '1'  ## host
                                        ip2 = '255.255.255.255'
                                    elif len(re.findall('.', mask)) > 1:
                                        addresstype = '2'  ## range
                                        ip2 = mask
                                    else:
                                        addresstype = '4'  ## network
                                        ip2 = cidr_to_netmask(mask)
                                    addressname = '{}-{}-{}'.format(subgroupname, network, mask)
                                    index = 1
                                    while addressname in config[context]['addresses']:
                                        addressname = '{}-{}-{}--{}'.format(subgroupname, network, mask, index)
                                    ## create new address object

                                    postdata = {'addrObjId_-1': addressname,
                                                'addrObjType_-1': addresstype,
                                                'addrObjZone_-1': addresszone,
                                                'addrObjProperties_-1': '14',
                                                'addrObjIp1_-1': network,
                                                'addrObjIp2_-1': ip2
                                                }
                                    cmddata = {'cmdtype': 'create_address',
                                               'target': target,
                                               'name': addressname,
                                               'type': addresstype,
                                               'zone': addresszone,
                                               'props': 14,
                                               'ip1': network,
                                               'ip2': ip2,
                                               'context': context,
                                               'fw_type': fw_type,
                                               'syntax': 'webui'
                                               }
                                    # log(postdata)
                                    url = 'https://' + target + '/main.cgi'
                                    # response = session.post(url, verify=False, data = postdata, headers=get_headers, stream=True, timeout=options.timeout_sw_webui_post)
                                    cmds.append(cmddata)
                                    response = session.post(url, verify=False, data=postdata, stream=True,
                                                            timeout=options.timeout_sw_webui_post)
                                    status = re.findall(r'<span class="message.*', response.text)
                                    if len(status) == 1:
                                        statusmsg = re.sub(r'.*nowrap>(.*?)&nbsp.*', r'\1', status[0])
                                        if 'has been updated' in statusmsg:
                                            log('!-- Address object created : {}'.format(addressname))
                                        else:
                                            log('!-- Address object creation failed : {} - {}'.format(addressname,
                                                                                                      statusmsg))

                                    ## add object to subgroup
                                    if not subgroupcreated and not options.groupusemaster:
                                        subgroupcreated = True
                                        postdata = {'addrObjId_-1': subgroupname,
                                                    'addrObjType_-1': '8',
                                                    'addrObjZone_-1': '',
                                                    'addrObjProperties_-1': '14',
                                                    'addrObjIp1_-1': '0.0.0.0',
                                                    'addrObjIp2_-1': '0.0.0.0'
                                                    }
                                        cmddata = {'cmdtype': 'create_group',
                                                   'target': target,
                                                   'name': subgroupname,
                                                   'type': '8',
                                                   'zone': '',
                                                   'props': 14,
                                                   'ip1': '0.0.0.0',
                                                   'ip2': '0.0.0.0',
                                                   'context': context,
                                                   'fw_type': fw_type,
                                                   'syntax': 'webui'
                                                   }
                                        cmds.append(cmddata)
                                        response = session.post(url, verify=False, data=postdata, stream=True,
                                                                timeout=options.timeout_sw_webui_post)
                                        status = re.findall(r'<span class="message.*', response.text)
                                        if len(status) == 1:
                                            statusmsg = re.sub(r'.*nowrap>(.*?)&nbsp.*', r'\1', status[0])
                                        if 'has been updated' in statusmsg:
                                            log('!-- Subgroup object created : {}'.format(subgroupname))
                                        else:
                                            log('!-- Subgroup object creation failed : {} - {}'.format(subgroupname,
                                                                                                       statusmsg))
                                        ## add subgroup to master group
                                        postdata = {'addro_atomToGrp_0': subgroupname,
                                                    'addro_grpToGrp_0': groupmaster
                                                    }
                                        cmddata = {'cmdtype': 'modify_address',
                                                   'target': target,
                                                   'name': groupmaster,
                                                   'member': [(subgroupname, 'addmember')],
                                                   'context': context,
                                                   'fw_type': fw_type,
                                                   'syntax': 'webui'
                                                   }
                                        url = 'https://' + target + '/main.cgi'
                                        cmds.append(cmddata)
                                        response = session.post(url, verify=False, data=postdata, stream=True,
                                                                timeout=options.timeout_sw_webui_post)
                                        status = re.findall(r'<span class="message.*', response.text)
                                        if len(status) == 1:
                                            statusmsg = re.sub(r'.*nowrap>(.*?)&nbsp.*', r'\1', status[0])
                                        if 'has been updated' in statusmsg:
                                            log('!-- Subgroup {} added to master group {}'.format(subgroupname,
                                                                                                  groupmaster))
                                            addedsubgroups.append(groupmaster)
                                        else:
                                            log('!-- Subgroup {} addition to master group {} failed - {}'.format(
                                                subgroupname, groupmaster, statusmsg))
                                            addedsubgroups.append(subgroupname)

                                    if options.groupusemaster:
                                        postdata = {'addro_atomToGrp_0': addressname,
                                                    'addro_grpToGrp_0': groupmaster
                                                    }
                                        cmddata = {'cmdtype': 'modify_address',
                                                   'target': target,
                                                   'name': groupmaster,
                                                   'member': [(addressname, 'addmember')],
                                                   'context': context,
                                                   'fw_type': fw_type,
                                                   'syntax': 'webui'
                                                   }
                                    else:
                                        postdata = {'addro_atomToGrp_0': addressname,
                                                    'addro_grpToGrp_0': subgroupname
                                                    }
                                        cmddata = {'cmdtype': 'modify_address',
                                                   'target': target,
                                                   'name': subgroupname,
                                                   'member': [(addressname, 'addmember')],
                                                   'context': context,
                                                   'fw_type': fw_type,
                                                   'syntax': 'webui'
                                                   }
                                    cmds.append(cmddata)
                                    response = session.post(url, verify=False, data=postdata, stream=True,
                                                            timeout=options.timeout_sw_webui_post)
                                    status = re.findall(r'<span class="message.*', response.text)
                                    if len(status) == 1:
                                        statusmsg = re.sub(r'.*nowrap>(.*?)&nbsp.*', r'\1', status[0])
                                    if 'has been updated' in statusmsg:
                                        if options.groupusemaster:
                                            log('!-- Address {} added to master group {}'.format(addressname,
                                                                                                 groupmaster))
                                        else:
                                            log('!-- Address {} added to subgroup {}'.format(addressname, subgroupname))
                                    else:
                                        if options.groupusemaster:
                                            log('!-- Address {} addition to master group {} failed - {}'.format(
                                                addressname, groupmaster, statusmsg))
                                        else:
                                            log('!-- Address {} addition to subgroup {} failed - {}'.format(addressname,
                                                                                                            subgroupname,
                                                                                                            statusmsg))
                            else:
                                log('!-- Group {} already created - Skipping - Target: {}'.format(subgroupname, target))
                        else:
                            log('!-- Master Group {} has no existing members - zone cannot be determined - Target: {}'.format(
                                groupmaster, target))
                        # break
                    else:
                        log('!-- Master group {} does not exist - Skipping - Target: {}'.format(groupmaster, target))
                # for cmd in cmds:
                # log(cmd)
                # exec_fw_command([cmd])
                else:
                    log('!-- Login Failed - Unable to make changes to target : Target: {}'.format(target))
            else:
                log('!-- Unable to load configuration : Target: {}'.format(target))

        # if fw_type=='sonicwall':

'''
# find policies where the source is also in the dest

from urllib.parse import quote as url_quote, unquote as url_unquote

for context in contexts:
    print(context)
    for policy in config[context]['policies']:
        if 'policyEnabled' in config[context]['policies'][policy]:
            if config[context]['policies'][policy]['policyEnabled'] == '1' and config[context]['policies'][policy]['policyAction'] == '2':
                policymatches=0
                for source in config[context]['policies'][policy]['policySrcNet']:
                    checkdest=False
                    if source in config[context]['addresses']:
                        if config[context]['addresses'][source]['addrObjType']!='1':
                            checkdest=True
                    elif source=='Any':
                        checkdest=True
                    match=False
                    if checkdest:
                        for dest in config[context]['policies'][policy]['policyDstNet']:
                            if source==dest:
                                match=True
                                policymatches+=1
                                break
                        if match==True:
                            break
                if match==True:
                    source_addr = config[context]['policies'][policy]['policySrcNet']
                    dest_addr = config[context]['policies'][policy]['policyDstNet']
                    dest_service = config[context]['policies'][policy]['policyDstSvc']
                    if 'policyEnabled' not in config[context]['policies'][policy]:
                        print (config[context]['policies'][policy])
                    if config[context]['policies'][policy]['policyEnabled'] == '0':
                        enabled = "."
                    elif config[context]['policies'][policy]['policyEnabled'] == '1':
                        if not options.web:
                            enabled = u'\u2713' 
                        else:            
                            enabled = 'Y'
                    if config[context]['policies'][policy]['policyAction'] == '0':
                        action = 'deny'
                    elif config[context]['policies'][policy]['policyAction'] == '1':
                        action ='discard'
                    elif config[context]['policies'][policy]['policyAction'] == '2':
                        action='allow'
                    name=config[context]['policies'][policy]['policyName']

                    if config[context]['policies'][policy]['policySrcZone'] == []:
                        source_zone = ['any']
                    else:
                        source_zone = config[context]['policies'][policy]['policySrcZone']
                    
                    if config[context]['policies'][policy]['policyDstZone'] == []:
                        dest_zone = ['any']
                    else:
                        dest_zone = config[context]['policies'][policy]['policyDstZone']
                    if policymatches==1:  
                        if config[context]['config']['fw_type']=='checkpoint':
                            log ('{:2.2s} {:8.8s} {:15.15s} {:30.30s} {:7.7s} {:40.40s} {:40.40s} {:40.40s}'.format('En', 'Action', 'CMA', 'Policy Name', 'Rule #', 'Source Address', 'Destination Address', 'Service'))
                        else:
                            log ('{:2.2s} {:8.8s} {:30.30s} {:20.20s} {:20.20s} {:40.40s} {:40.40s} {:40.40s}'.format('En', 'Action', 'Rule Name', 'Source Zone', 'Destination Zone', 'Source Address', 'Destination Address', 'Service'))
                    log ('=' * 200)
                    if config[context]['config']['fw_type']=='checkpoint':
                        log ('{:2.2s} {:8.8s} {:15.15s} {:30.30s} {:7.7s} {:40.40s} {:40.40s} {:40.40s}'.format(enabled, action, context, url_unquote(name), str(config[context]['policies'][policy]['policyUiNum']),  url_unquote(source_addr[0]), url_unquote(dest_addr[0]), url_unquote(dest_service[0])))
                    else:
                        log ('{:2.2s} {:8.8s} {:30.30s} {:20.20s} {:20.20s} {:40.40s} {:40.40s} {:40.40s}'.format(enabled, action, url_unquote(name), url_unquote(source_zone[0]), url_unquote(dest_zone[0]), url_unquote(source_addr[0]), url_unquote(dest_addr[0]), url_unquote(dest_service[0])))
                    longestval = max(len(source_addr), len(dest_addr), len(dest_service))
                    if longestval>1:
                        for index in range(1, longestval):
                            tmpsrc=''
                            tmpdst=''
                            tmpsvc=''
                            if index < len(source_addr):
                                tmpsrc=source_addr[index]
                            if index < len(dest_addr):
                                tmpdst=dest_addr[index]
                            if index < len(dest_service):
                                tmpsvc=dest_service[index]
                            if config[context]['config']['fw_type']=='checkpoint':
                                log ('{:2.2s} {:8.8s} {:15.15s} {:30.30s} {:7.7s} {:40.40s} {:40.40s} {:40.40s}'.format('', '', '', '', '', url_unquote(tmpsrc), url_unquote(tmpdst), url_unquote(tmpsvc)))
                            else:
                                log ('{:2.2s} {:8.8s} {:30.30s} {:20.20s} {:20.20s} {:40.40s} {:40.40s} {:40.40s}'.format('', '', '', '', '', url_unquote(tmpsrc), url_unquote(tmpdst), url_unquote(tmpsvc)))
                    log ('-' * 200)
                    #print('Match Found')
'''

# cip_audit(options.cipaudit)

'''
for context in config:
    if context.lower()!='shared':
        for index, name in enumerate(config[context]['addresses']):
            print('{:5.5s} {:60.60s}'.format(str(index + 1 ), name))
        for index, name in enumerate(config[context]['services']):
            print('{:5.5s} {:60.60s}'.format(str(index + 1 ), name))
        print(list(config[context]['services'].keys())[216])

for context in config:
    for rule in config[context]['policies']:
        print(config[context]['policies'][rule]['policyName'])
'''
'''
for context in config:
    for address in config[context]['addresses']:
        if config[context]['addresses'][address]['addrObjType']=='2':
            #print(config[context]['addresses'][address]['addrObjIp2'][0:4])
            if config[context]['addresses'][address]['addrObjIp2'][0:4]=='255.':
                print('Bad Address Range')
                print(config[context]['addresses'][address])
'''

# print(logging.DEBUG, logging.INFO, logging.NONE, logging.ERROR, logging.WARNING, logging.NOTICE)
# print (dir(logging))


if options.web:
    set_web_tab('')  # close out the last tab elements such as textarea, div and add the download button
    sys.stdout.write('\r\n')
    sys.stdout.write('0\r\n')
    sys.stdout.write('\r\n')
# for context in contexts:
# print(context)
# iplist=['10.215.18.81', '10.215.18.77', '10.215.18.78', '10.211.129.80', '10.215.19.132', '10.215.19.140', '10.215.19.133', '10.215.16.60', '10.215.18.177', '10.215.18.180']


# for ip in iplist:
# print (ip, end=' : ')
# print (get_fw_type(ip))

# exec_fw_command('1.1.1.1', 'sonicwall', (('create_address', {'addressname': 'testing', 'ip1': '10.10.10.10', 'ip2' : '255.255.255.255', 'addresstype': '1'})), syntax='cli')


## testing
## create address
## modify address
## create address
## delete address

## create address group
## modify address group
## create address group
## delete address group

## create rule
## modify rule - comment?
## create rule
## delete rule


## sonicwall testing
'''
print('sonicwall web')
print(exec_fw_command('10.215.16.60', 'sonicwall', [('create_address', {'addressname': 'test_host', 'ip1': '10.10.10.10', 'ip2' : '255.255.255.255', 'addresstype': '1', 'zone': 'LAN', 'color': 'black'})], syntax='webui'))
print(exec_fw_command('10.215.16.60', 'sonicwall', [('create_address', {'addressname': 'test_host_delete', 'ip1': '10.10.10.10', 'ip2' : '255.255.255.255', 'addresstype': '1', 'zone': 'LAN', 'color': 'black'})], syntax='webui'))

print(exec_fw_command('10.215.16.60', 'sonicwall', [('create_address', {'addressname': 'test_group', 'addresstype': '8', 'zone': 'LAN', 'color': 'black', 'members': ['test_host']})], syntax='webui'))
print(exec_fw_command('10.215.16.60', 'sonicwall', [('create_address', {'addressname': 'test_group_delete', 'addresstype': '8', 'zone': 'LAN', 'color': 'black', 'members': ['test_host_delete']})], syntax='webui'))

print(exec_fw_command('10.215.16.60', 'sonicwall', [('create_rule', {                     'polaction': '1', 'srczone': 'LAN', 'dstzone': 'WAN', 'sources': ['JeffGroup'], 'dests': ['Dst_Extbar'], 'services': ['NFS'], 'comment': 'testing'})], syntax='webui'))
print(exec_fw_command('10.215.16.60', 'sonicwall', [('modify_rule', {'action': 'delete', 'polaction': '1', 'srczone': 'LAN', 'dstzone': 'WAN', 'sources': ['JeffGroup'], 'dests': ['Dst_Extbar'], 'services': ['NFS'], 'comment': 'testing'})], syntax='webui'))

print(exec_fw_command('10.215.16.60', 'sonicwall', [('modify_address', {'action': 'delete', 'addressname': 'test_host_delete', 'addresstype': '8', 'zone': 'LAN', 'color': 'black', 'members': ['test_host']})], syntax='webui'))
print(exec_fw_command('10.215.16.60', 'sonicwall', [('modify_address', {'action': 'delete', 'addressname': 'test_group_delete', 'addresstype': '8', 'zone': 'LAN', 'color': 'black', 'members': ['test_host']})], syntax='webui'))

## unable to modify sonicwall rules via web
#print(exec_fw_command('10.215.16.60', 'sonicwall', [('modify_rule', {'action': 'disable', 'polaction': '1', 'srczone': 'LAN', 'dstzone': 'WAN', 'source': 'JeffGroup', 'dest': 'Dst_Extbar', 'service': 'NFS', 'comment': 'modified'})], syntax='webui'))
#print(exec_fw_command('10.215.16.60', 'sonicwall', [('modify_rule', {'action': 'disable', 'polaction': '1', 'srczone': 'LAN', 'dstzone': 'WAN', 'source': 'JeffGroup', 'dest': 'Dst_Extbar', 'service': 'NFS', 'comment': 'testing'})], syntax='webui'))



print('sonicwall cli')
exec_fw_command('10.215.16.60', 'sonicwall', [('create_address', {'addressname': 'test_host', 'ip1': '10.10.10.10', 'ip2' : '255.255.255.255', 'addresstype': '1', 'zone': 'LAN', 'color': 'black'})], syntax='cli')
exec_fw_command('10.215.16.60', 'sonicwall', [('create_address', {'addressname': 'test_host_delete', 'ip1': '10.10.10.10', 'ip2' : '255.255.255.255', 'addresstype': '1', 'zone': 'LAN', 'color': 'black'})], syntax='cli')

exec_fw_command('10.215.16.60', 'sonicwall', [('create_address', {'addressname': 'test_group', 'addresstype': '8', 'zone': 'LAN', 'color': 'black', 'members': ['test_host']})], syntax='cli')
exec_fw_command('10.215.16.60', 'sonicwall', [('create_address', {'addressname': 'test_group_delete', 'addresstype': '8', 'zone': 'LAN', 'color': 'black', 'members': ['test_host_delete']})], syntax='cli')

exec_fw_command('10.215.16.60', 'sonicwall', [('create_rule', {                     'polaction': '1', 'srczone': 'LAN', 'dstzone': 'WAN', 'sources': ['JeffGroup'], 'dests': ['Dst_Extbar'], 'services': ['NFS'], 'comment': 'testing'})], syntax='cli')
exec_fw_command('10.215.16.60', 'sonicwall', [('modify_rule', {'action': 'disable', 'polaction': '1', 'srczone': 'LAN', 'dstzone': 'WAN', 'sources': ['JeffGroup'], 'dests': ['Dst_Extbar'], 'services': ['NFS'], 'comment': 'testing'})], syntax='cli')
exec_fw_command('10.215.16.60', 'sonicwall', [('modify_rule', {'action': 'delete', 'polaction': '1', 'srczone': 'LAN', 'dstzone': 'WAN', 'sources': ['JeffGroup'], 'dests': ['Dst_Extbar'], 'services': ['NFS'], 'comment': 'testing'})], syntax='cli')

exec_fw_command('10.215.16.60', 'sonicwall', [('modify_address', {'action': 'delete', 'addressname': 'test_host_delete', 'addresstype': '8', 'zone': 'LAN', 'color': 'black', 'members': ['test_host']})], syntax='cli')
exec_fw_command('10.215.16.60', 'sonicwall', [('modify_address', {'action': 'delete', 'addressname': 'test_group_delete', 'addresstype': '8', 'zone': 'LAN', 'color': 'black', 'members': ['test_host']})], syntax='cli')



## checkpoint testing

print('checkpoint cli')
exec_fw_command('10.215.16.60', 'checkpoint', [('create_address', {'addressname': 'test_host', 'ip1': '10.10.10.10', 'ip2' : '255.255.255.255', 'addresstype': '1', 'zone': 'LAN', 'color': 'black'})], syntax='cli')
exec_fw_command('10.215.16.60', 'checkpoint', [('create_address', {'addressname': 'test_host_delete', 'ip1': '10.10.10.10', 'ip2' : '255.255.255.255', 'addresstype': '1', 'zone': 'LAN', 'color': 'black'})], syntax='cli')

exec_fw_command('10.215.16.60', 'checkpoint', [('create_address', {'addressname': 'test_group', 'addresstype': '8', 'zone': 'LAN', 'color': 'black', 'members': ['test_host']})], syntax='cli')
exec_fw_command('10.215.16.60', 'checkpoint', [('create_address', {'addressname': 'test_group_delete', 'addresstype': '8', 'zone': 'LAN', 'color': 'black', 'members': ['test_host_delete']})], syntax='cli')

exec_fw_command('10.215.16.60', 'checkpoint', [('create_rule', {'policyname': 'test_policy', 'polaction': '1', 'policynum': '1', 'srczone': 'LAN', 'dstzone': 'WAN', 'sources': ['JeffGroup'], 'dests': ['Dst_Extbar'], 'services': ['NFS'], 'comment': 'testing'})], syntax='cli')
exec_fw_command('10.215.16.60', 'checkpoint', [('modify_rule', {'action': 'disable', 'policyname': 'test_policy', 'polaction': '1', 'policynum': '1', 'srczone': 'LAN', 'dstzone': 'WAN', 'sources': ['JeffGroup'], 'dests': ['Dst_Extbar'], 'services': ['NFS'], 'comment': 'testing'})], syntax='cli')
exec_fw_command('10.215.16.60', 'checkpoint', [('modify_rule', {'action': 'delete', 'policyname': 'test_policy', 'polaction': '1', 'policynum': '1', 'srczone': 'LAN', 'dstzone': 'WAN', 'sources': ['JeffGroup'], 'dests': ['Dst_Extbar'], 'services': ['NFS'], 'comment': 'testing'})], syntax='cli')

exec_fw_command('10.215.16.60', 'checkpoint', [('modify_address', {'action': 'delete', 'addressname': 'test_host_delete', 'addresstype': '8', 'zone': 'LAN', 'color': 'black', 'members': ['test_host']})], syntax='cli')
exec_fw_command('10.215.16.60', 'checkpoint', [('modify_address', {'action': 'delete', 'addressname': 'test_group_delete', 'addresstype': '8', 'zone': 'LAN', 'color': 'black', 'members': ['test_host']})], syntax='cli')

'''

## panorama API testing

# options.password='admin'
# print(exec_fw_command('10.215.18.25', 'palo', [('create_address', {'addressname': 'test_host', 'ip1': '10.10.10.10', 'ip2' : '255.255.255.255', 'addresstype': '1', 'zone': 'LAN', 'color': 'black'})], syntax='webui'))
'''
print('PANO API')
print(exec_fw_command('10.215.19.132', 'pano', [('create_address', {'addressname': 'test_host', 'ip1': '10.10.10.10', 'ip2' : '255.255.255.255', 'addresstype': '1', 'zone': 'LAN', 'color': 'black', 'members': ['test_host'], 'context': 'shared'})], syntax='webui'))
print(exec_fw_command('10.215.19.132', 'pano', [('create_address', {'addressname': 'test_group', 'ip1': '10.10.10.10', 'ip2' : '255.255.255.255', 'addresstype': '8', 'zone': 'LAN', 'color': 'black', 'members': ['test_host'], 'context': 'shared'})], syntax='webui'))
print(exec_fw_command('10.215.19.132', 'pano', [('modify_address', {'action': 'delete', 'addressname': 'test_group', 'ip1': '10.10.10.10', 'ip2' : '255.255.255.255', 'addresstype': '8', 'zone': 'LAN', 'color': 'black', 'members': ['test_host'], 'context': 'shared'})], syntax='webui'))

print('pano api - create address and group - shared')
print(exec_fw_command('10.215.19.132', 'pano', [('create_address', {'addressname': 'test_host', 'ip1': '10.10.10.10', 'ip2' : '255.255.255.255', 'addresstype': '1', 'zone': 'LAN', 'color': 'black', 'context': 'shared'}), ('create_address', {'addressname': 'test_host2', 'ip1': '20.20.20.20', 'ip2' : '255.255.255.255', 'addresstype': '1', 'zone': 'LAN', 'color': 'black', 'context': 'shared'})], syntax='webui'))
print(exec_fw_command('10.215.19.132', 'pano', [('create_address', {'addressname': 'test_group', 'addresstype': '8', 'zone': 'LAN', 'color': 'black', 'members': [], 'context': 'shared'})], syntax='webui'))

print('pano api - create address and group - DG')

print(exec_fw_command('10.215.19.132', 'pano', [('create_address', {'addressname': 'test_host', 'ip1': '10.10.10.10', 'ip2' : '255.255.255.255', 'addresstype': '1', 'zone': 'LAN', 'color': 'black', 'context': 'Testing'}), ], syntax='webui'))
print(exec_fw_command('10.215.19.132', 'pano', [('create_address', {'addressname': 'test_host', 'ip1': '10.10.10.10', 'ip2' : '255.255.255.255', 'addresstype': '1', 'zone': 'LAN', 'color': 'black', 'context': 'Testing'})], syntax='webui'))
print(exec_fw_command('10.215.19.132', 'pano', [('create_address', {'addressname': 'test_group', 'addresstype': '8', 'zone': 'LAN', 'color': 'black', 'members': [], 'context': 'MavNet - CloudNet'})], syntax='webui'))

print('pano api - add member to group - shared')
print(exec_fw_command('10.215.19.132', 'pano', [('modify_address', {'addressname': 'test_group', 'context': 'shared', 'members': ['test_host', 'test_host2'], 'action' : 'addmembers'})], syntax='webui'))
#print(exec_fw_command('10.215.19.132', 'pano', [('create_address', {'addressname': 'test_group', 'addresstype': '8', 'zone': 'LAN', 'color': 'black', 'members': [], 'context': 'shared'})], syntax='webui'))
print(exec_fw_command('10.215.19.132', 'pano', [('modify_address', {'addressname': 'test_group', 'action': 'comment', 'comment': 'Jeff1', 'context': 'shared'})], syntax='webui'))
print(exec_fw_command('10.215.19.132', 'pano', [('modify_address', {'addressname': 'test_group', 'action': 'tag', 'tags': ['Sanctioned', 'empty', 'DELL_IN'], 'context': 'shared'})], syntax='webui'))

## paloalto API testing

options.password='admin'
print('palo api - create address and group')
print(exec_fw_command('10.215.18.70', 'palo', [('create_address', {'addressname': 'test_host', 'ip1': '10.10.10.10', 'ip2' : '255.255.255.255', 'addresstype': '1', 'zone': 'LAN', 'color': 'black', 'context': ''}), ], syntax='webui'))
print(exec_fw_command('10.215.18.80', 'palo', [('create_address', {'addressname': 'test_host', 'ip1': '10.10.10.10', 'ip2' : '255.255.255.255', 'addresstype': '1', 'zone': 'LAN', 'color': 'black', 'context': ''}), ], syntax='webui'))

'''

if options.getidp:  ## routines to get IPS details on sonicwall

    import pandas as pd
    from bs4 import BeautifulSoup
    import sonicwall as sw
    import re

    fw_list = ['10.102.227.203', '10.215.16.60', '1.1.1.1']
    # fw_list= ['10.215.16.60']
    # options.password=
    if not options.web and (options.username == None or options.password == None):
        options.username, options.password = get_creds()
    # log(options.grouptargets)
    for fw in options.grouptargets:
        session = requests.Session()
        session.mount('https://' + fw, sw.DESAdapter())
        urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
        response = sw.do_login(session, options.username, options.password, fw, False)
        if response:
            try:
                response = session.get('https://{}/systemAdministrationView.html'.format(fw), verify=False,
                                       timeout=options.timeout_sw_webui)
                if response.status_code == 200:
                    soup = BeautifulSoup(response.text, 'lxml')
                    firewallName = soup.find('input', attrs={'name': 'firewallName'}).get('value')  # firewallName
                else:
                    firewallName = 'Unknown'
                response = session.get('https://{}/idpSummary.html'.format(fw), verify=False,
                                       timeout=options.timeout_sw_webui)
                if response.status_code == 200:
                    if re.findall('Upgrade Required', response.text):
                        log('{},{},{},{},{},{},{},{},{},{},{},{},{},{},{}'.format('firewallName', 'fw_ip',
                                                                                  'isIDPEnabled', 'db_timestamp',
                                                                                  'lc_timestamp', 'expire_date',
                                                                                  'idpPreventHighPriority',
                                                                                  'idpDetectHighPriority', 'idpLRTHigh',
                                                                                  'idpPreventMediumPriority',
                                                                                  'idpDetectMediumPriority',
                                                                                  'idpLRTMedium',
                                                                                  'idpPreventLowPriority',
                                                                                  'idpDetectLowPriority', 'idpLRTLow'))
                        log('{},{},{}'.format(firewallName, fw, 'Device not licensed for IDS/IPS'))
                    else:
                        soup = BeautifulSoup(response.text, 'lxml')
                        # ips_status = soup.find_all('table')[9]
                        # ips_enabled = soup.find_all('table')[12]  ## isIDPEnabled
                        # ips_control = soup.find_all('table')[13] ## listControl

                        tables = [
                            [
                                [td.get_text(strip=True) for td in tr.find_all('td')]
                                for tr in table.find_all('tr')
                            ]
                            for table in soup.find_all('table')
                        ]
                        try:
                            isIDPEnabled = soup.find('input', attrs={'name': 'isIDPEnabled'}).has_attr(
                                'checked')  # isIDPEnabled
                        except:
                            isIDPEnabled = 'N/A'
                        # print(isIDPEnabled)
                        if isIDPEnabled == True:
                            # print(soup.findAll("table", {"class": "swlStatsTableRow"}))
                            try:  ## SonicOS 6.2
                                db_timestamp = tables[9][1][1]
                                lc_timestamp = tables[9][2][1]
                                expire_date = tables[9][3][1]
                            except:  ## SonicOS 6.5
                                db_timestamp = tables[0][1][1]
                                lc_timestamp = tables[0][2][1]
                                expire_date = tables[0][3][1]
                            idpPreventHighPriority = soup.find('input',
                                                               attrs={'name': 'idpPreventHighPriority'}).has_attr(
                                'checked')  # idpPreventHighPriority
                            idpDetectHighPriority = soup.find('input',
                                                              attrs={'name': 'idpDetectHighPriority'}).has_attr(
                                'checked')  # idpDetectHighPriority
                            idpLRTHigh = soup.find('input', attrs={'name': 'idpLRTHigh'})[
                                'value']  # idpDetectLowPriority # idpLRTHigh

                            idpPreventMediumPriority = soup.find('input',
                                                                 attrs={'name': 'idpPreventMediumPriority'}).has_attr(
                                'checked')  # idpPreventMediumPriority
                            idpDetectMediumPriority = soup.find('input',
                                                                attrs={'name': 'idpDetectMediumPriority'}).has_attr(
                                'checked')  # idpDetectMediumPriority
                            idpLRTMedium = soup.find('input', attrs={'name': 'idpLRTMedium'})[
                                'value']  # idpDetectLowPriority # idpLRTMedium

                            idpPreventLowPriority = soup.find('input',
                                                              attrs={'name': 'idpPreventLowPriority'}).has_attr(
                                'checked')  # idpPreventLowPriority
                            idpDetectLowPriority = soup.find('input', attrs={'name': 'idpDetectLowPriority'}).has_attr(
                                'checked')  # idpDetectLowPriority
                            idpLRTLow = soup.find('input', attrs={'name': 'idpLRTLow'})[
                                'value']  # idpDetectLowPriority # idpLRTLow
                        else:
                            db_timestamp, lc_timestamp, expire_date, idpPreventHighPriority, idpDetectHighPriority, idpLRTHigh, idpPreventMediumPriority, idpDetectMediumPriority, idpLRTMedium, idpPreventLowPriority, idpDetectLowPriority, idpLRTLow = (
                            'N/A', 'N/A', 'N/A', 'N/A', 'N/A', 'N/A', 'N/A', 'N/A', 'N/A', 'N/A', 'N/A', 'N/A')

                        # db_timestamp=tables[9][1][1]
                        # lc_timestamp=tables[9][2][1]
                        # expire_date=tables[9][3][1]
                        log('{},{},{},{},{},{},{},{},{},{},{},{},{},{},{}'.format('firewallName', 'fw_ip',
                                                                                  'isIDPEnabled', 'db_timestamp',
                                                                                  'lc_timestamp', 'expire_date',
                                                                                  'idpPreventHighPriority',
                                                                                  'idpDetectHighPriority', 'idpLRTHigh',
                                                                                  'idpPreventMediumPriority',
                                                                                  'idpDetectMediumPriority',
                                                                                  'idpLRTMedium',
                                                                                  'idpPreventLowPriority',
                                                                                  'idpDetectLowPriority', 'idpLRTLow'))
                        log('{},{},{},{},{},{},{},{},{},{},{},{},{},{},{}'.format(firewallName, fw, isIDPEnabled,
                                                                                  db_timestamp, lc_timestamp,
                                                                                  expire_date, idpPreventHighPriority,
                                                                                  idpDetectHighPriority, idpLRTHigh,
                                                                                  idpPreventMediumPriority,
                                                                                  idpDetectMediumPriority, idpLRTMedium,
                                                                                  idpPreventLowPriority,
                                                                                  idpDetectLowPriority, idpLRTLow))
                else:
                    log('{},{},{},{},{},{},{},{},{},{},{},{},{},{},{}'.format('firewallName', 'fw_ip', 'isIDPEnabled',
                                                                              'db_timestamp', 'lc_timestamp',
                                                                              'expire_date', 'idpPreventHighPriority',
                                                                              'idpDetectHighPriority', 'idpLRTHigh',
                                                                              'idpPreventMediumPriority',
                                                                              'idpDetectMediumPriority', 'idpLRTMedium',
                                                                              'idpPreventLowPriority',
                                                                              'idpDetectLowPriority', 'idpLRTLow'))
                    log('{},{},{}'.format(firewallName, fw,
                                          'Could not get IDP configuration table - 200/OK not returned'))
                # print(tables[12])
                # for table in soup.find_all('table'):
                #    print(table)
            except Exception as e:
                log('{},{},{},{},{},{},{},{},{},{},{},{},{},{},{}'.format('firewallName', 'fw_ip', 'isIDPEnabled',
                                                                          'db_timestamp', 'lc_timestamp', 'expire_date',
                                                                          'idpPreventHighPriority',
                                                                          'idpDetectHighPriority', 'idpLRTHigh',
                                                                          'idpPreventMediumPriority',
                                                                          'idpDetectMediumPriority', 'idpLRTMedium',
                                                                          'idpPreventLowPriority',
                                                                          'idpDetectLowPriority', 'idpLRTLow'))
                log('{},{},{},{}'.format(firewallName, fw, 'Could not get IDP configuration table', e))
        else:
            firewallName = 'Unknown'
            log('{},{},{},{},{},{},{},{},{},{},{},{},{},{},{}'.format('firewallName', 'fw_ip', 'isIDPEnabled',
                                                                      'db_timestamp', 'lc_timestamp', 'expire_date',
                                                                      'idpPreventHighPriority', 'idpDetectHighPriority',
                                                                      'idpLRTHigh', 'idpPreventMediumPriority',
                                                                      'idpDetectMediumPriority', 'idpLRTMedium',
                                                                      'idpPreventLowPriority', 'idpDetectLowPriority',
                                                                      'idpLRTLow'))
            log('{},{},{}'.format(firewallName, fw, 'Login or connection failure'))
        # sw.do_logout(session, fw)
        session.close()

if not True:  ## routines to get IPS details on sonicwall

    import pandas as pd
    from bs4 import BeautifulSoup
    import sonicwall as sw
    import re

    '''
    {'pagename': 'idpSummary.html', 'fieldname': 'isIDPEnabled' , 'datatype': 'checkbox'},
    {'pagename': 'idpSummary.html', 'fieldname': 'idpPreventHighPriority' , 'datatype': 'checkbox'},
    {'pagename': 'idpSummary.html', 'fieldname': 'idpDetectHighPriority' , 'datatype': 'checkbox'},
    {'pagename': 'idpSummary.html', 'fieldname': 'idpLRTHigh' , 'datatype': 'inputvalue'},
    {'pagename': 'idpSummary.html', 'fieldname': 'idpPreventMediumPriority' , 'datatype': 'checkbox'},
    {'pagename': 'idpSummary.html', 'fieldname': 'idpDetectMediumPriority' , 'datatype': 'checkbox'},
    {'pagename': 'idpSummary.html', 'fieldname': 'idpLRTMedium' , 'datatype': 'inputvalue'},
    {'pagename': 'idpSummary.html', 'fieldname': 'idpPreventLowPriority' , 'datatype': 'checkbox'},
    {'pagename': 'idpSummary.html', 'fieldname': 'idpDetectLowPriority' , 'datatype': 'checkbox'},
    {'pagename': 'idpSummary.html', 'fieldname': 'idpLRTLow' , 'datatype': 'inputvalue'},
    {'pagename': 'systemAdministrationView.html', 'fieldname': 'cfTablePageSize' , 'datatype': 'inputvalue'},
    '''

    commands = ({'pagename': 'idpSummary.html', 'fieldname': 'upgradeRequired', 'regexstr': 'Upgrade Required',
                 'datatype': 'regex'},

                {'pagename': 'activationView.html', 'fieldname': 'licensing', 'datatype': 'table_id',
                 'tablename': 'Sec'},
                )

    debug(set([cmd['pagename'] for cmd in commands]))
    options.grouptargets = ['10.102.227.203', '10.215.16.60', '1.1.1.1']
    # options.grouptargets= ['10.215.16.60']
    # options.grouptargets= ['1.1.1.1']
    # options.grouptargets= ['10.102.227.203']
    # fw_list= ['10.215.16.60']
    # options.password=
    if not options.web and (options.username == None or options.password == None):
        options.username, options.password = get_creds()
    results = {}
    for fw in options.grouptargets:
        results[fw] = {}
        session = requests.Session()
        session.mount('https://' + fw, sw.DESAdapter())
        urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
        response = sw.do_login(session, options.username, options.password, fw, False)
        if response:
            for pagename in set([cmd['pagename'] for cmd in commands]):
                try:
                    response = session.get('https://{}/{}'.format(fw, pagename), verify=False,
                                           timeout=options.timeout_sw_webui)
                    for cmd in commands:
                        if response.status_code == 200:
                            if cmd['pagename'] == pagename:
                                soup = BeautifulSoup(response.text, 'lxml')
                                tables = [[
                                    [td.get_text(strip=True) for td in tr.find_all('td')]
                                    for tr in table.find_all('tr')
                                ]
                                    for table in soup.find_all('table')]
                                if cmd['datatype'] == 'regex':
                                    if len(re.findall(cmd['regexstr'], response.text)) > 0:
                                        results[fw][cmd['fieldname']] = True
                                    else:
                                        results[fw][cmd['fieldname']] = False
                                if cmd['datatype'] == 'checkbox':
                                    results[fw][cmd['fieldname']] = soup.find('input', attrs={
                                        'name': cmd['fieldname']}).has_attr('checked')  #
                                if cmd['datatype'] == 'tablecell':
                                    results[fw][cmd['fieldname']] = tables[cmd['tablenum']][cmd['row']][cmd['col']]
                                if cmd['datatype'] == 'table':
                                    results[fw][cmd['fieldname']] = tables[cmd['tablenum']]
                                if cmd['datatype'] == 'table_id':
                                    debug('tablename:', cmd['tablename'])
                                    tabledata = [
                                        [td.get_text(strip=True) for td in tr.find_all('td')]
                                        for tr in soup.find('table', id=cmd['tablename']).find_all('tr')
                                    ]
                                    col_widths = [len(fw) + 2]
                                    for c_idx, colname in enumerate(tabledata[0]):
                                        col_widths.append(max([len(row[c_idx]) for row in tabledata if
                                                               len(row) == len(tabledata[0])]) + 2)
                                    out_str = ''
                                    for col_width in col_widths:
                                        out_str += '{:' + '{}.{}'.format(col_width, col_width) + 's} '
                                    for row in tabledata:
                                        if len(row) == len(tabledata[0]):
                                            pass
                                            # print(out_str.format(fw+',', *row))
                                        # print(col_width[index])
                                    '''for row in tabledata:
                                        for col in row:
                                            print('{:40.40s}'.format(col), end='')
                                        print('')
                                    '''

                                    '''[   [
                                                                        [td.get_text(strip=True) for td in tr.find_all('td')] 
                                                                        for tr in tabletmp.find_all('tr') ]
                                                                        for tabletmp in soup.find('table', id=cmd['tablename']) ]
                                    soup.find('table', id=cmd['tablename']).findAll('tr')
                                    '''
                                    results[fw][cmd['fieldname']] = tabledata
                                if cmd['datatype'] == 'inputvalue':
                                    results[fw][cmd['fieldname']] = \
                                    soup.find('input', attrs={'name': cmd['fieldname']})['value']
                                if cmd['datatype'] == 'listValue':
                                    data = re.sub(r'' + cmd['listname'] + '\((.*)\);', r'\1',
                                                  re.findall(r'' + cmd['listname'] + '.*', response.text)[0]).split(
                                        '\',')
                                    newlist = [re.sub('\s*\'', '', x) for x in data]
                                    # for item in data:
                                    #    print(item)
                                    results[fw][cmd['fieldname']] = newlist[cmd['valueindex']]

                        else:
                            results[fw][cmd['fieldname']] = None
                except Exception as e:
                    print(e)
                    for cmd in commands:
                        if cmd['pagename'] == pagename:
                            results[fw][cmd['fieldname']] = None
        else:
            for cmd in commands:
                results[fw][cmd['fieldname']] = None
    for fw in results:
        for fieldname in results[fw]:
            # print(type(results[fw][fieldname]))
            if type(results[fw][fieldname]) is not list:
                print(fieldname)
                print(results[fw][fieldname])
            # print(type(results[fw][result]))
            print('-' * 180)
            # print(results)

# pagename, fieldname, datatype, dependency
# regex
{'pagename': 'idpSummary.html', 'fieldname': 'isIDPEnabled', 'datatype': 'checkbox'}

# if not True:
#    log(get_zone('checkpoint', '192.168.1.128'))

if not True:  ## routines to determine address objects defined with a zone that differs from the routing table
    context = None
    for contexts in config:
        if config[contexts]['config']['fw_type'] == 'sonicwall':
            context = contexts
            break
    log(context)
    context = 'checkpoint'
    for address in config[context]['addresses']:
        if config[context]['addresses'][address]['addrObjType'] in ['1', '4']:
            # log('config   : ', config[context]['addresses'][address]['addrObjId'], config[context]['addresses'][address]['addrObjZone'])
            # log('get_zone : ', config[context]['addresses'][address]['addrObjId'], get_zone(context, config[context]['addresses'][address]['addrObjIp1']))
            if config[context]['addresses'][address]['addrObjZone'] != get_zone(context,
                                                                                config[context]['addresses'][address][
                                                                                    'addrObjIp1']) and \
                    config[context]['addresses'][address]['addrObjIp1'] != '0.0.0.0':
                log('ZONEINFO: ', address, get_zone(context, config[context]['addresses'][address]['addrObjIp1']))
                # log('Zone mismatch for object {:40.40} {:20.20} - config: {:10.10} - get_zone: {:10.10}'.format(config[context]['addresses'][address]['addrObjId'], config[context]['addresses'][address]['addrObjIp1'], config[context]['addresses'][address]['addrObjZone'], get_zone(context, config[context]['addresses'][address]['addrObjIp1'])))
    print('-' * 160)
    for route in config[context]['routing']:
        print(route)
        route_dest = config[context]['routing'][route]['pbrObjDst']
        if route_dest == '':
            route_dest = '0.0.0.0'
        for route_dest_addr in expand_address(config[context]['addresses'], route_dest,
                                              config[context]['addressmappings']):
            if route_dest_addr in config[context]['addresses']:
                # print(route_dest_addr)
                # print(dest_ip)
                # if netaddr.IPAddress(dest_ip) in netaddr.IPNetwork('{}/{}'.format(config[context]['addresses'][route_dest_addr]['addrObjIp1'], config[context]['addresses'][route_dest_addr]['addrObjIp2'])):
                # print('{:24.24s} - {:24.24s}'.format(config[context]['routing'][route]['pbrObjDst'], config[context]['routing'][route]['pbrObjGw'] ))
                print('{:>24.24s}/{} - {} - {}'.format(config[context]['addresses'][route_dest_addr]['addrObjIp1'],
                                                       netmask_to_cidr(
                                                           config[context]['addresses'][route_dest_addr]['addrObjIp2']),
                                                       config[context]['addresses'][
                                                           config[context]['routing'][route]['pbrObjGw']]['addrObjIp1'],
                                                       config[context]['addresses'][
                                                           config[context]['routing'][route]['pbrObjGw']][
                                                           'addrObjZone']))
        # routing_props = ['pbrObjId', 'pbrObjProperties', 'pbrObjSrc', 'pbrObjDst', 'pbrObjSvc', 'pbrObjGw', 'pbrObjIface', 'pbrObjIfaceName', 'pbrObjMetric', 'pbrObjPriority', 'pbrObjProbe', 'pbrObjComment']
        # print('{:24.24s} - {:24.24s}'.format(config[context]['routing'][route]['pbrObjDst'], config[context]['routing'][route]['pbrObjGw'] ))
    for interface in config[context]['interfaces']:
        if config[context]['interfaces'][interface]['interface_Zone'] != '':
            if config[context]['interfaces'][interface]['iface_static_ip'] != '0.0.0.0':
                print('{:>24.24s}/{} - {:24.24s} - {:24.24s}'.format(
                    config[context]['interfaces'][interface]['iface_static_ip'],
                    netmask_to_cidr(config[context]['interfaces'][interface]['iface_static_mask']),
                    config[context]['interfaces'][interface]['iface_static_gateway'],
                    config[context]['interfaces'][interface]['interface_Zone']))
            if config[context]['interfaces'][interface]['iface_lan_ip'] != '0.0.0.0':
                print('{:>24.24s}/{} - {:24.24s} - {:24.24s}'.format(
                    config[context]['interfaces'][interface]['iface_lan_ip'],
                    netmask_to_cidr(config[context]['interfaces'][interface]['iface_lan_mask']),
                    config[context]['interfaces'][interface]['iface_lan_default_gw'],
                    config[context]['interfaces'][interface]['interface_Zone']))
            if config[context]['interfaces'][interface]['iface_mgmt_ip'] != '0.0.0.0':
                print('{:>24.24s}/{} - {:24.24s} - {:24.24s}'.format(
                    config[context]['interfaces'][interface]['iface_mgmt_ip'],
                    netmask_to_cidr(config[context]['interfaces'][interface]['iface_mgmt_netmask']),
                    config[context]['interfaces'][interface]['iface_mgmt_default_gw'],
                    config[context]['interfaces'][interface]['interface_Zone']))
    log('INTERFACE', config[context]['interfaces'])
    log('INTERFACE', config[context]['zones'])
    log('INTERFACE', config[context]['routing'])
if not True:  ## routines to get zone of ip address based on routing table/interface info
    import netaddr
    import urllib

    dest_ip = '132.5.6.9'
    dest_ips = ['10.25.116.3', '10.7.200.1']
    for dest_ip in dest_ips:
        print('-' * 100)

        for context in contexts:
            log('Searching {} for address : {}'.format(context, dest_ip))
            print('-' * 100)
            #        for item in config[context]:
            #            print(item)
            if 'routing' in config[context]:
                matchlen = 0
                for route in config[context]['routing']:
                    route_dest = config[context]['routing'][route]['pbrObjDst']
                    if route_dest == '':
                        route_dest = '0.0.0.0'
                    # print(route_dest)
                    if route_dest in config[context]['addresses']:
                        # print(config[context]['addresses'][route_dest])
                        if config[context]['addresses'][route_dest]['addrObjType'] == '8':
                            debug('Route Destination is a group, checking each member object')
                            for route_dest_addr in expand_address(config[context]['addresses'], route_dest,
                                                                  config[context]['addressmappings']):
                                if route_dest_addr in config[context]['addresses']:
                                    # print(route_dest_addr)
                                    # print(dest_ip)
                                    if netaddr.IPAddress(dest_ip) in netaddr.IPNetwork(
                                            '{}/{}'.format(config[context]['addresses'][route_dest_addr]['addrObjIp1'],
                                                           config[context]['addresses'][route_dest_addr][
                                                               'addrObjIp2'])):
                                        # if netaddr.IPAddress(dest_ip) in netaddr.IPNetwork('{}/{}'.format(config[config[context]['addresses']['addrObjIp1'], netmask_to_cidr(config[context]['interfaces'][interface]['iface_lan_mask']))):
                                        # config[context]['addresses'][route_dest_addr]['IPSet']:
                                        debug('Searched address found in destination group: "{}"'.format(
                                            urllib.parse.unquote(route_dest)))
                                        if netmask_to_cidr(
                                                config[context]['addresses'][route_dest_addr]['addrObjIp2']) > matchlen:
                                            matchlen = netmask_to_cidr(
                                                config[context]['addresses'][route_dest_addr]['addrObjIp2'])
                                            next_hop = config[context]['routing'][route]['pbrObjGw']
                                            if next_hop in config[context]['addresses']:
                                                next_hop_ip = config[context]['addresses'][next_hop]['addrObjIp1']
                                            else:
                                                next_hop_ip = next_hop
                                        else:
                                            debug('Skipping - not longest match')
                        else:
                            if dest_ip in config[context]['addresses'][route_dest]['IPSet']:
                                debug('Searched address found in destination address')
                                if netmask_to_cidr(
                                        config[context]['addresses'][route_dest_addr]['addrObjIp2']) > matchlen:
                                    matchlen = netmask_to_cidr(
                                        config[context]['addresses'][route_dest_addr]['addrObjIp2'])
                                    next_hop = config[context]['routing'][route]['pbrObjGw']
                                    if next_hop in config[context]['addresses']:
                                        next_hop_ip = config[context]['addresses'][next_hop]['addrObjIp1']
                                    else:
                                        next_hop_ip = next_hop
                                else:
                                    debug('Skipping - not longest match')
                            # print(next_hop)
                            # print(next_hop_ip)
                    # print(config[context]['interfaces'])
                if matchlen != 0:
                    for interface in config[context]['interfaces']:
                        if config[context]['interfaces'][interface]['iface_lan_ip'] != '0.0.0.0':
                            if netaddr.IPAddress(next_hop_ip) in netaddr.IPNetwork(
                                    '{}/{}'.format(config[context]['interfaces'][interface]['iface_lan_ip'],
                                                   netmask_to_cidr(config[context]['interfaces'][interface][
                                                                       'iface_lan_mask']))):
                                # print('{} - {}/{}'.format(config[context]['interfaces'][interface]['iface_name'],config[context]['interfaces'][interface]['iface_lan_ip'],config[context]['interfaces'][interface]['iface_lan_mask']))
                                print(
                                    'ROUTE MATCH - Searched address {} is in Zone : {} Interface Name: {} Interface Address {}/{}'.format(
                                        dest_ip, config[context]['interfaces'][interface]['interface_Zone'],
                                        config[context]['interfaces'][interface]['iface_name'], '', ''))
                        if config[context]['interfaces'][interface]['iface_static_ip'] != '0.0.0.0':
                            if netaddr.IPAddress(next_hop_ip) in netaddr.IPNetwork(
                                    '{}/{}'.format(config[context]['interfaces'][interface]['iface_static_ip'],
                                                   netmask_to_cidr(config[context]['interfaces'][interface][
                                                                       'iface_static_mask']))):
                                # print('{} - {}/{}'.format(config[context]['interfaces'][interface]['iface_name'],config[context]['interfaces'][interface]['iface_static_ip'],config[context]['interfaces'][interface]['iface_static_mask']))
                                print(
                                    'ROUTE MATCH - Searched address {} is in Zone : {} Interface Name: {} Interface Address {}/{}'.format(
                                        dest_ip, config[context]['interfaces'][interface]['interface_Zone'],
                                        config[context]['interfaces'][interface]['iface_name'], '', ''))
                        if config[context]['interfaces'][interface]['iface_mgmt_ip'] != '0.0.0.0':
                            if netaddr.IPAddress(next_hop_ip) in netaddr.IPNetwork(
                                    '{}/{}'.format(config[context]['interfaces'][interface]['iface_mgmt_ip'],
                                                   netmask_to_cidr(config[context]['interfaces'][interface][
                                                                       'iface_mgmt_netmask']))):
                                # print('{} - {}/{}'.format(config[context]['interfaces'][interface]['iface_name'],config[context]['interfaces'][interface]['iface_mgmt_ip'],config[context]['interfaces'][interface]['iface_mgmt_netmask']))
                                print(
                                    'ROUTE MATCH - Searched address {} is in Zone : {} Interface Name: {} Interface Address {}/{}'.format(
                                        dest_ip, config[context]['interfaces'][interface]['interface_Zone'],
                                        config[context]['interfaces'][interface]['iface_name'], '', ''))

if options.testcreate:
    for context in contexts:
        if 'policynum' in config[context]['config']:
            for policy in config[context]['config']['policynum']:
                config[context]['config']['policynum'] = int(config[context]['config']['policynum'])
    testlist = [
        # ('pano', '10.215.19.132', 'shared'),
        # ('pano', '10.215.19.132', 'PTC Services DMZ'),
        # ('pano', '10.215.18.71', 'shared'),
        # ('palo', '10.215.18.81', ''),
        ('sw65', '10.215.16.61', ''),
        # ('sonicwall', '10.215.16.60', ''),
        # ('checkpoint', '', '')
        # ('checkpoint', '128.221.62.90', 'api')
    ]

    # for syntax in ['webui', 'cli']:
    for syntax in ['api']:
        for fw, fwip, context in testlist:

            log('-' * 100)
            log('{} {} testing'.format(fw, syntax))
            log('-' * 100)
            # print(options.username, options.password)
            result = exec_fw_command(fwip, fw, [('create_address', {'addressname': 'test_host', 'ip1': '10.10.10.10',
                                                                    'ip2': '255.255.255.255', 'addresstype': '1',
                                                                    'zone': 'LAN', 'color': 'black',
                                                                    'context': context})], syntax=syntax)
            if syntax in ['webui', 'api']: log('{:>60.60}: {}'.format('Create Host', result))
            debug('-' * 180)
            result = exec_fw_command(fwip, fw, [('create_address', {'addressname': 'test_range', 'ip1': '20.20.20.1',
                                                                    'ip2': '20.20.20.11', 'addresstype': '2',
                                                                    'zone': 'LAN', 'color': 'black',
                                                                    'context': context})], syntax=syntax)
            if syntax in ['webui', 'api']: log('{:>60.60}: {}'.format('Create Range', result))
            debug('-' * 180)
            result = exec_fw_command(fwip, fw, [('create_address', {'addressname': 'test_network', 'ip1': '30.30.30.0',
                                                                    'ip2': '255.255.255.252', 'addresstype': '4',
                                                                    'zone': 'LAN', 'color': 'black',
                                                                    'context': context})], syntax=syntax)
            if syntax in ['webui', 'api']: log('{:>60.60}: {}'.format('Create Network', result))
            debug('-' * 180)
            result = exec_fw_command(fwip, fw, [('create_address',
                                                 {'addressname': 'test_group', 'addresstype': '8', 'zone': 'LAN',
                                                  'color': 'black', 'context': context})], syntax=syntax)
            if syntax in ['webui', 'api']: log(
                '{:>60.60}: {}'.format('Create Address Group missing members param', result))
            debug('-' * 180)
            result = exec_fw_command(fwip, fw, [('create_address',
                                                 {'addressname': 'test_group', 'addresstype': '8', 'zone': 'LAN',
                                                  'color': 'black', 'members': [], 'context': context})], syntax=syntax)
            if syntax in ['webui', 'api']: log(
                '{:>60.60}: {}'.format('Create Address Group empty members param', result))
            debug('-' * 180)
            result = exec_fw_command(fwip, fw, [('create_address',
                                                 {'addressname': 'test_group', 'addresstype': '8', 'zone': 'LAN',
                                                  'color': 'black', 'members': ['test_host2'], 'context': context})],
                                     syntax=syntax)
            if syntax in ['webui', 'api']: log(
                '{:>60.60}: {}'.format('Create Address Group bad address member', result))
            debug('-' * 180)
            result = exec_fw_command(fwip, fw, [('create_address',
                                                 {'addressname': 'test_group', 'addresstype': '8', 'zone': 'LAN',
                                                  'color': 'black', 'members': ['test_host'], 'context': context})],
                                     syntax=syntax)
            if syntax in ['webui', 'api']: log('{:>60.60}: {}'.format('Create Address Group', result))
            debug('-' * 180)

            result = exec_fw_command(fwip, fw, [('create_service',
                                                 {'servicename': 'test_service_tcp', 'servicetype': '1',
                                                  'color': 'black', 'protocol': 'tcp', 'port1': '32',
                                                  'context': context})], syntax=syntax)
            if syntax in ['webui', 'api']: log('{:>60.60}: {}'.format('Create TCP Service', result))
            debug('-' * 180)
            result = exec_fw_command(fwip, fw, [('create_service',
                                                 {'servicename': 'test_service_udp', 'servicetype': '1',
                                                  'color': 'black', 'protocol': 'udp', 'port1': '44',
                                                  'context': context})], syntax=syntax)
            if syntax in ['webui', 'api']: log('{:>60.60}: {}'.format('Create UDP Service', result))
            debug('-' * 180)
            result = exec_fw_command(fwip, fw, [('create_service',
                                                 {'servicename': 'test_service_range', 'servicetype': '1',
                                                  'color': 'black', 'protocol': 'tcp', 'port1': '32', 'port2': '33',
                                                  'context': context})], syntax=syntax)
            if syntax in ['webui', 'api']: log('{:>60.60}: {}'.format('Create Service Range', result))
            debug('-' * 180)
            result = exec_fw_command(fwip, fw, [('create_service',
                                                 {'servicename': 'test_service_group', 'servicetype': '2',
                                                  'color': 'black', 'members': ['test_service_range'],
                                                  'context': context})], syntax=syntax)
            if syntax in ['webui', 'api']: log('{:>60.60}: {}'.format('Create Service Group', result))
            debug('-' * 180)

            result = exec_fw_command(fwip, fw, [('create_rule',
                                                 {'rulename': 'test_rule', 'policyname': '##rsa-ecom-core',
                                                  'policynum': '1', 'polaction': '1', 'enabled': '1',
                                                  'srczones': ['LAN'], 'dstzones': ['WAN'], 'sources': ['test_host'],
                                                  'dests': ['test_group'], 'services': ['any'], 'comment': 'testing',
                                                  'context': context})], syntax=syntax)
            if syntax in ['webui', 'api']: log('{:>60.60}: {}'.format('Create Rule', result))
            debug('-' * 180)

if options.testmodify:
    for context in contexts:
        if 'policynum' in config[context]['config']:
            for policy in config[context]['config']['policynum']:
                config[context]['config']['policynum'] = int(config[context]['config']['policynum'])
    testlist = [
        # ('pano', '10.215.19.132', 'shared'),
        # ('pano', '10.215.19.132', 'PTC Services DMZ'),
        # ('palo', '10.215.18.70', ''),
        # ('sonicwall', '10.215.16.60', ''),
        # ('sw65', '10.215.16.61', '')
        ('checkpoint', '128.221.62.90', 'api')
        # ('checkpoint', '', '')
    ]

    # exec_fw_comand syntax options should be cli, dbedit, api, webui, xmlapi

    # for syntax in ['webui', 'cli']:
    for syntax in ['api']:
        for fw, fwip, context in testlist:

            print('-' * 100)
            print('{} {} testing'.format(fw, syntax))
            print('-' * 100)
            # print(options.username, options.password)
            # delmembers addmembers
            ## created rule is LAN, WAN, test_host, test_group, any
            #
            result = exec_fw_command(fwip, fw, [('modify_rule', {'action': 'comment', 'comment': 'Modified Comment',
                                                                 'rulename': 'test_rule',
                                                                 'policyname': '##rsa-ecom-core', 'policynum': '1',
                                                                 'polaction': '1', 'srczones': ['LAN'],
                                                                 'dstzones': ['WAN'], 'sources': ['test_host'],
                                                                 'dests': ['test_group'], 'services': ['any'],
                                                                 'context': context})], syntax=syntax)
            if syntax in ['webui', 'api']: log('{:>35.35}: {}'.format('Modify Rule', result))
            result = exec_fw_command(fwip, fw, [('modify_rule',
                                                 {'action': 'logging', 'logging': True, 'comment': 'Modified Comment',
                                                  'rulename': 'test_rule', 'policyname': '##rsa-ecom-core',
                                                  'policynum': '1', 'polaction': '1', 'srczones': ['LAN'],
                                                  'dstzones': ['WAN'], 'sources': ['test_host'],
                                                  'dests': ['test_group'], 'services': ['any'], 'context': context})],
                                     syntax=syntax)
            if syntax in ['webui', 'api']: log('{:>35.35}: {}'.format('Modify Rule Logging', result))
            result = exec_fw_command(fwip, fw, [('modify_rule', {'action': 'delmembers', 'comment': 'Modified Comment',
                                                                 'rulename': 'test_rule',
                                                                 'policyname': '##rsa-ecom-core', 'policynum': '1',
                                                                 'polaction': '1', 'srczones': ['LAN'],
                                                                 'dstzones': ['WAN'], 'sources': ['test_range'],
                                                                 'context': context})], syntax=syntax)
            if syntax in ['webui', 'api']: log('{:>35.35}: {}'.format('Modify Rule Source', result))
            result = exec_fw_command(fwip, fw, [('modify_rule', {'action': 'delmembers', 'comment': 'Modified Comment',
                                                                 'rulename': 'test_rule',
                                                                 'policyname': '##rsa-ecom-core', 'policynum': '1',
                                                                 'polaction': '1', 'srczones': ['LAN'],
                                                                 'dstzones': ['WAN'], 'dests': ['test_network'],
                                                                 'context': context})], syntax=syntax)
            if syntax in ['webui', 'api']: log('{:>35.35}: {}'.format('Modify Rule Dests', result))

            result = exec_fw_command(fwip, fw, [('modify_rule', {'action': 'delmembers', 'comment': 'Modified Comment',
                                                                 'rulename': 'test_rule',
                                                                 'policyname': '##rsa-ecom-core', 'policynum': '1',
                                                                 'polaction': '1', 'srczones': ['LAN'],
                                                                 'dstzones': ['WAN'], 'sources': ['test_host'],
                                                                 'dests': ['test_network'],
                                                                 'services': ['test_service_udp'],
                                                                 'context': context})], syntax=syntax)
            if syntax in ['webui', 'api']: log('{:>35.35}: {}'.format('Modify Rule Services', result))
            ## is delmemebrs tehe right action for modifying tags?
            result = exec_fw_command(fwip, fw, [('modify_rule',
                                                 {'action': 'delmembers', 'tags': ['TESTTAG'], 'rulename': 'test_rule',
                                                  'policyname': '##rsa-ecom-core', 'policynum': '1', 'polaction': '1',
                                                  'context': context})], syntax=syntax)
            if syntax in ['webui', 'api']: log('{:>35.35}: {}'.format('Modify Rule Tags', result))
            result = exec_fw_command(fwip, fw, [('modify_rule', {'action': 'disable', 'comment': 'Modified Comment',
                                                                 'rulename': 'test_rule',
                                                                 'policyname': '##rsa-ecom-core', 'policynum': '1',
                                                                 'polaction': '1', 'srczones': ['LAN'],
                                                                 'dstzones': ['WAN'], 'sources': ['test_host'],
                                                                 'dests': ['test_group'], 'services': ['any'],
                                                                 'context': context})], syntax=syntax)
            if syntax in ['webui', 'api']: log('{:>35.35}: {}'.format('Modify Rule Enabled', result))

            result = exec_fw_command(fwip, fw, [('modify_address', {'action': 'addmembers', 'addressname': 'test_group',
                                                                    'members': ['test_range', 'test_network',
                                                                                'test_host'],
                                                                    'comment': 'modify comment', 'addresstype': '8',
                                                                    'zone': 'LAN', 'color': 'black',
                                                                    'context': context})], syntax=syntax)
            if syntax in ['webui', 'api']: log('{:>35.35}: {}'.format('Modify Address Group AddMembers', result))
            result = exec_fw_command(fwip, fw, [('modify_address', {'action': 'delmembers', 'addressname': 'test_group',
                                                                    'members': ['test_range'],
                                                                    'comment': 'modify comment', 'addresstype': '8',
                                                                    'zone': 'LAN', 'color': 'black',
                                                                    'context': context})], syntax=syntax)
            if syntax in ['webui', 'api']: log('{:>35.35}: {}'.format('Modify Address Group DelMembers', result))
            result = exec_fw_command(fwip, fw, [('modify_address',
                                                 {'action': 'color', 'addressname': 'test_host', 'ip1': '10.10.10.10',
                                                  'ip2': '255.255.255.255', 'addresstype': '1', 'zone': 'LAN',
                                                  'color': 'blue', 'context': context})], syntax=syntax)
            if syntax in ['webui', 'api']: log('{:>35.35}: {}'.format('Modify Host Color', result))
            result = exec_fw_command(fwip, fw, [('modify_address', {'action': 'comment', 'addressname': 'test_range',
                                                                    'comment': 'modified comment', 'ip1': '20.20.20.1',
                                                                    'ip2': '20.20.20.11', 'addresstype': '2',
                                                                    'zone': 'LAN', 'color': 'black',
                                                                    'context': context})], syntax=syntax)
            if syntax in ['webui', 'api']: log('{:>35.35}: {}'.format('Modify Range Comment', result))
            result = exec_fw_command(fwip, fw, [('modify_address',
                                                 {'action': 'tags', 'addressname': 'test_network', 'tags': ['TESTTAG'],
                                                  'ip1': '30.30.30.0', 'ip2': '255.255.255.255', 'addresstype': '4',
                                                  'zone': 'LAN', 'color': 'black', 'context': context})], syntax=syntax)
            if syntax in ['webui', 'api']: log('{:>35.35}: {}'.format('Modify Network Tags', result))
            result = exec_fw_command(fwip, fw, [('modify_address',
                                                 {'action': 'tags', 'addressname': 'test_network', 'tags': ['TESTTAG'],
                                                  'ip1': '30.30.30.0', 'ip2': '255.255.255.255', 'addresstype': '4',
                                                  'zone': 'LAN', 'color': 'black', 'context': context})], syntax=syntax)
            if syntax in ['webui', 'api']: log('{:>35.35}: {}'.format('Modify Network Tags', result))

            result = exec_fw_command(fwip, fw, [('modify_service',
                                                 {'action': 'addmembers', 'servicename': 'test_service_group',
                                                  'members': ['test_service_tcp', 'test_service_udp'],
                                                  'servicetype': '2', 'color': 'black', 'context': context})],
                                     syntax=syntax)
            if syntax in ['webui', 'api']: log('{:>35.35}: {}'.format('Modify Service Group - Addmembers', result))
            result = exec_fw_command(fwip, fw, [('modify_service',
                                                 {'action': 'delmembers', 'servicename': 'test_service_group',
                                                  'members': ['test_service_udp'], 'servicetype': '1', 'color': 'black',
                                                  'protocol': 'tcp', 'port1': '32', 'port2': '33',
                                                  'context': context})], syntax=syntax)
            if syntax in ['webui', 'api']: log('{:>35.35}: {}'.format('Modify Service Group - Delmembers', result))

            result = exec_fw_command(fwip, fw, [('modify_service',
                                                 {'action': 'color', 'servicename': 'test_service', 'servicetype': '1',
                                                  'color': 'blue', 'protocol': 'tcp', 'port1': '32',
                                                  'context': context})], syntax=syntax)
            if syntax in ['webui', 'api']: log('{:>35.35}: {}'.format('Modify Service Color', result))
            result = exec_fw_command(fwip, fw, [('modify_service', {'action': 'comment', 'servicename': 'test_service',
                                                                    'servicetype': '1', 'comment': 'Modified Comment',
                                                                    'protocol': 'tcp', 'port1': '32',
                                                                    'context': context})], syntax=syntax)
            if syntax in ['webui', 'api']: log('{:>35.35}: {}'.format('Modify Service Comment', result))
            result = exec_fw_command(fwip, fw, [('modify_service', {'action': 'addtags', 'servicename': 'test_service',
                                                                    'tags': ['TESTTAG'], 'servicetype': '1',
                                                                    'comment': 'Modified Comment', 'protocol': 'tcp',
                                                                    'port1': '32', 'context': context})], syntax=syntax)
            if syntax in ['webui', 'api']: log('{:>35.35}: {}'.format('Modify Service Tag', result))

if options.testdelete:
    for context in contexts:
        if 'policynum' in config[context]['config']:
            for policy in config[context]['config']['policynum']:
                config[context]['config']['policynum'] = int(config[context]['config']['policynum'])
    testlist = [
        # ('pano', '10.215.19.132', 'shared'),
        # ('pano', '10.215.19.132', 'PTC Services DMZ'),
        # ('palo', '10.215.18.70', ''),
        # ('sonicwall', '10.215.16.60', ''),
        # ('checkpoint', '', '')
        ('sw65', '10.215.16.61', '')
    ]
    # for syntax in ['webui', 'cli']:
    for syntax in ['api']:
        for fw, fwip, context in testlist:

            print('-' * 100)
            print('{} {} testing'.format(fw, syntax))
            print('-' * 100)
            # print(options.username, options.password)

            ## follwoing is to try deleting an address group already in use
            # result=exec_fw_command(fwip, fw, [('modify_address', {'action': 'delete', 'addressname': 'test_host', 'ip1': '10.10.10.10', 'ip2' : '255.255.255.255', 'addresstype': '1', 'zone': 'LAN', 'color': 'black', 'context': context})], syntax=syntax)
            # if syntax in ['webui', 'api']: print('{:>20.20}: {}'.format('Delete In Use Addr', result))

            result = exec_fw_command(fwip, fw, [('modify_rule', {'action': 'delete', 'rulename': 'test_rule',
                                                                 'policyname': '##rsa-ecom-core', 'policynum': '1',
                                                                 'polaction': '1', 'srczones': ['LAN'],
                                                                 'dstzones': ['WAN'], 'sources': ['test_host'],
                                                                 'dests': ['test_group'], 'services': ['any'],
                                                                 'comment': 'testing', 'context': context})],
                                     syntax=syntax)
            if syntax in ['webui', 'api']: print('{:>20.20}: {}'.format('Delete Rule', result))

            result = exec_fw_command(fwip, fw, [('modify_address',
                                                 {'action': 'delete', 'addressname': 'test_group', 'addresstype': '8',
                                                  'zone': 'LAN', 'color': 'black', 'members': ['test_host'],
                                                  'context': context})], syntax=syntax)
            if syntax in ['webui', 'api']: print('{:>20.20}: {}'.format('Delete Address Group', result))
            result = exec_fw_command(fwip, fw, [('modify_address',
                                                 {'action': 'delete', 'addressname': 'test_host', 'ip1': '10.10.10.10',
                                                  'ip2': '255.255.255.255', 'addresstype': '1', 'zone': 'LAN',
                                                  'color': 'black', 'context': context})], syntax=syntax)
            if syntax in ['webui', 'api']: print('{:>20.20}: {}'.format('Delete Host', result))
            result = exec_fw_command(fwip, fw, [('modify_address',
                                                 {'action': 'delete', 'addressname': 'test_range', 'ip1': '20.20.20.1',
                                                  'ip2': '20.20.20.11', 'addresstype': '2', 'zone': 'LAN',
                                                  'color': 'black', 'context': context})], syntax=syntax)
            if syntax in ['webui', 'api']: print('{:>20.20}: {}'.format('Delete Range', result))
            result = exec_fw_command(fwip, fw, [('modify_address', {'action': 'delete', 'addressname': 'test_network',
                                                                    'ip1': '30.30.30.0', 'ip2': '255.255.255.255',
                                                                    'addresstype': '4', 'zone': 'LAN', 'color': 'black',
                                                                    'context': context})], syntax=syntax)
            if syntax in ['webui', 'api']: print('{:>20.20}: {}'.format('Delete Network', result))

            result = exec_fw_command(fwip, fw, [('modify_service',
                                                 {'action': 'delete', 'servicename': 'test_service_group',
                                                  'servicetype': '2', 'color': 'black', 'members': ['test_service'],
                                                  'context': context})], syntax=syntax)
            if syntax in ['webui', 'api']: print('{:>20.20}: {}'.format('Delete Service Group', result))
            result = exec_fw_command(fwip, fw, [('modify_service',
                                                 {'action': 'delete', 'servicename': 'test_service_range',
                                                  'servicetype': '1', 'color': 'black', 'protocol': 'tcp',
                                                  'port1': '32', 'port2': '33', 'context': context})], syntax=syntax)
            if syntax in ['webui', 'api']: print('{:>20.20}: {}'.format('Delete Service Range', result))
            result = exec_fw_command(fwip, fw, [('modify_service',
                                                 {'action': 'delete', 'servicename': 'test_service_tcp',
                                                  'servicetype': '1', 'color': 'black', 'protocol': 'tcp',
                                                  'port1': '32', 'context': context})], syntax=syntax)
            if syntax in ['webui', 'api']: print('{:>20.20}: {}'.format('Delete Service', result))
            result = exec_fw_command(fwip, fw, [('modify_service',
                                                 {'action': 'delete', 'servicename': 'test_service_udp',
                                                  'servicetype': '1', 'color': 'black', 'protocol': 'tcp',
                                                  'port1': '32', 'context': context})], syntax=syntax)
            if syntax in ['webui', 'api']: print('{:>20.20}: {}'.format('Delete Service', result))

### policy name is different than rule name

###
'''
exec_fw_command('10.215.19.132', 'pano', [('create_address', {'addressname': 'test_host', 'ip1': '10.10.10.10', 'ip2' : '255.255.255.255', 'addresstype': '1', 'zone': 'LAN', 'color': 'black', 'members': ['test_host'], 'context': 'shared'})], syntax='cli')
exec_fw_command('10.215.19.132', 'pano', [('create_address', {'addressname': 'test_group', 'ip1': '10.10.10.10', 'ip2' : '255.255.255.255', 'addresstype': '8', 'zone': 'LAN', 'color': 'black', 'members': ['test_host'], 'context': 'shared'})], syntax='cli')
exec_fw_command('10.215.19.132', 'pano', [('modify_address', {'action': 'delete', 'addressname': 'test_group', 'ip1': '10.10.10.10', 'ip2' : '255.255.255.255', 'addresstype': '8', 'zone': 'LAN', 'color': 'black', 'members': ['test_host'], 'context': 'shared'})], syntax='cli')

print('PANO CLI - create address and group - shared')
exec_fw_command('10.215.19.132', 'pano', [('create_address', {'addressname': 'test_host', 'ip1': '10.10.10.10', 'ip2' : '255.255.255.255', 'addresstype': '1', 'zone': 'LAN', 'color': 'black', 'context': 'shared'}), ('create_address', {'addressname': 'test_host2', 'ip1': '20.20.20.20', 'ip2' : '255.255.255.255', 'addresstype': '1', 'zone': 'LAN', 'color': 'black', 'context': 'shared'})], syntax='cli')
exec_fw_command('10.215.19.132', 'pano', [('create_address', {'addressname': 'test_group', 'addresstype': '8', 'zone': 'LAN', 'color': 'black', 'members': [], 'context': 'shared'})], syntax='cli')

print('PANO CLI - modify group - shared')
exec_fw_command('10.215.19.132', 'pano', [('modify_address', {'addressname': 'test_group', 'context': 'shared', 'members': ['test_host', 'test_host2'], 'action' : 'addmembers'})], syntax='cli')
exec_fw_command('10.215.19.132', 'pano', [('modify_address', {'addressname': 'test_group', 'addresstype': 'group', 'action': 'comment', 'comment': 'Jeff1', 'context': 'shared'})], syntax='cli')
exec_fw_command('10.215.19.132', 'pano', [('modify_address', {'addressname': 'test_group', 'addresstype': 'group', 'action': 'tag', 'tags': ['Sanctioned', 'empty', 'DELL_IN'], 'context': 'shared'})], syntax='cli')



print('PANO CLI - create address and group - DG')

exec_fw_command('10.215.19.132', 'pano', [('create_address', {'addressname': 'test_host', 'ip1': '10.10.10.10', 'ip2' : '255.255.255.255', 'addresstype': '1', 'zone': 'LAN', 'color': 'black', 'context': 'Testing'}), ], syntax='cli')
exec_fw_command('10.215.19.132', 'pano', [('create_address', {'addressname': 'test_host', 'ip1': '10.10.10.10', 'ip2' : '255.255.255.255', 'addresstype': '1', 'zone': 'LAN', 'color': 'black', 'context': 'Testing'})], syntax='cli')
exec_fw_command('10.215.19.132', 'pano', [('create_address', {'addressname': 'test_group', 'addresstype': '8', 'zone': 'LAN', 'color': 'black', 'members': [], 'context': 'MavNet - CloudNet'})], syntax='cli')

## paloalto CLI testing

options.password='admin'
print('palo CLI - create address and group')
exec_fw_command('10.215.18.70', 'palo', [('create_address', {'addressname': 'test_host', 'ip1': '10.10.10.10', 'ip2' : '255.255.255.255', 'addresstype': '1', 'zone': 'LAN', 'color': 'black', 'context': ''}), ], syntax='cli')
exec_fw_command('10.215.18.80', 'palo', [('create_address', {'addressname': 'test_host', 'ip1': '10.10.10.10', 'ip2' : '255.255.255.255', 'addresstype': '1', 'zone': 'LAN', 'color': 'black', 'context': ''}), ], syntax='cli')




### for functions, add a set of required params, compare to sent params to determine if any params are missing.  if so return missing params in error.
### add option to print commands only - do not execute (mostly for documentation purposes)

'''

'''
## find dupes
count=0
print (len(config['checkpoint']['addresses']))
for addr1 in config['checkpoint']['addresses']:
    count += 1
    #print (count)
    if config['checkpoint']['addresses'][addr1]['addrObjType'] in ['1', '2', '4']:
        for addr2 in config['checkpoint']['addresses']:
            if addr1 != addr2:
                if (config['checkpoint']['addresses'][addr1]['addrObjIp1'],config['checkpoint']['addresses'][addr1]['addrObjIp2'],config['checkpoint']['addresses'][addr1]['addrObjType'])==(config['checkpoint']['addresses'][addr2]['addrObjIp1'],config['checkpoint']['addresses'][addr2]['addrObjIp2'],config['checkpoint']['addresses'][addr2]['addrObjType']): print('match!', count, (config['checkpoint']['addresses'][addr1]['addrObjIp1'],config['checkpoint']['addresses'][addr1]['addrObjIp2'],config['checkpoint']['addresses'][addr1]['addrObjType']))
'''
if options.uuid != None:
    print(options.uuid)
    for context in contexts:
        log(context)
        log(len(config[context]['policies']))
        for policy in config[context]['policies']:
            # log(policy)
            if 'policyUid' in config[context]['policies'][policy]:
                if config[context]['policies'][policy]['policyAction'] == '0':
                    action = 'deny'
                elif config[context]['policies'][policy]['policyAction'] == '1':
                    action = 'drop'
                elif config[context]['policies'][policy]['policyAction'] == '2':
                    action = 'allow'
                else:
                    action = 'UNKNOWN'
                # log(config[context]['policies'][policy])
                if options.uuid == [] or config[context]['policies'][policy]['policyUid'] in options.uuid:
                    log('{}~{}~{}~{}~{}~{}~{}'.format(config[context]['policies'][policy]['policyName'],
                                                      config[context]['policies'][policy]['policyUid'],
                                                      config[context]['policies'][policy]['policyNum'],
                                                      config[context]['policies'][policy]['policyUiNum'],
                                                      action,
                                                      config[context]['policies'][policy]['policyEnabled'] == '1',
                                                      config[context]['policies'][policy]['policyComment'],

                                                      ))

if options.dmz:
    import urllib
    import json

    for context in contexts:
        print('!-- ', context)
        if 'interfaces' in config[context]:
            # print(json.dumps(config[context]['interfaces'], indent=4))
            for interface in config[context]['interfaces']:
                # log(config[context]['interfaces'][interface])
                if urllib.parse.unquote(config[context]['interfaces'][interface]['interface_Zone']) not in ['MGMT', '']:
                    # log(interface)
                    if config[context]['interfaces'][interface]['iface_static_ip'] != '0.0.0.0':
                        print('{},{},{},{},{},{}'.format(context,
                                                         urllib.parse.unquote(
                                                             config[context]['interfaces'][interface]['iface_name']),
                                                         urllib.parse.unquote(config[context]['interfaces'][interface][
                                                                                  'interface_Zone']),
                                                         urllib.parse.unquote(config[context]['interfaces'][interface][
                                                                                  'iface_static_ip']),
                                                         urllib.parse.unquote(config[context]['interfaces'][interface][
                                                                                  'iface_static_mask']),
                                                         urllib.parse.unquote(
                                                             config[context]['interfaces'][interface]['portShutdown'])
                                                         ))
                    elif config[context]['interfaces'][interface]['iface_lan_ip'] != '0.0.0.0':
                        print('{},{},{},{},{},{}'.format(context,
                                                         urllib.parse.unquote(
                                                             config[context]['interfaces'][interface]['iface_name']), \
                                                         urllib.parse.unquote(config[context]['interfaces'][interface][
                                                                                  'interface_Zone']),
                                                         urllib.parse.unquote(
                                                             config[context]['interfaces'][interface]['iface_lan_ip']),
                                                         urllib.parse.unquote(config[context]['interfaces'][interface][
                                                                                  'iface_lan_mask']),
                                                         urllib.parse.unquote(
                                                             config[context]['interfaces'][interface]['portShutdown'])
                                                         ))
                    elif config[context]['interfaces'][interface]['iface_mgmt_ip'] != '0.0.0.0':
                        print('{},{},{},{},{},{}'.format(context,
                                                         urllib.parse.unquote(
                                                             config[context]['interfaces'][interface]['iface_name']),
                                                         urllib.parse.unquote(config[context]['interfaces'][interface][
                                                                                  'interface_Zone']),
                                                         urllib.parse.unquote(
                                                             config[context]['interfaces'][interface]['iface_mgmt_ip']),
                                                         urllib.parse.unquote(config[context]['interfaces'][interface][
                                                                                  'iface_mgmt_netmask']),
                                                         urllib.parse.unquote(
                                                             config[context]['interfaces'][interface]['portShutdown'])

                                                         ))
if not True:
    for context in contexts:
        # log(context)
        for address in config[context]['addresses']:
            # log('{},{},{}'.format(config[context]['addresses'][address]['addrObjId'], config[context]['addresses'][address]['connection_limit'], config[context]['addresses'][address]['auto_calc_conns']))
            try:
                log('{},{},{}'.format(config[context]['addresses'][address]['addrObjId'],
                                      config[context]['addresses'][address]['connection_limit'],
                                      config[context]['addresses'][address]['auto_calc_conns']))
            except:
                pass

# interface_props = ['iface_ifnum', 'iface_type', 'iface_name', 'interface_Zone', 'iface_comment', 'iface_static_ip', 'iface_static_mask', 'iface_static_gateway', 'iface_lan_ip', 'iface_lan_mask', 'iface_lan_default_gw', 'iface_mgmt_ip', 'iface_mgmt_netmask', 'iface_mgmt_default_gw', 'iface_static_gateway', 'iface_vlan_tag', 'iface_comment', 'iface_http_mgmt', 'iface_https_mgmt', 'iface_ssh_mgmt', 'iface_ping_mgmt', 'iface_snmp_mgmt', 'portShutdown']

if not True:
    import sonicwall as sw
    import re

    binddn_passwords = {'cn=ServiceFWRWemeaprod,ou=service accounts,dc=emea,dc=dell,dc=com'.lower(): 'password1',
                        'cn=ServiceFWRWamerprod,ou=service accounts,dc=amer,dc=dell,dc=com'.lower(): 'password2',
                        'cn=ServiceFWRWapjprod,ou=service accounts,dc=apj,dc=dell,dc=com'.lower(): 'password3'
                        }

    target = '10.215.16.60'
    target = '10.67.73.13'
    options.username = 'admin'
    options.password = 'admin'
    session = requests.Session()
    session.mount('https://' + target, sw.DESAdapter())
    response = sw.do_login(session, options.username, options.password, target, True)
    # 'cgiaction': 'none',
    url = 'https://' + target + '/main.cgi'
    response = sw.get_url(session, 'https://' + target + '/ldapProps.html')
    print(response.text)
    try:
        loginname = re.findall(r'var loginName.*', response.text)[0].split('"')[1].lower()
        print(binddn_passwords[loginname])
    except Exception as e:
        print('Could not get current Bind DN setting')
        print(e)

    sw.do_logout(session, target)
    print(binddn_passwords)

if options.ldap:
    import sonicwall as sw
    import getpass
    import re

    binddn_passwords = {
        'cn=servicefwrwemeaprod,ou=service accounts,dc=emea,dc=dell,dc=com'.lower(): 'g-VoY%9r2WKj?mnA+ZQ_d1Xt',
        'cn=servicefwrwamerprod,ou=service accounts,dc=amer,dc=dell,dc=com'.lower(): 'ypC4w_eFju3t?rZQX7A~V0b+',
        'cn=servicefwrwapjprod,ou=service accounts,dc=apac,dc=dell,dc=com'.lower(): '+E-?_Td1MqFvA43GIP2nBHj~'}

    # servicefwrwemeaprod,ou=service accounts,dc=emea,dc=dell,dc=com
    options.username = 'admin'
    # swis_username = input                ("  Solarwinds Username : ")
    # swis_password = getpass.getpass      ("  Solarwinds Password : ")
    # swis_username='jeff_miller2'

    options.password = input('       Admin password : ')
    val_username = input("  Validation Username : ")
    val_password = input("  Validation Password : ")

    import requests
    from orionsdk import SwisClient
    from getpass import getpass
    import json

    npm_server = 'solarwindscs.dell.com'

    verify = False
    if not verify:
        from requests.packages.urllib3.exceptions import InsecureRequestWarning

        requests.packages.urllib3.disable_warnings(InsecureRequestWarning)

    # swis = SwisClient(npm_server, swis_username, swis_password)
    # results = swis.query('''SELECT  O.NodeID, O.Caption as NodeName, O.IPAddress, O.Status, NodeDescription, Asset_State as AssetState, O.IOSVersion as Version, C.Cyber_Security_Classification as Classification
    # FROM Orion.Nodes O
    # INNER JOIN Orion.NodesCustomProperties AS C ON O.NodeID = C.NodeID
    # WHERE C.SNOW_Product_Name like '%Sonic%fire%' AND NodeDescription like '%SonicWALL%' and C.DeviceType = 'Core Controller'
    # ORDER BY NodeName ''')

    # results = swis.query('''SELECT  O.NodeID, O.Caption as NodeName, O.IPAddress, O.Status, NodeDescription, Asset_State as AssetState, O.IOSVersion as Version, C.Cyber_Security_Classification as Classification, C.Region, C.DeviceType
    # FROM Orion.Nodes O
    # INNER JOIN Orion.NodesCustomProperties AS C ON O.NodeID = C.NodeID
    # WHERE C.SNOW_Product_Name like '%Sonic%fire%' AND NodeDescription like '%SonicWALL%'
    # RDER BY NodeName ''')

    results = {}
    results['results'] = [({'IPAddress': '10.215.16.61', 'NodeID': 1226, 'Classification': 'Medium',
                            'AssetState': 'Post-Production', 'Status': 1, 'Version': ' 6.2.5.4-1n',
                            'NodeName': 'blr12swfwcorp01',
                            'NodeDescription': 'SonicWALL SuperMassive 9400 (SonicOS Enhanced 6.2.5.4-1n)'})]

    # log(results)
    val_result = None
    log('|{:30.30s}|{:17.17s}|{:8.8s}|{:8.8s}|{:8.8s}|{:11.11}|{:11.11}|{:11.11}|{:11.11}|{:8.8}|{:8.8}|{:19.19}|{:12.12}|'.format(
        'Device Name', 'IP Address', 'Status', 'HA Mode', 'HA State', 'Create RO', 'Create RW', 'Remove RO',
        'Remove RW', 'Add RO', 'Add RW', 'LDAP BindDN Found', 'Validation'))
    for row in results['results']:
        # log(row)
        log("-" * 180)
        # print("{}".format(row))
        target = row['IPAddress']
        if row['Status'] == 1:  # only devices that are "UP"
            if len([value for value in options.ldap if value in ['all', 'any']]) > 0 or row[
                'Classification'].lower() in [x.lower() for x in options.ldap]:
                session = requests.Session()
                session.mount('https://' + target, sw.DESAdapter())
                # log(target, options.username, options.password)
                response = sw.do_login(session, options.username, options.password, target, True)
                # log(response)
                if response:
                    response = sw.get_url(session,
                                          'https://' + target + '/getJsonData.json?_=1566657857&dataSet=alertStatus')
                    resp_json = json.loads(response.text)
                    if 'svrrpNodeState' in resp_json and 'svrrpHaMode' in resp_json:
                        active = (resp_json['svrrpNodeState'].lower() == 'active' or resp_json[
                            'svrrpHaMode'].lower() == 'standalone')
                        # log('Firewall HA Mode : ', resp_json['svrrpHaMode'])
                        # log('Firewall State   : ', resp_json['svrrpNodeState'].lower())
                        if active:
                            url = 'https://' + target + '/main.cgi'
                            postdata = {
                                'iStartItem': '1',
                                'error_page': 'groupObjView.html',
                                'refresh_page': '',
                                'userGroupObjId_-1': 'CS_FIREWALL_RW',
                                'userGroupObjComment_-1': 'Read-Write PAC Group',
                                'userGroupObjType_-1': '2',
                                'userGroupObjProperties_-1': '16398',
                                'userGroupObjPrivMask_-1': '128',
                                'userGroupObjVpnDestNet_-1': '',
                                'userGroupObjCfspId_-1': '0',
                                'userGroupOtpReq_-1': '0',
                                'userGroupObjLdapLocn_-1': 'emea.dell.com/AdmAccounts/PrivilegedGroups/CS_Firewall_RW'
                            }
                            create_rw_result = 'Skipped'  # send_sw_webcmd(session, url, postdata)
                            # log('Create CIS_FIREWALL_RW : ', result)

                            postdata = {'uo_atomToGrp_-3': 'CIS_SFW_RW',
                                        'uo_grpToGrp_-3': 'SonicWALL Administrators'
                                        }
                            del_rw_result = 'Skipped'  # send_sw_webcmd(session, url, postdata)
                            # log('Remove CIS_SFW_RW from SonicWALL Administrators : ', result)

                            postdata = {'uo_atomToGrp_0': 'CS_FIREWALL_RW',
                                        'uo_grpToGrp_0': 'SonicWALL Administrators'
                                        }

                            add_rw_result = 'Skipped'  # send_sw_webcmd(session, url, postdata)
                            # log('Add CIS_FIREWALL_RO to SonicWALL Administrators : ', result)

                            postdata = {
                                'iStartItem': '1',
                                'error_page': 'groupObjView.html',
                                'refresh_page': '',
                                'userGroupObjId_-1': 'CS_FIREWALL_RO',
                                'userGroupObjComment_-1': 'Read-Only PAC Group',
                                'userGroupObjType_-1': '2',
                                'userGroupObjProperties_-1': '16398',
                                'userGroupObjPrivMask_-1': '128',
                                'userGroupObjVpnDestNet_-1': '',
                                'userGroupObjCfspId_-1': '0',
                                'userGroupOtpReq_-1': '0',
                                'userGroupObjLdapLocn_-1': 'emea.dell.com/AdmAccounts/PrivilegedGroups/CS_Firewall_RO'
                            }
                            create_ro_result = 'Skipped'  # send_sw_webcmd(session, url, postdata)
                            # log('Create CIS_FIREWALL_RO :', result)

                            postdata = {'uo_atomToGrp_-3': 'CIS_SFW_RO',
                                        'uo_grpToGrp_-3': 'SonicWALL Read-Only Admins'
                                        }
                            del_ro_result = 'Skipped'  # send_sw_webcmd(session, url, postdata)
                            # log('Remove CIS_SFW_RO from SonicWALL Administrators : ', result)

                            postdata = {'uo_atomToGrp_0': 'CS_FIREWALL_RO',
                                        'uo_grpToGrp_0': 'SonicWALL Read-Only Admins'
                                        }

                            add_ro_result = 'Skipped'  # send_sw_webcmd(session, url, postdata)
                            # log('Add CIS_FIREWALL_RO to SonicWALL Read-Only Admins : ', result)

                            postdata = {'ldapServerBindPwd': 'newpassword'}
                            # result=send_sw_webcmd(session, url, postdata)
                            # log('Change LDAP password : ', result)
                            response = sw.get_url(session, 'https://' + target + '/ldapProps.html')
                            try:
                                loginname = re.findall(r'var loginName.*', response.text)[0].split('"')[1].lower()
                                # log('Changing Password for Bind DN : ', loginname)
                                if loginname.lower() in binddn_passwords:
                                    postdata = {'ldapServerBindPwd': binddn_passwords[loginname.lower()]}
                                    result = send_sw_webcmd(session, url, postdata)
                                    # log('Change LDAP password : ', result)
                                    # log('Changing Password for Bind DN "{}" : {}', format(loginname, result))
                                    bind_result = True
                                else:
                                    log('Unable to change password for Bind DN : ', loginname)
                                    bind_result = False
                            except Exception as e:
                                try:
                                    loginname = re.findall(r'new LdapSrvr.*', response.text)[0].split('"')[3]
                                    log(loginname)
                                    bind_result = True
                                except:
                                    log('Could not get current Bind DN setting')
                                    log(e)
                                    # log(response.text)
                                    bind_result = False

                            response = sw.get_url(session, 'https://' + target + '/systemToolsView.html')
                            csrf = re.findall(r'csrfToken.*"', response.text)[0].split('value=')[1].split('"')[1]
                            log('csrf', csrf)
                            url = 'https://' + target + '/main.cgi'
                            postdata = {'csrfToken': csrf,
                                        'cgiaction': "none",
                                        'ldapCgiAction': "0",
                                        'ldapCgiActnSrvrName': "",
                                        'ldapCgiActnParam': "",
                                        'isLdapPost': "",
                                        'ldapSrvrHostName_-2': "ausdcamer.amer.dell.com",
                                        'ldapSrvrHostName_0': "ausdcamer.amer.dell.com",
                                        'ldapSrvrBindName_0': "newuser3",
                                        'ldapSrvrPort_0': "3269",
                                        'ldapSrvrBindType_0': "1"
                                        }
                            '''
                            csrfToken	"F2C10AD96A1B83D7DAE0DF371BA6F87C"
radiusDfltUserGroup	""
cgiaction	"none"
ldapCgiAction	"0"
ldapCgiActnSrvrName	""
ldapCgiActnParam	""
isLdapPost	""
ldapTreesAutoConfDomain	""
protocolSel	"LDAP+version+3"
tlsCertSel	"--None--"
ldapProtocolVer	"3"
cbox_ldapTlsRequireServerCert	""
ldapTlsCertName	""
ldapAllowReferrals_0	"on"
ldapAllowReferrals_2	"on"
ldapAllowReferrals_3	"on"
cbox_ldapAllowReferrals_0	""
cbox_ldapAllowReferrals_1	""
cbox_ldapAllowReferrals_2	""
cbox_ldapAllowReferrals_3	""
selDfltUserGroup	"0"
gcMirrorDelGrpsMeth	"1"
ldapMirrorGlbCatDelGrpsDtct	"1"
cbox_userRadiusCheckLocal	""
cbox_ldapUsrGrpMirroring	""
ldapRelayOnWAN	"on"
ldapRelayOnVPN	"on"
ldapRelaySecret	""
ldapRelayLegacyVpnUsrGrp	""
ldapRelayLegacyVpnClientGrp	""
ldapRelayLegacyL2TPUsrGrp	""
ldapRelayLegacyInetUsrGrp	""
ldapRelayHashSecret	""
cbox_ldapRelayEnable	""
cbox_ldapRelayOnLAN	""
cbox_ldapRelayOnWAN	""
cbox_ldapRelayOnDMZ	""
cbox_ldapRelayOnWLAN	""
cbox_ldapRelayOnVPN	""
remAuthTstSelAgent	"ausdcamer.amer.dell.com"
ldapTstType	"0"
Radius_user	""
Radius_passwd	""
usrTstProtocol	"0"
srchTstFltr	""
srchTstVal	""
srchTstAttrs	""
remAuthTstProtocol	""
remAuthTstParam	""
remAuthTstType	"-1"
treeAutoConfAppend	"on"
treeAutoConf2ndRef	"on"
readSchemaActn	"on"
imprtGrpsTypRadio	"on"
imprtSrvrSelRadio	"on"
imprtUoGsDomRadio	"dom"
rNum	"F63D1AE61011252D1353A082C8D12ADD"
testType	"1"
testDesc	"LDAP+server"
ldapSrvrHostName_-2	"ausdcamer.amer.dell.com"
ldapSrvrHostName_0	"ausdcamer.amer.dell.com"
ldapSrvrPort_0	"3269"
ldapSrvrRole_0	"0"
ldapSrvrEnabled_0	"on"
ldapSrvrBindType_0	"1"
ldapSrvrBindName_0	"asdasdads"
ldapSrvrBindTree_0	""
ldapSrvrBindRefAcctUse_0	"1"
ldapSrvrUsrDomain_0	"dell.com"
ldapSrvrUseTls_0	"on"
ldapSrvrNegTls_0	"off"
ldapSrvrTimeout_0	"10"
ldapSrvrOpnTimeout_0	"5"
ldapSrvrBackupFor_0	""
ldapSrvrAuthPartition_0	""
ldapSrvrBindPwd_0	""
ldapSrvrBindHashPwd_0	""
ldapSrvrUsrObjClass_0	"user"
ldapSrvrUsrLogonNameAttr_0	"sAMAccountName"
ldapSrvrUsrQualLogonAttr_0	"userPrincipalName"
ldapSrvrUsrGrpAttr_0	"memberOf"
ldapSrvrUsrOtherGrpAttr_0	"primaryGroupID"
ldapSrvrUsrUseOtherGrpAttr_0	"off"
ldapSrvrUsrFrmdIpAttr_0	"msRADIUSFramedIPAddress"
ldapSrvrUsrGrpObjClass_0	"group"
ldapSrvrUsrGrpMbrAttr_0	"member"
ldapSrvrUsrGrpMbrType_0	"0"
ldapSrvrUsrGrpOthrMatchAttr_0	"primaryGroupToken"
auditPath	"MANAGE+/+Users+/+Settings+/+LDAP+Configuration"
                            
                            '''

                            result = send_sw_webcmd(session, url, postdata)
                            log(result)

                            sw.do_logout(session, target)
                            val_result = sw.do_login(session, val_username, val_password, target, True)
                            # log('Validation check : ', response)
                            sw.do_logout(session, target)
                            if val_result:
                                log('|{:30.30s}|{:17.17s}|{:8.8s}|{:8.8s}|{:8.8s}|{:11.11s}|{:11.11s}|{:11.11s}|{:11.11s}|{:8.8s}|{:8.8s}|{:19.19s}|{:12.12s}|'.format(
                                    row['NodeName'], row['IPAddress'], 'Passed', resp_json['svrrpHaMode'],
                                    resp_json['svrrpNodeState'], str(create_ro_result), str(create_rw_result),
                                    str(del_ro_result), str(del_rw_result), str(add_ro_result), str(add_rw_result),
                                    str(bind_result), str(val_result)))
                            else:
                                log('|{:30.30s}|{:17.17s}|{:8.8s}|{:8.8s}|{:8.8s}|{:11.11s}|{:11.11s}|{:11.11s}|{:11.11s}|{:8.8s}|{:8.8s}|{:19.19s}|{:12.12s}|'.format(
                                    row['NodeName'], row['IPAddress'], 'Failed', resp_json['svrrpHaMode'],
                                    resp_json['svrrpNodeState'], str(create_ro_result), str(create_rw_result),
                                    str(del_ro_result), str(del_rw_result), str(add_ro_result), str(add_rw_result),
                                    str(bind_result), str(val_result)))

                        else:
                            log('|{:30.30s}|{:17.17s}|{}|{}|'.format(row['NodeName'], row['IPAddress'], 'Skipped',
                                                                     'Not Active Appliance in HA Pair'))
                            # log('This node is not the active node of an HA pair')
                    else:
                        log('|{:30.30s}|{:17.17s}|{}|{}|'.format(row['NodeName'], row['IPAddress'], 'Skipped',
                                                                 'Unable to determine device state'))

                else:
                    log('|{:30.30s}|{:17.17s}|{}|{}|'.format(row['NodeName'], row['IPAddress'], 'Skipped',
                                                             'Admin Login Failed'))
            else:
                log('|{:30.30s}|{:17.17s}|{}|{}|'.format(row['NodeName'], row['IPAddress'], 'Skipped',
                                                         'Classification Mismatch'))
        else:
            log('|{:30.30s}|{:17.17s}|{}|{}|'.format(row['NodeName'], row['IPAddress'], 'Skipped',
                                                     'Solarwinds Reports Node Down'))

if options.recheck:  ## not sure what these routines were meant to do.  Perhaps to check LDAP auth and then use admin account to perform DNS and ping checks on LDAP FQDN
    import sonicwall as sw
    import getpass
    import re
    from bs4 import BeautifulSoup as bs

    verify = False
    if not verify:
        from requests.packages.urllib3.exceptions import InsecureRequestWarning

        requests.packages.urllib3.disable_warnings(InsecureRequestWarning)

    val_username = input("  Validation Username : ")
    val_password = input("  Validation Password : ")

    for target in options.recheck:
        url = 'https://' + target + '/main.cgi'
        session = requests.Session()
        session.mount('https://' + target, sw.DESAdapter())

        val_result = sw.do_login(session, val_username, val_password, target, False, 30)
        # log('Validation check : ', response)

        if not val_result:
            log('{},{}'.format(target, 'User Login Failed'))
            '''    #log('validation failed, checking dns settings')
            get_username = 'admin'
            
            #get_password = 'admin'

            session = requests.Session()
            session.mount('https://' + target, sw.DESAdapter()) 
            if sw.do_login(session, get_username, get_password, target, False):
                log('{},{}'.format(target,'admin login successful'))
                #log('admin login successful')
                response=sw.get_url(session, 'https://' + target + '/systemToolsView.html')
                csrf=re.findall(r'csrfToken.*"',response.text)[0].split('value=')[1].split('"')[1]
                #log('csrf value : ', csrf)

                postdata = {    'csrfToken': csrf, 
                                'refresh_page': 'systemToolsView.html', 
                                'cgiaction': 'dnsLookup', 
                                'dnsName': 'ausdcamer.amer.dell.com' }

                try:
                    result=send_sw_webcmd(session, url, postdata, timeout=options.timeout_sw_webui)
                    #log('DNS lookup send result :', result)
                    response=sw.get_url(session, 'https://' + target + '/systemToolsView.html')
                    #log(response.text)
                    soup = bs(response.text, 'lxml')
                    #log(re.findall(r'Resolved.*',soup.find_all('table')[-1].find_all('tr')[0] ))
                    log('{},{},{}'.format(target, 'Resolved Address', soup.find_all('table', text="Resolved Address")))
                    #log(re.findall(r'ausdcamer.amer.dell.com*', response.text))
                except Exception as e:
                    log('{},{},{}'.format(target, 'Resolve Address', 'Fatal Error trying to resolve address'))
                    log(e)

                    #log('csrf value : ', csrf)
            
                postdata = {    'csrfToken': csrf,
                                'refresh_page': 'systemToolsView.html',
                                'cgiaction': 'ping',
                                'pingAddr': '10.8.8.8',
                                'dtIpv6Preferred': 'off',
                                'cbox_dtIpv6Preferred': '',
                                'diagToolInterface': '-1' }
            
                try:
                    result=send_sw_webcmd(session, url, postdata, timeout=options.timeout_sw_webui)
                    #log('Ping LDAP result : ', result)
                    response=sw.get_url(session, 'https://' + target + '/systemToolsView.html')
                    soup = bs(response.text, 'lxml')
                    #log(response.text)
                    #log(re.findall(r'10.8.8.8.*', response.text))
                    log('{},{},{}'.format(target,'Ping Result', soup.find_all('table', text='labelHeading')[-1].find_all('tr')[-1].find_all('td')[-1].get_text(strip=True)))
                except:
                    log('{},{},{}'.format(target, 'Ping Result', 'Fatal Error trying to ping address'))
                sw.do_logout(session, target)
            else:
                log('{},{}'.format(target,'admin login failed'))
        '''


        else:
            log('{},{}'.format(target, 'User Login Successful'))
            sw.do_logout(session, target)
        # if not val_result:

if not True:
    for context in contexts:
        for address in config[context]['addresses']:
            log(config[context]['addresses'][address]['addrObjIp1'])

if options.gms:  ## clear GMS enabled checkbox
    import sonicwall as sw
    import getpass
    import re
    from bs4 import BeautifulSoup as bs

    # get_username='admin'
    # get_password='admin'
    get_username = options.username
    get_password = options.password
    target = options.gms
    url = 'https://' + target + '/main.cgi'
    session = requests.Session()
    # log(url)
    session.mount('https://' + target, sw.DESAdapter())
    login_result = sw.do_login(session, get_username, get_password, target, True,
                               timeout=options.timeout_sw_webui_login)
    if login_result:
        # print(login_result)
        # response=sw.get_url(session, 'https://' + target + '/systemToolsView.html', timeout=options.timeout_sw_webui)
        # csrf=re.findall(r'csrfToken.*"',response.text)[0].split('value=')[1].split('"')[1]
        # postdata = {    'csrfToken': csrf,
        #                'cbox_useGlobalMgt': '' }
        # postdata = {    'csrfToken': csrf,                         'useGlobalMgt': 'off' }
        ##postdata = { 'csrfToken': csrf, 'cgiaction': 'updateSecServInfo' }
        # result=send_sw_webcmd(session, url, postdata, timeout=options.timeout_sw_webui)

        response = session.get('https://{}/systemAdministrationView.html'.format(target), verify=False,
                               timeout=options.timeout_sw_webui)
        # debug(response.text)
        if response.status_code == 200:
            try:
                soup = bs(response.text, 'lxml')
                isGMSEnabled = soup.find('input', attrs={'name': 'useGlobalMgt'}).has_attr('checked')  # isIDPEnabled
            except:
                isGMSEnabled = None
        else:
            isGMSEnabled = None
        result = isGMSEnabled
        log('{},{}'.format(target, result))
        sw.do_logout(session, target)
    else:
        log('{},{},{}'.format(target, 'Login Failed', login_result))

if not True:  # find bi-directional rules

    from netaddr import IPSet
    import re
    import ipaddress

    for context in config:
        # log(config[context])
        if 'policies' in config[context]:
            for policy in config[context]['policies']:
                # log(context)

                srcSet = IPSet([])
                dstSet = IPSet([])

                for source_index in config[context]['policies'][policy]['policySrcNet']:
                    if source_index.lower() == 'any' and options.zero_network:
                        found_in_source = True
                        source_addr = ['Any']
                        break
                    policyIPv4_srclist = []
                    if (source_index in config[context]['addresses']):
                        for expanded_index in expand_address(config[context]['addresses'],
                                                             config[context]['addresses'][source_index]['addrObjId'],
                                                             config[context]['addressmappings']):
                            if (expanded_index in config[context]['addresses']):
                                policyIPv4_srclist.extend(config[context]['addresses'][expanded_index]['IPv4Networks'])
                            elif (expanded_index in config['shared']['addresses']):
                                policyIPv4_srclist.extend(config['shared']['addresses'][expanded_index]['IPv4Networks'])
                    elif (source_index in config['shared']['addresses']):
                        for expanded_index in expand_address(config['shared']['addresses'],
                                                             config['shared']['addresses'][source_index]['addrObjId'],
                                                             config['shared']['addressmappings']):
                            policyIPv4_srclist.extend(config['shared']['addresses'][expanded_index]['IPv4Networks'])
                            prefix = '*'
                    else:
                        # if source_index.lower() not in ['any', '']: log('UNKNOWN SOURCE "{}"'.format(source_index))
                        try:
                            if re.findall('-', source_index) != []:
                                first, last = source_index.split('-')
                                for x in ipaddress.summarize_address_range(ipaddress.IPv4Address(first),
                                                                           ipaddress.IPv4Address(last)):
                                    policyIPv4_srclist.extend([x])
                            else:
                                first = source_index
                                last = source_index
                                if re.findall('/', first) == []:
                                    first = first + '/32'
                                policyIPv4_srclist.extend([ipaddress.IPv4Network(first)])
                        except Exception as e:
                            debug(e, 'UNKNOWN SOURCE "{}"'.format(source_index))
                            pass

                    srcSet = IPSet([])
                    for x in policyIPv4_srclist:
                        srcSet.add(str(x))

                for dest_index in config[context]['policies'][policy]['policyDstNet']:
                    if dest_index.lower() == 'any' and options.zero_network:
                        found_in_dest = True
                        dest_addr = ['Any']
                        break
                    policyIPv4_dstlist = []
                    if (dest_index in config[context]['addresses']):
                        for expanded_index in expand_address(config[context]['addresses'],
                                                             config[context]['addresses'][dest_index]['addrObjId'],
                                                             config[context]['addressmappings']):
                            if (expanded_index in config[context]['addresses']):
                                policyIPv4_dstlist.extend(config[context]['addresses'][expanded_index]['IPv4Networks'])
                            elif (expanded_index in config['shared']['addresses']):
                                policyIPv4_dstlist.extend(config['shared']['addresses'][expanded_index]['IPv4Networks'])
                    elif (dest_index in config['shared']['addresses']):
                        for expanded_index in expand_address(config['shared']['addresses'],
                                                             config['shared']['addresses'][dest_index]['addrObjId'],
                                                             config['shared']['addressmappings']):
                            policyIPv4_dstlist.extend(config['shared']['addresses'][expanded_index]['IPv4Networks'])
                            prefix = '*'
                    else:
                        try:
                            if re.findall('-', dest_index) != []:
                                first, last = dest_index.split('-')
                                for x in ipaddress.summarize_address_range(ipaddress.IPv4Address(first),
                                                                           ipaddress.IPv4Address(last)):
                                    policyIPv4_dstlist.extend([x])
                            else:
                                first = dest_index
                                last = dest_index
                                if re.findall('/', first) == []:
                                    first = first + '/32'
                                policyIPv4_dstlist.extend([ipaddress.IPv4Network(first)])
                        except Exception as e:
                            debug(e, 'UNKNOWN DESTINATION "{}"'.format(dest_index))
                            pass
                    dstSet = IPSet([])
                    for x in policyIPv4_dstlist:
                        dstSet.add(str(x))
                searchset = IPSet([])
                searchset.add(str(ipaddress.IPv4Network('10.0.0.0/8')))
                # log(dstSet)
                if (ipaddress.IPv4Network('10.0.0.0/8') in policyIPv4_dstlist) and (
                        ipaddress.IPv4Network('10.0.0.0/8') in policyIPv4_srclist):
                    log('{},{},{},{}'.format(context, config[context]['policies'][policy]['policyName'],
                                             config[context]['policies'][policy]['policySrcNet'],
                                             config[context]['policies'][policy]['policyDstNet']))

if not True:  ## find services using a portlist
    for context in contexts:
        print(context)
        if 'services' in config[context]:
            for service in config[context]['services']:
                portlist = get_ports_of(config[context]['services'], config[context]['services'][service]['svcObjId'])
                if len(portlist) < 100:
                    pass
                    # print(config[context]['services'][service]['svcObjId'], portlist)
                # print(get_ports_of(config[context]['services'], config[context]['services'][service]['svcObjId']))

if options.setlogprofile:  ## set log profile for rules on panorama -- too many edits in a short period of time causes issues- palo recommended a 10 sec delay between edits.  wound up doing this via bash using xmlstarlet
    target = options.panoramaip

    commands = []

    for context in options.context:
        changes = {'logs': 0, 'start': 0, 'end': 0, 'comments': 0}
        if options.setlogprofile not in config[context]['logprofiles'] and options.setlogprofile not in \
                config['shared']['logprofiles']:
            log('ERROR! Log Profile {} not available to Device-Group: {}'.format(options.setlogprofile, context))

        else:

            if context != 'shared':
                # print(context)
                for policy in config[context]['policies']:
                    # print(config[context]['policies'][policy]['policyLogSetting'])
                    modified = False
                    if config[context]['policies'][policy]['policyLogSetting'] != options.setlogprofile:
                        commands.append(('modify_rule', {'context': context,
                                                         'policyname': config[context]['policies'][policy][
                                                             'policyName'], 'action': 'log-setting',
                                                         'log-setting': options.setlogprofile}))
                        changes['logs'] += 1
                        modified = True
                    if config[context]['policies'][policy]['policyLogStart'].lower() != 'no':
                        commands.append(('modify_rule', {'context': context,
                                                         'policyname': config[context]['policies'][policy][
                                                             'policyName'], 'action': 'log-start', 'log-start': 'no'}))
                        changes['start'] += 1
                        modified = True
                    if config[context]['policies'][policy]['policyLogEnd'].lower() != 'yes':
                        commands.append(('modify_rule', {'context': context,
                                                         'policyname': config[context]['policies'][policy][
                                                             'policyName'], 'action': 'log-end', 'log-end': 'yes'}))
                        changes['end'] += 1
                        modified = True
                    if modified == True:
                        if config[context]['policies'][policy]['policyComment'] == '':
                            commands.append(('modify_rule', {'context': context,
                                                             'policyname': config[context]['policies'][policy][
                                                                 'policyName'], 'action': 'comment',
                                                             'comment': config[context]['policies'][policy][
                                                                            'policyComment'] + 'CHG0243187 - Fix Log Settings (Profile/Start-End)'}))
                            changes['comments'] += 1
                        else:
                            commands.append(('modify_rule', {'context': context,
                                                             'policyname': config[context]['policies'][policy][
                                                                 'policyName'], 'action': 'comment',
                                                             'comment': config[context]['policies'][policy][
                                                                            'policyComment'] + '\n' + 'CHG0243187 - Fix Log Settings (Profile/Start-End)'}))
                            changes['comments'] += 1

                log('Summary of updates needed for Device Group {}: Log Profiles: {}, Log-Start: {}, Log-End: {}, Comments: {}'.format(
                    context, changes['logs'], changes['start'], changes['end'], changes['comments']))
            # for command in commands:
            #    print(command)
            log('Starting API pushes for {} commands'.format(str(len(commands))))
            exec_fw_command(target, 'pano', commands, syntax='api', delay=None, use_session=True)
            # exec_fw_command(target, 'pano', [('modify_rule', { 'context': context, 'policyname': config[context]['policies'][policy], 'action': 'comment', 'comment': config[context]['policies'][policy]['policyComment'] + '\n' + + 'CHGXXXX' })] ,syntax='api')
            # exec_fw_command(target, 'pano', [('modify_rule', { 'context': context, 'policyname': config[context]['policies'][policy], 'action': 'log-start', 'log-start':  'no' })] ,syntax='api')
            # exec_fw_command(target, 'pano', [('modify_rule', { 'context': context, 'policyname': config[context]['policies'][policy], 'action': 'log-end', 'log-end': 'yes' })] ,syntax='api')

if False:  ## Get Syslog server details
    import re
    import sonicwall as sw
    import pandas
    from urllib.parse import quote, unquote

    matched_context = None
    matched_object = None

    for context in contexts:
        if context != 'shared':
            matched_context = context
            break
    if matched_context:
        session = requests.Session()
        session.mount('https://' + options.sonicwallip, sw.DESAdapter())
        urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
        if not options.web and (options.username == None or options.password == None):
            options.username, options.password = get_creds()
        response = sw.do_login(session, options.username, options.password, options.sonicwallip, True)
        if response:
            url = 'https://' + options.sonicwallip + '/logSyslogView.html'
            response = sw.get_url(session, url)
            if response:
                data = response.content
                try:
                    tl = pandas.read_html(data, match='Server Name')
                    df = tl[0]
                    # print (df.to_string(index=False, na_rep='',header=False))
                    for table in tl:
                        # print(table)
                        # print(table[0][1])
                        # print(len(table))
                        for row in range(1, len(table) - 1):
                            pattern = re.compile("\((.+)\)")
                            if pattern.search(table[0][row]):
                                server = pattern.search(table[0][row]).group(0)[1:-1]
                                print('{:40.40s}{:100.100s}{:10.10s}'.format(matched_context, server, table[1][row]))
                                # for context in config['config']:
                                #    print(context)

                                server_lower = quote(server, safe='()').lower()
                                debug('"{}"'.format(server_lower))
                                for address in config[matched_context]['addresses']:
                                    debug('"{}"'.format(address))
                                    if address.lower() == server_lower:
                                        matched_object = ('addresses', address)
                                        break
                                if not matched_object:
                                    for address in config[matched_context]['addressesfqdn']:
                                        debug('"{}"'.format(address))
                                        if address.lower() == server_lower:
                                            matched_object = ('addressesfqdn', address)
                                            break

                                if matched_object:
                                    obj_type, obj_name = matched_object
                                    # print(config[matched_context][obj_type][obj_name])
                                # print('-'*100)
                except Exception as e:
                    print(e)
                    print('{:40.40s}{:100.100s}{:10.10s}'.format(matched_context, "Syslog Table not Found", ""))
            else:
                print('{:40.40s}{:100.100s}{:10.10s}'.format(matched_context, "Get Syslog Page Failed", ""))
            sw.do_logout(session, options.sonicwallip)
        else:
            print('{:40.40s}{:100.100s}{:10.10s}'.format(options.sonicwallip, "Login Failed", ""))

if not True:  ## check if sonicwall has current password
    old_password = '$0n'
    import sonicwall as sw

    for target in options.grouptargets:
        session = requests.Session()
        session.mount('https://' + target, sw.DESAdapter())
        urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
        if not options.web and (options.username == None or options.password == None):
            options.username, options.password = get_creds()

        response = sw.do_login(session, options.username, options.password, target, True)
        if response:
            log(target, 'new')
        else:
            response = sw.do_login(session, options.username, old_password, target, True)
            if response:
                log(target, 'old')
            else:
                log(target, 'unknown')

if not True:  # modify/fix LDAP user groups in 6.5
    import sonicwall as sw
    import json
    import re
    import time
    from collections import OrderedDict

    urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
    for target in options.grouptargets:
        log(target)
        session = requests.Session()
        session.mount('https://' + target, sw.DESAdapter())
        urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
        sw.do_login(session, 'admin', 'snowflake', target, preempt=True)
        response = sw.get_url(session, 'https://' + target + '/addUserObjGroupDlg.html')
        csrf = re.findall(r'csrfToken.*"', response.text)[0].split('value=')[1].split('"')[1]
        postdata = {'csrfToken': csrf,
                    'cgiaction': "none",
                    'error_page': 'userObjView.html',
                    'refresh_page': '',
                    'userGroupObjId_-2': 'CS_FIREWALL_RW',
                    'userGroupObjComment_-2': 'Read-Write PAC Group',
                    'userGroupObjType_-2': '2',
                    'userGroupObjProperties_-2': '16398',
                    'userGroupObjPrivMask_-2': '128',
                    'userGroupObjVpnDestNet_-2': '',
                    'userGroupOtpReq_-2': '0',
                    'userGroupObjLdapLocn_-2': 'emea.dell.com/AdmAccounts/PrivilegedGroups/CS_Firewall_RW',

                    'userGroupObjId_1': 'CS_FIREWALL_RW',
                    'userGroupObjComment_1': 'Read-Write PAC Group',
                    'userGroupObjType_1': '2',
                    'userGroupObjProperties_1': '131086',
                    'userGroupObjPrivMask_1': '128',
                    'userGroupObjVpnDestNet_1': '',
                    'userGroupOtpReq_1': '0',
                    'userGroupObjLdapLocn_1': 'emea.dell.com/AdmAccounts/PrivilegedGroups/CS_Firewall_RW',
                    'auditPath': 'MANAGE / Users / Local Users & Groups / Edit Group'}
        # 'userGroupObjProperties_-2': "131086",
        # 'userGroupObjComment_-2': 'Read-Only PAC Group',
        # 'userGroupObjType_-2': '2',
        # 'userGroupObjProperties_-2': '131086',
        # 'userGroupObjPrivMask_-2': '128',
        # 'userGroupObjVpnDestNet_-2': '',
        # 'userGroupOtpReq_-2': '0',
        # 'userGroupObjLdapLocn_-2': 'emea.dell.com/AdmAccounts/PrivilegedGroups/CS_Firewall_RO',
        # 'auditPath': 'MANAGE / Users / Local Users & Groups / Edit Group',
        # 'userGroupObjId_1':	"CS_FIREWALL_RO",
        # 'userGroupObjProperties_1': "131086",
        # 'userGroupObjComment_1': 'Read-Only PAC Group',
        # 'userGroupObjType_1': '2',
        # 'userGroupObjProperties_1': '131086',
        # 'userGroupObjPrivMask_1': '128',
        # 'userGroupObjVpnDestNet_1': '',
        # 'userGroupOtpReq_1': '0',
        # 'userGroupObjLdapLocn_1': 'emea.dell.com/AdmAccounts/PrivilegedGroups/CS_Firewall_RO',
        # 'auditPath': 'MANAGE / Users / Local Users & Groups / Edit Group'

        url = 'https://' + target + '/main.cgi'
        result = send_sw_webcmd(session, url, postdata)
        log('change group result', result)

        response = sw.get_url(session, 'https://' + target + '/addUserObjGroupDlg.html')
        csrf = re.findall(r'csrfToken.*"', response.text)[0].split('value=')[1].split('"')[1]
        postdata = {'csrfToken': csrf,
                    'cgiaction': "none",
                    'error_page': 'userObjView.html',
                    'refresh_page': '',
                    'userGroupObjId_-1': 'CS_FIREWALL_RO',
                    'userGroupObjComment_-1': 'Read-Only PAC Group',
                    'userGroupObjType_-1': '2',
                    'userGroupObjProperties_-1': '131086',
                    'userGroupObjPrivMask_-1': '0',
                    'userGroupObjVpnDestNet_-1': '',
                    'userGroupObjCfspId_-1': '0',
                    'userGroupOtpReq_-1': '0',
                    'userGroupObjLdapLocn_-1': 'emea.dell.com/AdmAccounts/PrivilegedGroups/CS_Firewall_RO'
                    }
        url = 'https://' + target + '/main.cgi'
        # result=send_sw_webcmd(session, url, postdata)
        # log('add group result', result)

        sw.do_logout(session, target)

if not True:
    import sonicwall as sw
    import json
    import re
    import time
    from collections import OrderedDict
    import sonicwall as sw
    import re

    urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

    for target in options.grouptargets:

        ## Enable API first

        session = requests.Session()
        session.mount('https://' + target, sw.DESAdapter())
        sw.do_login(session, options.username, options.password, target, preempt=True)
        response = sw.get_url(session, 'https://' + target + '/systemAdministrationView.html')
        csrf = re.findall(r'csrfToken.*"', response.text)[0].split('value=')[1].split('"')[1]
        postdata = {'csrfToken': csrf,
                    'cgiaction': "none",
                    'sonicOsApi_enable': "on",
                    'sonicOsApi_basicAuth': "on",
                    'cbox_sonicOsApi_enable': "",
                    'cbox_sonicOsApi_basicAuth': ""}
        url = 'https://' + target + '/main.cgi'
        api_result = send_sw_webcmd(session, url, postdata)
        sw.do_logout(session, target)

        ## Use API to send CLI command for groups
        session = requests.Session()
        session.mount('https://' + target, sw.DESAdapter())
        urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
        url = 'https://{}/api/sonicos/auth'.format(target)
        session.headers = OrderedDict(
            [('User-Agent', 'python-requests/2.18.4'), ('Accept', '*/*'), ('Accept-Encoding', 'gzip, deflate'),
             ('Connection', 'keep-alive')])
        post_data = None
        # auth = requests.auth.HTTPBasicAuth(options.username, options.password)
        response_code = None
        login_tries = 0
        while response_code != 200 and login_tries < 5:
            login_tries += 1
            response = session.post(url=url, headers={'authorization': "Basic " + base64.b64encode(
                '{}:{}'.format(options.username, options.password).encode()).decode()}, verify=False)
            response_code = response.status_code
            if response_code != 200:
                # session = requests.Session()
                # session.mount('https://' + target, sw.DESAdapter())
                # urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
                # url='https://{}/api/sonicos/auth'.format(target)
                debug('Login failed, retrying in 10 seconds')
                time.sleep(10)

        if response_code == 200:
            url = 'https://{}/api/sonicos/direct/cli'.format(target)
            session.headers.update({'content-type': 'text/plain'})

            ''' This section is to retrieve LDAP server config if the BindDN name needs to be changed
            post_data = 'show user ldap'
            result=session.post(url=url, data=post_data, verify=False)
            result=send_sw_webcmd(session, url, post_data)
            log(result.text)
            ldap_config=json.loads(result.text)
            print(json.dumps(ldap_config, sort_keys=True, indent=4))
            for server in ldap_config['user']['ldap']['server']:
                print(server['bind']['distinguished_name'])
            '''

            post_data = 'show user local groups\n'
            result = session.post(url=url, data=post_data, verify=False)
            groups = json.loads(result.text)
            print(groups)
            for group in groups['user']['local']['group']:
                if re.findall(r'^CS_FIREWALL', group['name'].upper()):
                    group_name = group['name']
                    print(group_name)
                    post_data = 'user local\ngroup "{}"\ndomain any\nno memberships-by-ldap-location\ncommit\n'.format(
                        group_name)
                    result = session.post(url=url, data=post_data, verify=False)
                    su_result = json.loads(result.text)['status']['success']

                    '''
                    post_data = 'user local\ngroup "CS_FIREWALL_RO"\ndomain any\nno memberships-by-ldap-location\ncommit\n'
                    result=session.post(url=url, data=post_data, verify=False)
                    ro_result=json.loads(result.text)['status']['success']
                    
                    
                    post_data = 'user local\ngroup "CS_FIREWALL_RW"\ndomain any\nno memberships-by-ldap-location\ncommit\n'
                    result=session.post(url=url, data=post_data, verify=False)
                    rw_result=json.loads(result.text)['status']['success']
                    '''

                    log('{},{},{},{},{},{}'.format(target, login_tries, ro_result, rw_result, su_result, ""))

        else:
            log('{},{},{},{},{},{}'.format(target, login_tries, 'Skipped', 'Skipped', 'Skipped', 'Login Failed'))

        ## Log out via DELETE method
        url = 'https://{}/api/sonicos/auth'.format(target)
        post_data = None
        session.delete(url=url, verify=False)


# if options.nexposesvc:

def bulk_create_services(target):
    import re
    import ipaddress
    import sonicwall as sw
    from netaddr import IPSet, IPRange, IPNetwork

    # log(config)
    try:
        target_context = None

        if target == None:
            if options.panoramaip:
                target = options.panoramaip
            elif options.sonicwallip:
                target = options.sonicwallip
            elif options.sonicwall_api_ip:
                target = options.sonicwall_api_ip
            elif options.checkpoint_api:
                target = options.checkpoint_api
            elif options.checkpoint:
                global config
                target = ''
            else:
                target = ''
        else:
            log(target)
            if options.fwtype in ['sw', 'sonicwall']:  ## not really supported as I need to read in routing table
                config = get_sonicwall_exp(target)

                '''
                exp_config=get_sw_config_https(target, None, options.username, options.password)
                tmpconfig=None
                if exp_config: 
                    memory_config=convert_exp_file('', None, exp_config.encode())
                    exp_config=None # free up memory 
                    if memory_config:
                        tmpconfig=load_sonicwall('', True, memory_config)
                        memory_config=None  # free up memory

                if tmpconfig:
                    if options.context !='':
                        tmpcontext=options.context[0]
                    else:
                        tmpcontext=tmpconfig['config']['name']
                    config={}
                    config[tmpcontext] = tmpconfig
                    if not options.context:
                        options.context = [tmpcontext]
                    for context in options.context:
                        contexts.append(context)
                    tmpconfig=None  # free up memory
                '''

            elif options.fwtype in ['sw65']:
                config = {}
                config['sonicwall'] = load_sonicwall_api(target, options.username, options.password)
                if not options.context:
                    options.context = ['sonicwall']
                for context in options.context:
                    contexts.append(context)
            elif options.fwtype in ['palo', 'panorama', 'pano']:
                palo_xml = get_palo_config_https(target, 'config.panorama.temp', options.username, options.password)
                if palo_xml:
                    config = load_xml('', palo_xml)
                    palo_xml = None
            elif options.fwtype in ['cp',
                                    'checkpoint']:  ## not much advantage for multiprocessing here, can just perform this by loading config files per cma and generating dbedit commands.
                pass

        comment = 'RITM5363965 - TASK5953822'
        comment = 'RITM5284122 - TASK5885697'

        nexpose_delay = 0

        # if options.context==['all']:
        #    contexts=[x for x in config]
        # else:
        #    contexts=options.context
        for context in options.context:
            log('context: ', context)
            group_length = len(options.groupservices)
            if context in config:  # and context!='shared':
                service_group_members = expand_service(config[context]['services'], options.nexposesvc,
                                                       config[context]['servicemappings'], inc_group=False)
                # service_group_members=config[context]['servicemappings'][options.nexposesvc]
                # expand_service(config[context]['services'], options.nexposesvc, config[context]['servicemappings'], inc_group=False)
                # if len(service_group_members) >= len(options.groupservices):
                #    log('Service Group already contains the correct number of members {}, no modifications needed (STEP1)'.format(len(service_group_members)))
                # else:
                # log('Service Group only contains {} members, running Service Creation (STEP1)'.format(len(service_group_members)))
                # log(service_group_members)
                if len(config[context]['services']) > 1:
                    sw_objects = {'address_objects': {'ipv4': [], 'ipv6': [], 'fqdn': []},
                                  'address_groups': {'ipv4': [], 'ipv6': [], 'fqdn': []}, 'service_objects': [],
                                  'service_groups': []}
                    fw_type = config[context]['config']['fw_type']
                    # if 'services' in config:
                    # log('context2: ', context)
                    # log('fw_type', fw_type)
                    if fw_type == 'panorama': fw_type = 'pano'
                    if fw_type == 'paloalto': fw_type = 'palo'
                    if fw_type in ["sw65", "palo", "pano", "R80", 'paloalto', 'panorama']:
                        api_type = 'api'
                    elif fw_type == "sonicwall":
                        api_type = 'webui'
                    elif fw_type == "checkpoint":
                        api_type = 'cli'
                    if fw_type in ['pano', 'panorama']:
                        # log(context)
                        target_context = 'shared'
                        if options.nexposesvc.lower() not in [x.lower() for x in config['shared'][
                            'services']]:  ## create address group if needed
                            if context == 'shared':
                                log('Creating Shared Service Group : {}'.format(options.nexposesvc))
                                if not options.readonly:
                                    result = exec_fw_command(target, fw_type, [('create_service',
                                                                                {'servicename': options.nexposesvc,
                                                                                 'servicetype': '2', 'zone': 'LAN',
                                                                                 'color': 'black', 'comment': comment,
                                                                                 'members': [],
                                                                                 'context': target_context})],
                                                             syntax=api_type, delay=nexpose_delay)
                        else:
                            if context == 'shared':
                                log('Using existing shared Service Group : {}'.format(options.nexposesvc))
                    elif fw_type not in ['pano', 'panorama']:
                        target_context = context
                        if fw_type in ['sonicwall', 'sw65']:
                            log('!-- Building lists for address and service objects')
                            orig_api = True
                            sw_objects = get_sw_objects(target, options.username, options.password, fw_type)
                        # if not options.readonly:
                        #    sw_enable_api(target, options.username, options.password)
                        '''
                        if options.nexposesvc.lower() not in [x.lower() for x in config[context]['services']]:
                            if fw_type in ['sw65', 'sonicwall']:
                                log('Creating Temp Service Object for Sonicwalls ')
                                if not options.readonly:
                                    result=exec_fw_command(target, fw_type, [('create_service', {'servicename': 'temp_service_object', 'protocol': 'tcp', 'port1' : '65535', 'servicetype': '1', 'color': 'black', 'comment': 'DELETE_ME', 'context': target_context})], syntax=api_type, delay=nexpose_delay)
                                log('Creating Service Group : {}'.format(options.nexposesvc))
                                if not options.readonly:
                                    result=exec_fw_command(target, fw_type, [('create_service', {'servicename': options.nexposesvc, 'servicetype': '2', 'color': 'black', 'comment': comment, 'members': ['temp_service_object'], 'context': target_context})], syntax=api_type, delay=nexpose_delay)
                            else:
                                log('Creating Service Group : {}'.format(options.nexposesvc))
                                if not options.readonly:
                                    result=exec_fw_command(target, fw_type, [('create_service', {'servicename': options.nexposesvc, 'servicetype': '2', 'color': 'black', 'comment': comment, 'members': [], 'context': target_context})], syntax=api_type, delay=nexpose_delay)
                        '''
                        if options.nexposesvc.lower() in [x.lower() for x in config[context]['services']]:
                            for service in config[context]['services']:
                                if service.lower() == options.nexposesvc.lower():
                                    options.nexposesvc = service
                                    break
                            log('Using existing Service Group : {}'.format(options.nexposesvc))

        new_services, existing_services, members_added, members_existed = ([], [], [], [])

        if target_context:
            if len(config[target_context]['services']) > 1:
                services_to_add = []  # list of sets containing (protocol, port1, port2, service_name)

                for service_to_add in options.groupservices:  ## build services_to_add
                    if len(service_to_add.split(',')) == 2:
                        service_prot, service_ports = service_to_add.split(',')[0].split('/')
                        service_name = service_to_add.split(',')[1]
                        if len(service_ports.split('-')) == 2:
                            service_port1, service_port2 = service_ports.split('-')
                        else:
                            service_port1, service_port2 = (service_ports, '')

                        try:
                            if service_prot.lower() in ['tcp', 'udp']:
                                if service_prot.lower() == 'tcp':
                                    service_prot_num = '6'
                                elif service_prot.lower() == 'udp':
                                    service_prot_num = '17'
                                services_to_add.append((service_prot.lower(), service_prot_num, service_port1,
                                                        service_port2, service_name))
                            else:
                                log('Skipping entry {} - Protocol must be tcp or udp'.format(service_to_add))
                        except Exception as e:
                            log(e)
                            log('Skipping entry {} - Invalid format'.format(service_to_add))
                    else:
                        log('Skipping entry {} - Invalid format - Expected protocol/ports,service_object_name'.format(
                            service_to_add))

                matches = {}
                service_cmds = []
                group_members = []

                for service_prot, service_prot_num, service_port1, service_port2, service_name in services_to_add:  ## build a list of existing address objects that match each object that needs to be created
                    if service_port2 != '':
                        service_def = '{}/{}-{}'.format(service_prot, service_port1, service_port2)
                    else:
                        service_def = '{}/{}'.format(service_prot, service_port1)

                    matches[service_def] = {'exact': None, 'underscore': None, 'dash': None, 'other': None}
                    # log('new address : ', address_name)
                    for config_service in config[target_context][
                        'services']:  ## build a list of existing address objects that match the object we want to add
                        if 'svcObjIpType' in config[target_context]['services'][config_service]:
                            if config[target_context]['services'][config_service]['svcObjIpType'].lower() in [
                                service_prot, service_prot_num]:
                                if service_port1 == config[target_context]['services'][config_service][
                                    'svcObjPort1'] and (
                                        service_port2 == config[target_context]['services'][config_service][
                                    'svcObjPort2'] or (
                                                config[target_context]['services'][config_service]['svcObjPort2'] ==
                                                config[target_context]['services'][config_service][
                                                    'svcObjPort1'] and service_port2) == ''):
                                    if config_service not in matches[service_def]:
                                        if re.findall(r'^{}$'.format(service_name), config_service.lower(),
                                                      flags=re.IGNORECASE) or re.findall(
                                            r'{}_{}-{}$'.format(service_prot, service_port1, service_port2),
                                            config_service.lower(), flags=re.IGNORECASE):
                                            matches[service_def]['exact'] = config_service
                                        if re.findall(r'{}_{}$'.format(service_prot, service_port1),
                                                      config_service.lower(), flags=re.IGNORECASE) or re.findall(
                                                r'{}_{}-{}$'.format(service_prot, service_port1, service_port2),
                                            config_service.lower(), flags=re.IGNORECASE):
                                            matches[service_def]['underscore'] = config_service
                                        elif re.findall(r'{}-{}$'.format(service_prot, service_port1),
                                                        config_service.lower(), flags=re.IGNORECASE) or re.findall(
                                                r'{}-{}-{}$'.format(service_prot, service_port1, service_port2),
                                                config_service.lower(), flags=re.IGNORECASE):
                                            matches[service_def]['dash'] = config_service
                                        else:
                                            if not matches[service_def]['other']:
                                                matches[service_def]['other'] = config_service

                    new_service_name = service_name
                    index = 0
                    while new_service_name.lower() in [x.lower() for x in config[target_context]['services']]:
                        # log(config[target_context]['services'])
                        new_service_name = '{}_{}'.format(service_name, index)
                        index += 1
                    if matches[service_def]['exact']:
                        log('Using existing object name with exact name match {}'.format(matches[service_def]['exact']))
                        existing_services.append(matches[service_def]['exact'])
                        # if not options.readonly:
                        group_members.append(matches[service_def]['exact'])
                    elif matches[service_def]['other']:
                        log('Using existing object name with other match {} instead of requested name {}'.format(
                            matches[service_def]['other'], service_name))
                        existing_services.append(matches[service_def]['other'])
                        # if not options.readonly:
                        group_members.append(matches[service_def]['other'])
                    elif matches[service_def]['underscore']:
                        log('Using existing object name with underscore match {} instead of requested name {}'.format(
                            matches[service_def]['underscore'], service_name))
                        existing_services.append(matches[service_def]['underscore'])
                        # if not options.readonly:
                        group_members.append(matches[service_def]['underscore'])
                    elif matches[service_def]['dash']:
                        log('Using existing object name with dash match {} instead of requested name {}'.format(
                            matches[service_def]['dash'], service_name))
                        existing_services.append(matches[service_def]['dash'])
                        # if not options.readonly:
                        group_members.append(matches[service_def]['dash'])
                    else:  ## no matches found
                        log('Creating new service object {} defined as {}'.format(new_service_name, service_def))
                        group_members.append(new_service_name)
                        new_services.append(new_service_name)
                        # if not options.readonly:
                        if service_port2 == '':
                            service_port2 = service_port1
                        service_cmds.append(('create_service',
                                             {'servicename': new_service_name, 'protocol': service_prot,
                                              'port1': service_port1, 'port2': service_port2, 'servicetype': '1',
                                              'color': 'black', 'comment': comment, 'context': target_context}))

                ###############################################

                if not options.readonly:
                    if service_cmds != []:
                        # log(target, fw_type)
                        result = exec_fw_command(target, fw_type, service_cmds, syntax=api_type, delay=nexpose_delay,
                                                 sw_objects=sw_objects)
                        log('Creating Service objects', result)
                    else:
                        log('No new services need to be created')
                    members_added = []
                    group_created = False
                    for sublist in [group_members[i:i + 50] for i in range(0, len(group_members),
                                                                           50)]:  ## only add a max of 50 group members at a time (limit is 100) -- should likely move this to the create/modify address group routines instead
                        result = False
                        if fw_type in ['sonicwall', 'sw65']:
                            sw_objects = get_sw_objects(target, options.username, options.password, fw_type)
                        for member in [x for x in sublist]:  # cant use sublist and then change it in the loop.
                            if options.nexposesvc in config[target_context]['servicemappings']:
                                if member in config[target_context]['servicemappings'][options.nexposesvc]:
                                    sublist.remove(member)
                                    members_existed.append(member)
                                    log('Removing {} from sublist'.format(member))
                        if options.nexposesvc.lower() != 'none':
                            while sublist != [] and result != True:
                                # log('-----------------JEFF------------------------------')
                                # if sublist != []:
                                log('subgroup members : ', sublist)
                                if options.nexposesvc.lower() in [x.lower() for x in
                                                                  config[target_context]['services']] or group_created:
                                    log('Adding members to existing group')
                                    result = exec_fw_command(target, fw_type, [('modify_service',
                                                                                {'action': 'addmembers',
                                                                                 'servicename': options.nexposesvc,
                                                                                 'servicetype': '2', 'color': 'black',
                                                                                 'comment': comment, 'members': sublist,
                                                                                 'context': target_context})],
                                                             syntax=api_type, delay=nexpose_delay,
                                                             sw_objects=sw_objects)
                                else:
                                    log('Creating group and adding members')
                                    result = exec_fw_command(target, fw_type, [('create_service',
                                                                                {'servicename': options.nexposesvc,
                                                                                 'servicetype': '2', 'color': 'black',
                                                                                 'comment': comment, 'members': sublist,
                                                                                 'context': target_context})],
                                                             syntax=api_type, delay=nexpose_delay,
                                                             sw_objects=sw_objects)
                                    log(result)
                                    if result == True:
                                        group_created = True

                                # result=exec_fw_command(target, fw_type, [('modify_address', {'action': 'addmembers', 'addressname': options.nexposesvc, 'members': [sublist], 'addresstype': '8', 'zone': target_zone, 'color': 'black', 'context': target_context})], syntax=api_type, delay=nexpose_delay, sw_objects=sw_objects)
                                ## maximum of 100 objects at a time

                                log('Adding Members to group', result)
                                if result != True:
                                    if fw_type == 'sw65':
                                        bad_object = ''
                                        try:
                                            bad_object = result[1].split(' ')[5]
                                            sublist.remove(bad_object)
                                            log('Removing {} from group members'.format(bad_object))
                                            log('Group members {}'.format(sublist))
                                        except:
                                            log('Removing {} from group failed'.format(bad_object))
                                    else:
                                        # log(result)
                                        result = True
                                else:
                                    for x in sublist:
                                        members_added.append(x)
                    if members_added != []:
                        log('The following group members were successfully added : ', members_added)

                # if  fw_type != 'pano' and not options.readonly:
                # result=exec_fw_command(target, fw_type, [('modify_service', {'action': 'delete', 'servicename': 'temp_service_object', 'servicetype': '1', 'context': target_context})], syntax=api_type, delay=nexpose_delay)

                # if not orig_api:
                #    sw_disable_api(target, options.username, options.password)
        return (target, new_services, existing_services, members_added, members_existed)

    except Exception as e:
        log(e)
        return (target, 'Exception', e, '', '')


if options.nexposesvc:

    # for c in config: log(c)

    def run_parallel(targets, max_proc=48):

        from multiprocessing import Pool

        pool = Pool(processes=max_proc)
        results = pool.map(bulk_create_services, targets)
        pool.close()
        return results


    if options.grouptargets:
        results = run_parallel(options.grouptargets)
        for target, new_services, existing_services, members_added, members_existed in results:
            if new_services != 'Exception':
                log('{},{},{},{}'.format(target, 'New Services', len(new_services), new_services))
                log('{},{},{},{}'.format(target, 'Existing Services', len(existing_services), existing_services))
                log('{},{},{},{}'.format(target, 'New Group Members', len(members_added), members_added))
                log('{},{},{},{}'.format(target, 'Existing Group Members', len(members_existed), members_existed))
            else:
                log('{},{},{}'.format(target, 'Exception', new_services))
    else:
        results = bulk_create_services(None)


def bulk_get_sw_config(params, method='webui'):
    import pickle

    try:
        target, nodename = params.split(',')
        original_logging = options.logging
        if method.lower() == 'api':
            log('Retrieving configuration via API for Node {} IP {}'.format(nodename, target))
            # options.logging=logging.NONE
            config['sonicwall'] = load_sonicwall_api(target, options.username, options.password)
        else:
            log('Retrieving configuration via WebUI for Node {} IP {}'.format(nodename, target))
            config = get_sonicwall_exp(target)  # load_sonicwall(target, options.skip_disabled)

        config['shared'] = {}
        config['shared']['config'] = {}
        config['shared']['config']['name'] = ''
        config['shared']['config']['fw_type'] = ''
        config['shared']['config']['version'] = ''
        config['shared']['config']['mgmtip'] = ''
        config['shared']['addresses'] = {}
        config['shared']['services'] = {}
        config['shared']['policies'] = {}  # return_policy
        config['shared']['nat'] = {}
        config['shared']['apps'] = {}
        config['shared']['addressmappings'] = {}
        config['shared']['servicemappings'] = {}
        config['shared']['logprofiles'] = {}
        # log("!-- Saving config")

        outfile = open('{}.config'.format(nodename), 'wb')
        tmp = OrderedDict()
        tmp['config'] = config
        tmp['custom'] = customops
        result = pickle.dump(tmp, outfile)
        outfile.close()
    except Exception as e:
        options.logging = original_logging
        return target, False, (e, e.__traceback__.tb_lineno)
    options.logging = original_logging
    return target, True, 'Config saved'


if options.getconfigs:

    def run_parallel(params, max_proc=48):

        from multiprocessing import Pool

        pool = Pool(processes=max_proc)
        results = pool.map(bulk_get_sw_config, params)
        pool.close()

        return results


    if options.getconfigs:
        # original_logging=options.logging
        results = run_parallel(options.getconfigs)
        # options.logging=original_logging
        for result in results:
            log(result)


def bulk_create_addresses(target, config=None):
    import re
    import ipaddress
    import sonicwall as sw
    from netaddr import IPSet, IPRange, IPNetwork

    try:
        members_added = []
        members_existed = []
        new_addresses = []
        existing_addresses = []

        if target == None:
            if options.panoramaip:
                target = options.panoramaip
            elif options.sonicwallip:
                target = options.sonicwallip
            elif options.sonicwall_api_ip:
                target = options.sonicwall_api_ip
            elif options.checkpoint_api:
                target = options.checkpoint_api
            elif options.checkpoint:
                target = ''
            else:
                target = ''
        else:
            log(target)
            if options.fwtype in ['sw', 'sonicwall']:  ## not really supported as I need to read in routing table
                config = get_sonicwall_exp(target)

                '''
                exp_config=get_sw_config_https(target, None, options.username, options.password)
                tmpconfig=None
                if exp_config: 
                    memory_config=convert_exp_file('', None, exp_config.encode())
                    exp_config=None # free up memory 
                    if memory_config:
                        tmpconfig=load_sonicwall('', True, memory_config)
                        memory_config=None  # free up memory

                if tmpconfig:
                    if options.context !='':
                        tmpcontext=options.context[0]
                    else:
                        tmpcontext=tmpconfig['config']['name']
                    config={}
                    config[tmpcontext] = tmpconfig
                    if not options.context:
                        options.context = [tmpcontext]
                    for context in options.context:
                        contexts.append(context)
                    tmpconfig=None  # free up memory
                '''

            elif options.fwtype in ['sw65']:
                config = {}
                config['sonicwall'] = load_sonicwall_api(target, options.username, options.password)
                if not options.context:
                    options.context = ['sonicwall']
                for context in options.context:
                    contexts.append(context)
            elif options.fwtype in ['palo', 'panorama', 'pano']:
                palo_xml = get_palo_config_https(target, 'config.panorama.temp', options.username, options.password)
                if palo_xml:
                    config = load_xml('', palo_xml)
                    palo_xml = None
            elif options.fwtype in ['cp',
                                    'checkpoint']:  ## not much advantage for multiprocessing here, can just perform this by loading config files per cma and generating dbedit commands.
                pass
        ## should probably allow the use of options.grouptargets

        # log(config['sonicwall']['addressmappings'])

        comment = options.comment

        nexpose_delay = 0
        ## Create Nexpose group

        # if options.nexpose.lower() not in [x.lower() for x in config['shared']['addresses']]:  ## create address group if needed
        #    if not options.readonly:
        #        log('Creating Address Group : {}'.format(options.nexpose))
        #        result=exec_fw_command(target, 'pano', [('create_address', {'addressname': options.nexpose, 'addresstype': '8', 'zone': 'LAN', 'color': 'black', 'comment': comment, 'members': [], 'context': 'shared'})], syntax='api', delay=10)
        # else:
        #    log('Using existing Address Group : {}'.format(options.nexpose))

        ## Create rules with group - this was removed as it is now added as a shared policy
        # if options.context != ['all']:
        target_context = None
        for context in options.context:
            target_zone = None
            group_length = len(options.groupaddresses)
            # log(context)
            address_group_members = expand_address(config[context]['addresses'], options.nexpose,
                                                   config[context]['addressmappings'])
            # if len(address_group_members) >= group_length:
            #    log('{} contains {} members, no action needed (STEP1)'.format(options.nexpose, len(address_group_members)))
            # else:
            # log('{} only contains {} members, creating address objects (STEP1)'.format(options.nexpose, len(address_group_members)))
            if len(config[context][
                       'addresses']) > 1:  # at least one address must exist to continue, otherwise loading config likely failed.
                sw_objects = {'address_objects': {'ipv4': [], 'ipv6': [], 'fqdn': []},
                              'address_groups': {'ipv4': [], 'ipv6': [], 'fqdn': []}, 'service_objects': [],
                              'service_groups': []}
                if context in config:
                    fw_type = config[context]['config']['fw_type']
                    if fw_type in ["sw65", "palo", "pano", "R80", 'paloalto', 'panorama']:
                        api_type = 'api'
                    elif fw_type == "sonicwall":
                        api_type = 'webui'
                    elif fw_type == "checkpoint":
                        api_type = 'cli'
                    if fw_type in ['pano', 'panorama']:
                        fw_type = 'pano'
                        target_zone = True
                        target_context = 'shared'
                        if options.nexpose.lower() not in [x.lower() for x in config['shared'][
                            'addresses']] and not options.readonly:  ## create address group if needed
                            log('Creating Shared Address Group : {}'.format(options.nexpose))
                            result = exec_fw_command(target, fw_type, [('create_address',
                                                                        {'addressname': options.nexpose,
                                                                         'addresstype': '8', 'zone': 'LAN',
                                                                         'color': 'black', 'comment': comment,
                                                                         'members': [], 'context': target_context})],
                                                     syntax=api_type, delay=nexpose_delay)
                        elif options.nexpose.lower() in [x.lower() for x in config['shared']['addresses']]:
                            for address in config[context]['addresses']:
                                if address.lower() == options.nexpose.lower():
                                    options.nexpose = address
                                    break
                            log('!-- Using existing Address Group : {}'.format(options.nexpose))
                    elif fw_type not in ['pano', 'panorama']:
                        target_context = context
                        if fw_type in ['sonicwall', 'sw65']:
                            # log(options.groupaddresses[0].split(',')[0])
                            if not options.skipzone:
                                for address in options.groupaddresses:
                                    if len(address.split('%')) == 2:
                                        target_zone = get_zone(target_context, address.split(',')[0].split('%')[1],
                                                               config)
                                    else:
                                        target_zone = get_zone(target_context, address.split(',')[0], config)
                                    if target_zone != None:
                                        # log('target_zone', target_zone, address)
                                        break
                                if target_zone == None:
                                    try:
                                        log('Trying to determine zone for {}'.format(
                                            options.groupaddresses[0].split(',')[0]))
                                        target_zone = \
                                        get_zones2(target_context, options.groupaddresses[0].split(',')[0], config)[0]
                                    except:
                                        target_zone = None

                                log('!-- Zone for newly created objects : {}'.format(target_zone))
                            else:
                                log('!-- Skipping zone detection for adding address objects to group')
                                target_zone = True
                            log('!-- Building lists for address and service objects')
                            orig_api = True
                            # orig_api=sw_get_api_status(target, options.username, options.password)
                            # sw_enable_api(target, options.username, options.password)
                            sw_objects = get_sw_objects(target, options.username, options.password, fw_type)
                        else:
                            # log('Zone for newly created objects : {}'.format(target_zone))
                            target_zone = 'LAN'
                            orig_api = None

                        # if options.nexpose.lower() not in [x.lower() for x in config[context]['addresses']] and not options.readonly:
                        # log('!-- Original API status {}'.format(orig_api))
                        # if api_type=='api' and orig_api==False:  ## only enable if needed -- enabling API will log you out of box
                        #    sw_enable_api(target, options.username, options.password)
                        # log('!-- Creating Temp Address Object for Sonicwalls ')
                        # result=exec_fw_command(target, fw_type, [('create_address', {'addressname': 'temp_address_object', 'ip1': '1.1.1.1', 'ip2' : '255.255.255.255', 'addresstype': '1', 'zone': target_zone, 'color': 'black', 'comment': 'DELETE_ME', 'context': target_context})], syntax=api_type, delay=nexpose_delay)
                        # log('!-- Creating Address Group : {}'.format(options.nexpose))
                        # result=exec_fw_command(target, fw_type, [('create_address', {'addressname': options.nexpose, 'addresstype': '8', 'zone': target_zone, 'color': 'black', 'comment': comment, 'members': ['temp_address_object'], 'context': target_context})], syntax=api_type, delay=nexpose_delay)
                        # log(result)
                        # elif options.nexpose.lower() in [x.lower() for x in config[context]['addresses']]:
                        if options.nexpose.lower() in [x.lower() for x in config[context]['addressmappings']]:
                            for address in config[context]['addresses']:
                                if address.lower() == options.nexpose.lower():
                                    options.nexpose = address
                                    break
                            log('!-- Using existing Address Group : {}'.format(options.nexpose))

                            # result=exec_fw_command(target, fw_type, [('create_rule', {'rulename': 'test_rule', 'policyname': context, 'policynum': '1', 'polaction': '1', 'srczones': [target_zone], 'dstzones': ['WAN'], 'sources': ['test_host'], 'dests': ['test_group'], 'services': ['any'], 'comment': 'testing', 'context': context})], syntax='api')
                        # result=exec_fw_command(target, fw_type, [('create_rule', {'rulename': 'NEXPOSE', 'policyname': context, 'policynum': '1', 'polaction': '2', 'srczones': [target_zone], 'dstzones': ['any'], 'sources': [options.nexpose], 'dests': ['any'], 'services': ['any'], 'applications': ['any'], 'comment': comment, 'disabled': 'True', 'context': context})], syntax='api', delay=10)
                        # result=exec_fw_command(target, 'pano', [('modify_rule', {'action': 'disable', 'comment': 'Modified Comment', 'rulename': 'NEXPOSE', 'policyname': context, 'policynum': '1', 'polaction': '1', 'srczones': ['LAN'], 'dstzones': ['WAN'], 'sources': ['test_host'], 'dests': ['test_group'], 'services': ['any'], 'context': context})], syntax='api')
        # if len(address_group_members) >= group_length:
        #    log('{} contains {} members, no action needed (STEP2)'.format(options.nexpose, len(address_group_members)))
        # else:
        # target_zone='WAN'
        # log(target_zone, target_context)

        members_added = []
        members_existed = []
        new_addresses = []
        existing_addresses = []

        if target_context:
            if target_zone and len(config[target_context]['addresses']) > 1:

                addresses_to_add = []  # list of sets containing (network, mask, address_name)
                address_cmds = []
                group_members = []

                for address_to_add in options.groupaddresses:  ## build addresses_to_add
                    fqdn = None
                    if address_to_add in config[target_context]['addresses']:
                        group_members.append(address_to_add)
                        log('Using existing object name with exact name match {}'.format(address_to_add))
                        existing_addresses.append(address_to_add)
                    elif len(address_to_add.split(',')) == 2:

                        address_obj, address_name = address_to_add.split(',')
                        if len(address_obj.split('/')) == 2:
                            network, mask = address_obj.split('/')
                        elif len(address_obj.split('%')) == 2:
                            fqdn, fqdn_ip = address_obj.split('%')
                        elif len(address_obj.split('-')) == 2:
                            range_start, range_end = address_obj.split('-')
                            network, mask = (None, None)
                        else:
                            network, mask = (address_obj, '32')
                        if fqdn != None:
                            addresses_to_add.append((fqdn, fqdn_ip, address_name, 'fqdn'))
                            # target_zone=get_zone(target_context, fqdn_ip, config)
                        else:
                            try:
                                tmpaddr = IPNetwork(network + '/' + str(mask))
                                addresses_to_add.append((network, mask, address_name, 'network'))
                            except:
                                try:
                                    tmpaddr = IPRange(range_start, range_end)
                                    addresses_to_add.append((range_start, range_end, address_name, 'range'))
                                except:
                                    # pass
                                    log('!-- Skipping entry {} - Invalid format'.format(address_to_add))

                    else:
                        log('!-- Skipping entry {} - Invalid format - Expected network/mask,address_name'.format(
                            address_to_add))

                ## for sonicwalls, if we are adding objects to a group, I need to add routines to ensure addresses being added do not overlap!

                # for address_to_add in addresses_to_add: ## now perform action on each address object to add
                matches = {}

                # for addr in addresslist: log(addr)
                # log ('-'*100)
                # for first, address_name in groupaddresses: log(address_name)

                ###result=exec_fw_command(fwip, fw, [('create_address', {'addressname': 'test_fqdn', 'domain': 'www.deleteme.com', 'ttl': '120', 'addresstype': 'fqdn', 'zone': 'LAN', 'color': 'black' })], syntax=syntax)

                for network, mask, address_name, address_type in addresses_to_add:  ## build a list of existing address objects that match each object that needs to be created
                    if address_type == 'network':
                        network_mask = '{}/{}'.format(network, mask)
                        fqdn_name = address_name
                        try:
                            host_name = address_name.split('.')[0]
                        except:
                            host_name = address_name
                        matches[network_mask] = {'address_ip': None, 'fqdn': None, 'hostname': None, 'other': None}
                        # log('new address : ', address_name)
                        for config_address in config[target_context][
                            'addresses']:  ## build a list of existing address objects that match the object we want to add
                            if config[target_context]['addresses'][config_address]['IPv4Networks'] == [
                                ipaddress.IPv4Network(
                                    network_mask)]:  # or ( config[target_context]['addresses'][config_address]['addrObjIp1'] == network and config[target_context]['addresses'][config_address]['addrObjIp2']==cidr_to_netmask(mask)):
                                # log(config[target_context]['addresses'][address])
                                if config_address not in matches[network_mask]:
                                    if re.findall(r'{}.*{}'.format(host_name, network), config_address.lower(),
                                                  flags=re.IGNORECASE):
                                        matches[network_mask]['address_ip'] = config_address
                                        existing_addresses.append(config_address)
                                    elif config_address.lower() == fqdn_name.lower():
                                        matches[network_mask]['fqdn'] = config_address
                                        existing_addresses.append(config_address)
                                    elif config_address.lower() == host_name.lower():
                                        if not matches[network_mask]['hostname']:
                                            matches[network_mask]['hostname'] = config_address
                                            existing_addresses.append(config_address)
                                    else:
                                        if not matches[network_mask]['other']:
                                            matches[network_mask]['other'] = config_address
                                            existing_addresses.append(config_address)

                        # if len(matches[network_mask]) == 0: ## no address object exists with same definition - create new address object and add it to group
                        # result=exec_fw_command(target, fw_type, [('create_address', {'addressname': new_address_name, 'ip1': network, 'ip2' : cidr_to_netmask(mask), 'addresstype': '1', 'zone': target_zone, 'color': 'black', 'comment': 'NEXPOSE_SCANNERS', 'context': target_context})], syntax='cli')
                        # result=exec_fw_command(target, fw_type, [('modify_address', {'action': 'addmembers', 'addressname': options.nexpose, 'members': [new_address_name], 'comment': 'NEXPOSE_GROUP', 'addresstype': '8', 'zone': target_zone, 'color': 'black', 'context': target_context})], syntax='cli')
                        # else: # figure out what address object to use and add it to group
                        # address_name
                        new_address_name = address_name
                        if len(address_name.split('.')) > 0:
                            new_address_name = address_name.split('.')[0]
                        new_address_name = '{}-{}'.format(new_address_name, network)

                        if matches[network_mask]['address_ip']:
                            log('Using existing object name with address_ip match {} instead of requested name {}'.format(
                                matches[network_mask]['address_ip'], address_name))
                            group_members.append(matches[network_mask]['address_ip'])
                        elif matches[network_mask]['fqdn']:
                            log('Using existing object name with fqdn match {} instead of requested name {}'.format(
                                matches[network_mask]['fqdn'], address_name))
                            group_members.append(matches[network_mask]['fqdn'])
                        elif matches[network_mask]['hostname']:
                            log('Using existing object name with hostname match {} instead of requested name {}'.format(
                                matches[network_mask]['hostname'], address_name))
                            group_members.append(matches[network_mask]['hostname'])
                        elif matches[network_mask]['other']:
                            log('Using existing object name with first match {} instead of requested name {}'.format(
                                matches[network_mask]['other'], address_name))
                            group_members.append(matches[network_mask]['other'])
                        else:  ## no matches found
                            log('Creating new address object {} defined as {}'.format(new_address_name, network_mask))
                            new_addresses.append(new_address_name)
                            group_members.append(new_address_name)
                            if mask == '32':
                                address_cmds.append(('create_address', {'addressname': new_address_name, 'ip1': network,
                                                                        'ip2': cidr_to_netmask(mask),
                                                                        'addresstype': '1', 'zone': target_zone,
                                                                        'color': 'black', 'comment': comment,
                                                                        'context': target_context}))
                            else:
                                address_cmds.append(('create_address', {'addressname': new_address_name, 'ip1': network,
                                                                        'ip2': cidr_to_netmask(mask),
                                                                        'addresstype': '4', 'zone': target_zone,
                                                                        'color': 'black', 'comment': comment,
                                                                        'context': target_context}))
                    elif address_type == 'range':
                        new_address_name = address_name
                        # for range_start, range_end, address_name, address_type in addresses_to_add: ## build a list of existing address objects that match each object that needs to be created
                        address_cmds.append(('create_address',
                                             {'addressname': new_address_name, 'ip1': network, 'ip2': mask,
                                              'addresstype': '2', 'zone': target_zone, 'color': 'black',
                                              'comment': comment, 'context': target_context}))
                        group_members.append(new_address_name)
                    elif address_type == 'fqdn':  # [('create_address', {'addressname': 'test_fqdn', 'domain': 'www.deleteme.com', 'ttl': '120', 'addresstype': 'fqdn', 'zone': 'LAN', 'color': 'black' })]
                        # log('Creating fqdn object {}'.format(address_name))
                        # log(config[target_context]['addressesfqdn'])
                        # for x in config[target_context]['addressesfqdn']:
                        #    log(x)
                        #    pass
                        #    log(config[target_context]['addressesfqdn'][x])
                        # if address_name in config[target_context]['addresses'] or address_name in config[target_context]['addressesV6']:# or address_name in config[target_context]['addressesfqdn']:
                        #    existing_addresses.append(address_name)
                        #    log('Using existing fqdn object with name {}'.format(address_name))

                        ## Sonicwall 6.5.4.8 has a problem where sometimes the JSON returned for FQDN objects is mixed-up.  an FQDN match will only happen if both the Name of the object and the
                        ## FQDN definition of the object are the same.  This is not ideal, as it should only match on FQDN definition.  Our use of FQDNs is limited, so no major concerns here.

                        if network in [config[target_context]['addressesfqdn'][x]['addrObjFqdn'] for x in
                                       config[target_context]['addressesfqdn']] and address_name in [
                            config[target_context]['addressesfqdn'][y]['addrObjFqdnId'] for y in
                            config[target_context]['addressesfqdn']]:
                            for y in config[target_context]['addressesfqdn']:
                                log('{} -- {} -- {} -- {}'.format(network, config[target_context]['addressesfqdn'][y][
                                    'addrObjFqdn'], address_name, config[target_context]['addressesfqdn'][y][
                                                                      'addrObjFqdnId']))
                                if network in config[target_context]['addressesfqdn'][y][
                                    'addrObjFqdn'] and address_name == config[target_context]['addressesfqdn'][y][
                                    'addrObjFqdnId']:
                                    group_members.append(config[target_context]['addressesfqdn'][y]['addrObjFqdnId'])
                                    existing_addresses.append(
                                        config[target_context]['addressesfqdn'][y]['addrObjFqdnId'])
                                    log('Using existing fqdn object {} with name {}'.format(y, config[target_context][
                                        'addressesfqdn'][y]['addrObjFqdnId']))
                                    break
                            # existing_addresses.append(address_name)
                            # group_members.append(new_address_name)

                        else:
                            log('Creating new fqdn object {}'.format(address_name))
                            new_address_name = address_name
                            address_cmds.append(('create_address', {'addressname': new_address_name, 'domain': network,
                                                                    'addresstype': 'fqdn', 'zone': target_zone,
                                                                    'color': 'black', 'comment': comment,
                                                                    'context': target_context}))
                            group_members.append(new_address_name)
                if not options.readonly:
                    if address_cmds != []:
                        # log(target, fw_type)
                        result = exec_fw_command(target, fw_type, address_cmds, syntax=api_type, delay=nexpose_delay,
                                                 sw_objects=sw_objects)
                        log('Creating Address objects', result)

                    else:
                        log('No new addresses need to be created')
                    members_added = []
                    members_existed = []
                    group_created = False
                    for sublist in [group_members[i:i + 50] for i in range(0, len(group_members),
                                                                           50)]:  ## only add a max of 50 group members at a time (limit is 100) -- should likely move this to the create/modify address group routines instead
                        result = False
                        if fw_type in ['sonicwall', 'sw65']:
                            sw_objects = get_sw_objects(target, options.username, options.password, fw_type)
                        for member in [x for x in sublist]:  # cant use sublist and then change it in the loop.
                            if options.nexpose in config[target_context]['addressmappings']:
                                if member in config[target_context]['addressmappings'][options.nexpose]:
                                    sublist.remove(member)

      members_existed.append(member)
                                    log('Removing {} from sublist'.format(member))

                        if options.nexpose.lower() != 'none':
                            # log('sublist', sublist)
                            tries = 0
                            while sublist != [] and result != True and tries < len(sublist):
                                tries += 1
                                log('subgroup members : ', sublist)
                                if options.nexpose.lower() in [x.lower() for x in config[target_context][
                                    'addresses']] or options.nexpose.lower() in [x.lower() for x in
                                                                                 config[target_context][
                                                                                     'addressesV6']] or group_created:
                                    result = exec_fw_command(target, fw_type, [('modify_address',
                                                                                {'action': 'addmembers',
                                                                                 'addressname': options.nexpose,
                                                                                 'addresstype': '8',
                                                                                 'zone': target_zone, 'color': 'black',
                                                                                 'comment': comment, 'members': sublist,
                                                                                 'context': target_context})],
                                                             syntax=api_type, delay=nexpose_delay,
                                                             sw_objects=sw_objects)
                                    log('Adding members to existing group :', result)
                                else:
                                    result = exec_fw_command(target, fw_type, [('create_address',
                                                                                {'addressname': options.nexpose,
                                                                                 'addresstype': '8',
                                                                                 'zone': target_zone, 'color': 'black',
                                                                                 'comment': comment, 'members': sublist,
                                                                                 'context': target_context})],
                                                             syntax=api_type, delay=nexpose_delay,
                                                             sw_objects=sw_objects)
                                    log('Creating group and adding members :', result)
                                    if result == True:
                                        group_created = True

                                if result != True:
                                    bad_object = ''
                                    if fw_type == 'sw65':
                                        try:
                                            bad_object = result[1].split(' ')[5]
                                            sublist.remove(bad_object)
                                            log('Removing {} from group members'.format(bad_object))
                                            log('Group members {}'.format(sublist))
                                        except:
                                            log('Removing {} from group failed'.format(bad_object))
                                    else:
                                        # log(result)
                                        result = True
                                else:
                                    for x in sublist:
                                        members_added.append(x)

                    if members_added != []:
                        log('The following group members were successfully added : ', members_added)
                #    if not orig_api:
                #        sw_disable_api(target, options.username, options.password)
            else:
                log('!-- Unable to determine Address object zone - skipping')
        return (target, new_addresses, existing_addresses, members_added, members_existed)
    except Exception as e:
        # log(e)
        return (target, 'Exception', e, '', '')


if options.nexpose:  ## create address objects

    def run_parallel(targets, max_proc=48):

        from multiprocessing import Pool

        pool = Pool(processes=max_proc)
        results = pool.map(bulk_create_addresses, targets)

        return results


    if options.grouptargets:
        results = run_parallel(options.grouptargets)
        for target, new_addresses, existing_addresses, members_added, members_existed in results:
            if new_addresses != 'Exception':
                log('{},{},{},{}'.format(target, 'New Addresses', len(new_addresses), new_addresses))
                log('{},{},{},{}'.format(target, 'Existing Addresses', len(existing_addresses), existing_addresses))
                log('{},{},{},{}'.format(target, 'New Group Members', len(members_added), members_added))
                log('{},{},{},{}'.format(target, 'Existing Group Members', len(members_existed), members_existed))
            else:
                log('{},{},{}'.format(target, 'Exception', new_addresses))

    else:
        log('Creating bulk objects without target group targets specified')
        bulk_create_addresses(None, config)

if not True:  # options.nexpose:  ## create address objects
    import re
    import ipaddress
    import sonicwall as sw
    from netaddr import IPSet, IPRange, IPNetwork

    # input - group name to create
    # input - address object to create with hostname
    # input - validate that each address is valid and does not overlap with any other address (required for sonicwall)
    # load panorama config
    # check for existence of each ip in shared objects - use object that matches FQDN, hostname or first match in that order
    # make sure given address object name doesnt already exist, otherwise keep appending a number
    # groups should be specified as group/group_name rather than group_name/group

    # options.groupaddresses =['192.168.1.0/24,network1', '192.168.2.0/24,network2', '192.168.3.1,host1', '192.168.3.128,host2', '192.168.3.45,host3', '192.168.3.99/32,host4', '65.115.19.0/24,host5', 'OEM-Agent-access/group']
    groupaddresses = []
    for group_address in options.groupaddresses:
        if len(group_address.split(',')) == 2:
            groupaddresses.append(group_address.split(','))
        elif len(group_address.split('/')) == 2:
            if group_address.split('/')[1].lower() == 'group':
                groupaddresses.append(['group', group_address.split('/')[0]])
            else:
                log('Skipping {} as is must contain IPAddress,hostname or groupname/group'.format(group_address))
        else:
            log('Skipping {} as is must contain IPAddress,hostname or groupname/group'.format(group_address))

    addresslist = []
    addipset = IPSet([])  # IPSet of all the addresses being added to ensure none of them overlap
    target = '1.1.1.1'

    # log(groupaddresses)
    result = True

    result = exec_fw_command(options.panoramaip, 'pano', [('create_address',
                                                           {'addressname': options.nexpose, 'addresstype': '8',
                                                            'zone': 'LAN', 'color': 'black', 'comment': 'NEXPOSE_GROUP',
                                                            'members': [], 'context': 'shared'})], syntax='api')

    if result:

        ## go create address groups elsewhere....

        for address_set in groupaddresses:
            address = address_set[0]
            badaddress = False
            if address.lower() == 'group':
                if address_set[1] in config['shared']['addresses']:
                    if config['shared']['addresses'][address_set[1]]['addrObjType'] == '8':
                        log('Adding group {} to new group {}'.format(address_set[1], ''))
                        addresslist.append((address_set[1], 'group'))
                    else:  ## no idea what this is doing
                        badaddress = True  ## not an address group
                        log('Skipping {} as it is not an address group object type'.format(group_address))
                        log(config['shared']['addresses'][address]['addrObjType'])
                else:  ## no idea what this is doing
                    badaddress = True  ## not found in addresses
                    log('Skipping {} as it was not found in shared addresses'.format(group_address))

            else:
                if len(re.findall('/', address)) == 1:
                    network, mask = address.split('/')
                elif len(re.findall('-', address)) == 1:  # address object is a range
                    # log('range found')
                    network, mask = address.split('-')
                elif len(re.findall('/', address)) == 0:
                    network = address
                    mask = '32'
                else:
                    log('!-- Skipping {} - Invalid netmask or address group not found'.format(address))
                    badaddress = True

            if not badaddress:
                try:
                    # tmpaddr=ipaddress.IPv4Network(network+'/'+str(mask))
                    tmpaddr = IPNetwork(network + '/' + str(mask))
                except Exception as e:
                    try:
                        # log(network, mask)
                        tmpaddr = IPRange(network, mask)
                    except:
                        log('!-- Skipping {} - {}'.format(address, e))
                        badaddress = True
            if not badaddress:  ## if addresses dont overlap, add the address to "addresslist"
                # if len(IPSet([network+'/'+str(mask)]) & config[context]['addresses'][groupmaster]['IPSet'])==0:
                # if len(IPSet(list(tmpaddr)) & config[context]['addresses'][groupmaster]['IPSet'])==0:
                # log(network)
                # if len(IPSet([network+'/'+str(mask)]) & addipset)==0:
                if len(IPSet(list(tmpaddr)) & addipset) == 0:
                    addresslist.append((network, mask, address))
                    # addipset.add(network+'/'+str(mask))
                    # log(tmpaddr)
                    addipset.add(tmpaddr)
                else:
                    log('!-- Skipping {} - Overlaps with another new address - Target: {}'.format(address, tmpaddr))
            # else:
            #    log('!-- Skipping {} - Overlaps with existing group member - Target: {}'.format(address, target))
        # print (len(config['shared']['addresses']))

        matches = {}

        for addr in addresslist: log(addr)
        log('-' * 100)
        for first, address_name in groupaddresses: log(address_name)

        for network, mask, address in addresslist:  ## build a list of existing address objects that match each object that needs to be created
            new_address = '{}/{}'.format(network, mask)
            matches[new_address] = []
            # log('new address : ', new_address)
            if mask.lower() != 'group':
                for address in config['shared'][
                    'addresses']:  ## build a list of existing address objects that match the object we want to add
                    if config['shared']['addresses'][address]['IPv4Networks'] == [ipaddress.IPv4Network(new_address)]:
                        # log(config['shared']['addresses'][address])
                        if address not in matches[new_address]: matches[new_address].append(address)

        new_address_name = None
        # debug(matches)

        for address_def, address_name in groupaddresses:  ## groupaddresses is a list of the original options.groupaddresses list split into a set of (address definition, name)
            # if address_def==new_address:
            debug('-' * 100)
            debug('outer loop')
            debug(address_name)
            # new_address_name=None
            if address_name.lower() != 'group':
                new_fqdn = address_name
                try:
                    new_hostname = address.name.split('.')[0]
                except:
                    new_hostname = address_name

                if len(matches[new_address]) == 0 and IPNetwork(address_def) == IPNetwork(
                        new_address):  # if no matching object found, create new object
                    new_address_name = address_name
                    log('Creating new address object {} defined as {}'.format(new_address_name, new_address))
                    base_address_name = new_address_name
                    count = 0
                    while new_address_name in config['shared']['addresses']:
                        debug('NAME CONFLICT!')
                        new_address_name = '{}_{}'.format(base_address_name, count)
                        count = +1
                    network, mask = new_address.split('/')
                    mask = cidr_to_netmask(mask)
                    result = exec_fw_command(options.panoramaip, 'pano', [('create_address',
                                                                           {'addressname': new_address_name,
                                                                            'ip1': network, 'ip2': mask,
                                                                            'addresstype': '1', 'zone': 'LAN',
                                                                            'color': 'black',
                                                                            'comment': 'NEXPOSE_SCANNERS',
                                                                            'context': 'shared'})], syntax='api')
                    if not result: log('Creating address object {} failed'.format(new_address_name))
                elif len(matches[new_address]) != 0:
                    for match in matches[new_address]:
                        debug('inner loop')
                        debug('match: ', match)
                        if new_fqdn.lower() == match.lower():  # matching object found, use object that matches FQDN first
                            new_address_name = new_fqdn
                            log('Using existing object name with fqdn match {} instead of {}'.format(new_address_name,
                                                                                                     address_name))
                            break
                        elif new_hostname.lower() == match.lower():  # matching object found, use object that matches hostname second
                            new_address_name = new_hostname
                            log('Using existing object name with hostname match {} instead of {}'.format(
                                new_address_name, address_name))
                            break
                    if not new_address_name:  # matching object found, use the name of the first matched object
                        debug('new address', new_address)
                        debug('matches', matches[new_address])
                        new_address_name = matches[new_address][0]
                        log('Using existing object name first on list {} instead of {}'.format(new_address_name,
                                                                                               address_name))
            if new_address_name:
                result = exec_fw_command(options.panoramaip, 'pano', [('modify_address', {'action': 'addmembers',
                                                                                          'addressname': options.nexpose,
                                                                                          'members': [new_address_name],
                                                                                          'comment': 'NEXPOSE_GROUP',
                                                                                          'addresstype': '8',
                                                                                          'zone': 'LAN',
                                                                                          'color': 'black',
                                                                                          'context': 'shared'})],
                                         syntax='api')
                if not result: log('Adding {} tp group {} failed'.format(new_address_name, options.nexpose))

        # else:  ## new address is a group, use network as the name
        #    new_address_name=network
        # if new_address_name:  ## add address to group
        #    # def create_address_obj(target, session, apikey, fw_type, syntax, params):
        #    # def exec_fw_command(target, fw_type, commands, syntax='cli', policylens=None, delay=None, use_session=True, use_apikey=False, dryrun=False):
        #    #result=exec_fw_command(options.panoramaip, 'pano', [('modify_address', {'action': 'addmembers', 'addressname': options.nexpose, 'members': ['NEXPOSE_'+new_address_name], 'comment': 'NEXPOSE_GROUP', 'addresstype': '8', 'zone': 'LAN', 'color': 'black', 'context': 'shared'})], syntax='api')
        #    pass
        # else:
        #    log('No matching address object')
        # for addr in config['shared']['addresses']:
        #    log(addr)
    else:
        log('Group Creation Failed')

if not True:  ## compare sonicwall NAT rules between versions 6.2 and 6.5 - both contexts must exist in config with _new and _old added to context name

    import re
    from urllib.parse import quote, unquote

    print(
        '{:20.20s}{:20.20s}{:20.20s}{:20.20s}{:20.20s}{:20.20s}{:40.40s}{:40.40s}{:20.20s}{:20.20s}{:20.20s}{:20.20s}'.format(
            'mgmtip', 'Note', 'new_rule_index', 'orig_src', 'orig_dst', 'orig_svc', 'trans_src', 'trans_dst',
            'trans_svc', 'iface_src', 'iface_dst', 'pol_enabled'))

    for context in config:

        if re.findall(r'_old', context):
            old = context  # .split('_')[0]
        elif re.findall(r'_new', context):
            new = context  # .split('_')[0]
    # OrderedDict([('natPolicyOrigSrc', ['']), ('natPolicyName', ''), ('natPolicyOrigDst', ['']), ('natPolicyOrigSvc', ['Idle%20HF']), ('natPolicyTransSrc', ['HF%20Backup%20X18%3aV1667%20IP']), ('natPolicyTransDst', ['']), ('natPolicyTransSvc', ['']), ('natPolicySrcIface', '-1'), ('natPolicyDstIface', '268862226'), ('natPolicyEnabled', '0'), ('natPolicyComment', 'Stack%20NAT%20Policy%20For%20HF'), ('natPolicyProperties', '1023'), ('natpolicyName', 'Empty'), ('natPolicyNum', ''), ('natPolicyUiNum', '')])
    # print(old, new)
    # print (len(config[new]['nat']), len(config[old]['nat']))
    for new_rule_index in config[new]['nat']:  # ['config']:
        trans_dst_list = []
        trans_src_list = []
        new_rule = config[new]['nat'][new_rule_index]
        orig_src, orig_dst, orig_svc, trans_src, trans_dst, trans_svc, iface_src, iface_dst, pol_enabled = unquote(
            str(new_rule['natPolicyOrigSrc'][0])), unquote(str(new_rule['natPolicyOrigDst'][0])), unquote(
            str(new_rule['natPolicyOrigSvc'][0])), unquote(str(new_rule['natPolicyTransSrc'][0])), unquote(
            str(new_rule['natPolicyTransDst'][0])), unquote(str(new_rule['natPolicyTransSvc'][0])), new_rule[
                                                                                                               'natPolicySrcIface'], \
                                                                                                           new_rule[
                                                                                                               'natPolicyDstIface'], unquote(
            str(new_rule['natPolicyEnabled'] == '1'))
        if orig_src == '': orig_src = 'Any'
        if orig_dst == '': orig_dst = 'Any'
        if orig_svc == '': orig_svc = 'Any'
        if trans_src == '': trans_src = 'Any'
        if trans_dst == '': trans_dst = 'Any'
        if trans_svc == '': trans_svc = 'Any'
        if int(iface_dst) > 0:
            iface_dst = unquote(config[context]['interfaces'][new_rule['natPolicyDstIface']]['iface_name'])
        else:
            iface_dst = 'Any'
        if int(iface_src) > 0:
            iface_src = unquote(config[context]['interfaces'][new_rule['natPolicySrcIface']]['iface_name'])
        else:
            iface_src = 'Any'
        # if iface_src=='-1': iface_src='Any'
        # if iface_src=='-1': iface_src='Any'
        # print(config[new]['nat'][new_rule])
        old_matched = 0
        new_matched = 0
        for old_rule_index in config[old]['nat']:  # ['config']:
            old_rule = config[old]['nat'][old_rule_index]
            if (new_rule['natPolicyOrigSrc'], new_rule['natPolicyOrigDst'], new_rule['natPolicyOrigSvc'],
                new_rule['natPolicyTransSrc'], new_rule['natPolicyTransDst'], new_rule['natPolicyTransSvc'],
                new_rule['natPolicySrcIface'], new_rule['natPolicyDstIface']) == (
            old_rule['natPolicyOrigSrc'], old_rule['natPolicyOrigDst'], old_rule['natPolicyOrigSvc'],
            old_rule['natPolicyTransSrc'], old_rule['natPolicyTransDst'], old_rule['natPolicyTransSvc'],
            old_rule['natPolicySrcIface'], old_rule['natPolicyDstIface']):
                old_matched = old_matched + 1
        for new_rule_index2 in config[new]['nat']:  # ['config']:
            new_rule2 = config[new]['nat'][new_rule_index2]
            if (new_rule['natPolicyOrigSrc'], new_rule['natPolicyOrigDst'], new_rule['natPolicyOrigSvc'],
                new_rule['natPolicyTransSrc'], new_rule['natPolicyTransDst'], new_rule['natPolicyTransSvc'],
                new_rule['natPolicySrcIface'], new_rule['natPolicyDstIface']) == (
            new_rule2['natPolicyOrigSrc'], new_rule2['natPolicyOrigDst'], new_rule2['natPolicyOrigSvc'],
            new_rule2['natPolicyTransSrc'], new_rule2['natPolicyTransDst'], new_rule2['natPolicyTransSvc'],
            new_rule2['natPolicySrcIface'], new_rule2['natPolicyDstIface']):
                new_matched = new_matched + 1
            elif (new_rule['natPolicyOrigSrc'], new_rule['natPolicyOrigDst'], new_rule['natPolicyOrigSvc'],
                  new_rule['natPolicyTransDst'], new_rule['natPolicyTransSvc'], new_rule['natPolicyDstIface']) == (
            new_rule2['natPolicyOrigSrc'], new_rule2['natPolicyOrigDst'], new_rule2['natPolicyOrigSvc'],
            new_rule2['natPolicyTransDst'], new_rule2['natPolicyTransSvc'],
            new_rule2['natPolicyDstIface']) and orig_svc != 'Idle HF' and str(
                    new_rule_index + 1) not in trans_src_list:  # and pol_enabled == 'True':
                trans_src_list.append(str(new_rule_index + 1))

                print(
                    '{:20.20s}{:20.20s}{:20.20s}{:20.20s}{:20.20s}{:20.20s}{:40.40s}{:40.40s}{:20.20s}{:20.20s}{:20.20s}{:20.20s}'.format(
                        config[context]['config']['mgmtip'], 'Diff Trans Source', str(new_rule_index + 1), orig_src,
                        orig_dst, orig_svc, trans_src, trans_dst, trans_svc, iface_src, iface_dst, pol_enabled))
        # print(new_rule_index,old_matched, new_matched)

        if old_matched == 0:
            print(
                '{:20.20s}{:20.20s}{:20.20s}{:20.20s}{:20.20s}{:20.20s}{:40.40s}{:40.40s}{:20.20s}{:20.20s}{:20.20s}{:20.20s}'.format(
                    config[context]['config']['mgmtip'], 'No matches', str(new_rule_index + 1), orig_src, orig_dst,
                    orig_svc, trans_src, trans_dst, trans_svc, iface_src, iface_dst, pol_enabled))
        if new_matched > 1:
            print(
                '{:20.20s}{:20.20s}{:20.20s}{:20.20s}{:20.20s}{:20.20s}{:40.40s}{:40.40s}{:20.20s}{:20.20s}{:20.20s}{:20.20s}'.format(
                    config[context]['config']['mgmtip'], 'Multiple matches', str(new_rule_index + 1), orig_src,
                    orig_dst, orig_svc, trans_src, trans_dst, trans_svc, iface_src, iface_dst, pol_enabled))
        # print('{:20.20s}{:20.20s}{:20.20s}{:20.20s}{:20.20s}{:20.20s}{:40.40s}{:40.40s}{:20.20s}{:20.20s}{:20.20s}{:20.20s}'.format(config[context]['config']['mgmtip'], 'All matches', str(new_rule_index + 1), orig_src, orig_dst, orig_svc, trans_src, trans_dst, trans_svc, iface_src, iface_dst, pol_enabled))
        # print(new_rule)
    print('-' * 280)
    # print(config[context]['interfaces'])

## SonicOS API Testing
if not True:
    import sonicwall as sw
    import json
    import re
    import time
    from collections import OrderedDict
    import sonicwall as sw
    import re

    urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

    for target in options.grouptargets:

        ## Enable API first

        session = requests.Session()
        session.mount('https://' + target, sw.DESAdapter())
        sw.do_login(session, options.username, options.password, target, preempt=True)
        response = sw.get_url(session, 'https://' + target + '/systemAdministrationView.html')
        csrf = re.findall(r'csrfToken.*"', response.text)[0].split('value=')[1].split('"')[1]
        postdata = {'csrfToken': csrf,
                    'cgiaction': "none",
                    'sonicOsApi_enable': "on",
                    'sonicOsApi_basicAuth': "on",
                    'cbox_sonicOsApi_enable': "",
                    'cbox_sonicOsApi_basicAuth': ""}
        url = 'https://' + target + '/main.cgi'
        api_result = send_sw_webcmd(session, url, postdata)
        sw.do_logout(session, target)

        ## Use API to send CLI command for groups
        session = requests.Session()
        session.mount('https://' + target, sw.DESAdapter())
        urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
        url = 'https://{}/api/sonicos/auth'.format(target)
        session.headers = OrderedDict(
            [('User-Agent', 'python-requests/2.18.4'), ('Accept', '*/*'), ('Accept-Encoding', 'gzip, deflate'),
             ('Connection', 'keep-alive')])
        post_data = None
        # auth = requests.auth.HTTPBasicAuth(options.username, options.password)
        response_code = None
        login_tries = 0
        while response_code != 200 and login_tries < 5:
            login_tries += 1
            response = session.post(url=url, headers={'authorization': "Basic " + base64.b64encode(
                '{}:{}'.format(options.username, options.password).encode()).decode()}, verify=False)
            response_code = response.status_code
            if response_code != 200:
                # session = requests.Session()
                # session.mount('https://' + target, sw.DESAdapter())
                # urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
                # url='https://{}/api/sonicos/auth'.format(target)
                debug('Login failed, retrying in 10 seconds')
                time.sleep(10)
        # /api/sonicos/access-rules/ipv4
        if response_code == 200:
            url = 'https://{}/api/sonicos/access-rules/ipv4'.format(target)
            session.headers.update({'content-type': 'text/plain'})
            # Application/JSON
            ''' This section is to retrieve LDAP server config if the BindDN name needs to be changed
            post_data = 'show user ldap'
            result=session.post(url=url, data=post_data, verify=False)
            result=send_sw_webcmd(session, url, post_data)
            log(result.text)
            ldap_config=json.loads(result.text)
            print(json.dumps(ldap_config, sort_keys=True, indent=4))
            for server in ldap_config['user']['ldap']['server']:
                print(server['bind']['distinguished_name'])
            '''

            # post_data = 'show user local groups\n'
            result = session.get(url=url, data=post_data, verify=False)
            response = json.loads(result.text)
            # print(response)
            # print(len(response['access_rules']))
            rule_uuids = []
            for rule in response['access_rules']:
                #    print(rule)
                rule_uuids.append(rule['ipv4']['uuid'])
            # print(rule_uuids)

            # for rule_uuid in rule_uuids[0]:
            print(rule_uuids[0])
            print(response['access_rules'][0])
            session.headers.update({'content-type': 'Application/JSON'})
            post_data = {'access_rule': {'ipv4': {'tcp': {'urgent': True}}}}
            url = 'https://{}/api/sonicos/access-rules/ipv4/uuid/{}'.format(target, rule_uuids[0])
            result = session.put(url=url, json=post_data, verify=False)
            print(result.text)
            post_data = None
            url = 'https://{}/api/sonicos/config/pending'.format(target)
            result = session.post(url=url, json=post_data, verify=False)
            print(result.text)

            # rw_result=json.loads(result.text)['status']['success']
            # for rule_uuid in
            '''
            print(groups)
            for group in groups['user']['local']['group']:
                if re.findall(r'^CS_FIREWALL', group['name'].upper()): 
                    group_name=group['name']
                    print(group_name)
                    post_data = 'user local\ngroup "{}"\ndomain any\nno memberships-by-ldap-location\ncommit\n'.format(group_name)
                    result=session.post(url=url, data=post_data, verify=False)
                    su_result=json.loads(result.text)['status']['success']
                    
                    #post_data = 'user local\ngroup "CS_FIREWALL_RO"\ndomain any\nno memberships-by-ldap-location\ncommit\n'
                    #result=session.post(url=url, data=post_data, verify=False)
                    r#o_result=json.loads(result.text)['status']['success']
                    
                    
                    #post_data = 'user local\ngroup "CS_FIREWALL_RW"\ndomain any\nno memberships-by-ldap-location\ncommit\n'
                    #result=session.post(url=url, data=post_data, verify=False)
                    #rw_result=json.loads(result.text)['status']['success']
                    
                    log('{},{},{},{},{},{}'.format(target, login_tries, ro_result, rw_result, su_result, ""))
            '''
        else:
            log('{},{},{},{},{},{}'.format(target, login_tries, 'Skipped', 'Skipped', 'Skipped', 'Login Failed'))

        ## Log out via DELETE method
        url = 'https://{}/api/sonicos/auth'.format(target)
        post_data = None
        session.delete(url=url, verify=False)

if not True:  ## compare sonicwall 6.2 and 6.5 configs

    # load_sonicwall_api('10.215.16.61','admin','admin')
    # log(config['sonicwall']['interfaces'])
    # log(config['sonicwall']['addressmappings'])
    # log(config['sonicwall']['servicemappings'])
    # log(sw_enable_api('10.215.16.61', 'admin', 'admin'))
    import pprint
    import sys
    import json


    # pp = pprint.PrettyPrinter(indent=2)
    # pp.pprint(config)

    def get_size(obj, seen=None):
        """Recursively finds size of objects"""
        size = sys.getsizeof(obj)
        if seen is None:
            seen = set()
        obj_id = id(obj)
        if obj_id in seen:
            return 0
        # Important mark as seen *before* entering recursion to gracefully handle
        # self-referential objects
        seen.add(obj_id)
        if isinstance(obj, dict):
            size += sum([get_size(v, seen) for v in obj.values()])
            size += sum([get_size(k, seen) for k in obj.keys()])
        elif hasattr(obj, '__dict__'):
            size += get_size(obj.__dict__, seen)
        elif hasattr(obj, '__iter__') and not isinstance(obj, (str, bytes, bytearray)):
            size += sum([get_size(i, seen) for i in obj])
        return size


    pp = pprint.PrettyPrinter(indent=2)
    # pp.pprint(config)

    # for context in config:
    #    log(context)
    #    if context != 'shared':
    #        for address in config[context]['addresses']:
    #            if config[context]['addresses'][address]['addrObjType'] == '8':
    #                log(pp.pprint(config[context]['addresses'][address]))
    from urllib.parse import unquote as url_unquote
    from urllib.parse import quote as url_quote

    skip_keys = ['addrObjProperties', 'usedzones', 'addressmappings', 'config', 'servicemappings', 'svcObjProperties']
    in_a_not_b = []
    in_b_not_a = []

    config_items = 'addresses'
    for config_item in config['sonicwall']:
        log('config_item', config_item)
        if config_item not in skip_keys:
            for config_key in config['sonicwall'][config_item]:
                config_key_quoted = url_quote(config_key)
                log('     config_key', config_key)
                if config_key_quoted in config['edp2sfwedsvcslab01'][config_item] and config_key not in skip_keys:
                    for key in config['sonicwall'][config_item][config_key]:
                        key = url_quote(key)
                        log('     key', key)
                        if key in config['edp2sfwedsvcslab01'][config_item][config_key_quoted] and key not in skip_keys:
                            if config['sonicwall'][config_item][config_key][key] != \
                                    config['edp2sfwedsvcslab01'][config_item][config_key_quoted][key]:
                                try:
                                    if url_quote(config['sonicwall'][config_item][config_key][key]) != \
                                            config['edp2sfwedsvcslab01'][config_item][config_key_quoted][key]:
                                        log('!-- {:20.20} - {:20.20} - {:50.50} - {:50.50}'.format(str(config_key), key,
                                                                                                   str(config[
                                                                                                           'sonicwall'][
                                                                                                           config_item][
                                                                                                           config_key][
                                                                                                           key]), str(
                                                config['edp2sfwedsvcslab01'][config_item][config_key_quoted][key])))
                                except:
                                    log('!-- {:20.20} - {:20.20} - {:50.50} - {:50.50}'.format(str(config_key), key,
                                                                                               str(config['sonicwall'][
                                                                                                       config_item][
                                                                                                       config_key][
                                                                                                       key]), str(
                                            config['edp2sfwedsvcslab01'][config_item][config_key_quoted][key])))
                        elif key not in config['edp2sfwedsvcslab01'][config_item][config_key_quoted]:
                            if key not in in_a_not_b:
                                in_a_not_b.append(key)
                                log('!-- Key {} in api but not in exp'.format(key))
                elif config_key_quoted not in config['edp2sfwedsvcslab01'][config_item]:
                    log('!-- Config key {} in api but not in exp'.format(config_key))

    '''
            for item in config[context]:
                log('{:20.20} {:20.20} {:20.20}'.format(item, str(len(config[context][item])) ,str(get_size(config[context][item])) ))
                if len(config[context][item]) > 0 and item != 'usedzones':
                    log(pp.pprint(config[context][item][next(iter(config[context][item]))]))
            print('total dict size', sys.getsizeof(config[context]))
    '''

    # print('total dict size', get_size(config))

if not True:
    from netaddr import IPRange

    for context in config:
        # for p in config[context]['nat']:
        #    if config[context]['nat'][p]['natPolicyName']=='##Hop-Durham-TPA':
        #        log(config[context]['nat'][p])
        for address in config[context]['addresses']:
            if config[context]['addresses'][address]['addrObjType'] == '2':
                try:
                    # log('{:10.10} {:50.50} : {:20.20} : {:20.20}'.format(str(len(IPRange(config[context]['addresses'][address]['addrObjIp1'],config[context]['addresses'][address]['addrObjIp2']))), config[context]['addresses'][address]['addrObjId'],config[context]['addresses'][address]['addrObjIp1'],config[context]['addresses'][address]['addrObjIp2']))
                    log('{},{},{},{}'.format(str(len(IPRange(config[context]['addresses'][address]['addrObjIp1'],
                                                             config[context]['addresses'][address]['addrObjIp2']))),
                                             config[context]['addresses'][address]['addrObjId'],
                                             config[context]['addresses'][address]['addrObjIp1'],
                                             config[context]['addresses'][address]['addrObjIp2']))
                except:
                    # log('{:10.10} {:50.50} : {:20.20} : {:20.20}'.format('error', config[context]['addresses'][address]['addrObjId'],config[context]['addresses'][address]['addrObjIp1'],config[context]['addresses'][address]['addrObjIp2']))
                    log('{},{},{},{}'.format('error', config[context]['addresses'][address]['addrObjId'],
                                             config[context]['addresses'][address]['addrObjIp1'],
                                             config[context]['addresses'][address]['addrObjIp2']))

if not True:  # troubleshooting zone assignment for create_tuples
    addr_names = ['glbl-ps3gtm-m.us.dell.com', 'glbl-ps3gtm01.us.dell.com', 'glbl-ps3gtm02.us.dell.com',
                  'glbl-pc1gtm01.us.dell.com', 'glbl-pc1gtm02.us.dell.com']
    for addr in addr_names:
        print(addr, get_zone('checkpoint', config['checkpoint']['addresses'][addr]['addrObjIp1']))
    # log(config['checkpoint']['interfaces'])
    # log(config['checkpoint']['zones'])
    log(config['checkpoint']['policies'][132])
    for addr in config['checkpoint']['policies'][132]['policySrcNet']:
        print(addr, get_zone('checkpoint', config['checkpoint']['addresses'][addr]['addrObjIp1']))
    for addr in config['checkpoint']['policies'][132]['policyDstNet']:
        print(addr, get_zone('checkpoint', config['checkpoint']['addresses'][addr]['addrObjIp1']))

if not True:
    log(config['checkpoint']['services']['tcp-high-ports'])
    for addr in config['checkpoint']['addresses']:
        if config['checkpoint']['addresses'][addr]['addrObjType'] == '98':
            log(addr, config['checkpoint']['addresses'][addr]['IPSet'])

if not True:
    old_loglevel = options.logging
    options.logging = 0
    for search_ip in options.groupaddresses:
        from netaddr import IPSet, IPNetwork, IPRange

        search_ip = '10.99.5.141'
        log('{:20.20s} | {:20.20s} | {:20.20s} | {:20.20s} | {:20.20s} | {:20.20s}'.format('Source', 'Destination',
                                                                                           'Nexthop', 'Interface',
                                                                                           'Zone', 'Match Length'))
        log('-' * 135)
        bestmatch = {'len': -1, 'zone': None, 'iface': None, 'gateway': None}
        for route in config['sonicwall']['routing']:
            if config['sonicwall']['routing'][route]['pbrObjSrc'] == '':
                source = 'Any'
            else:
                source = config['sonicwall']['routing'][route]['pbrObjSrc']
            gateway = config['sonicwall']['routing'][route]['pbrObjGw']
            if gateway in config['sonicwall']['addresses']:
                gateway = config['sonicwall']['addresses'][gateway]['addrObjIp1']
            elif gateway == '':
                gateway = '0.0.0.0'
            iface = config['sonicwall']['routing'][route]['pbrObjIface']
            zone = ''
            for interface in config['sonicwall']['interfaces']:
                if config['sonicwall']['interfaces'][interface]['iface_name'] == iface:
                    zone = config['sonicwall']['interfaces'][interface]['interface_Zone']
            if config['sonicwall']['routing'][route]['pbrObjDst'] in config['sonicwall']['addresses']:
                for dest in expand_address(config['sonicwall']['addresses'],
                                           config['sonicwall']['routing'][route]['pbrObjDst'], config['sonicwall'][
                                               'addressmappings']):  # def expand_address(address_dict, address_object, address_map, inc_group=False):
                    if config['sonicwall']['addresses'][dest]['addrObjType'] == '2':
                        for range_ip in IPRange(config['sonicwall']['addresses'][dest]['addrObjIp1'],
                                                config['sonicwall']['addresses'][dest]['addrObjIp2']):
                            # log(range_ip)
                            dest_network = '{}/{}'.format(range_ip, '32')
                            if IPNetwork(search_ip) in IPNetwork(dest_network) and source == 'Any':
                                matchlen = 32
                            else:
                                matchlen = -1
                            log('{:20.20s} | {:20.20s} | {:20.20s} | {:20.20s} | {:20.20s} | {:20.20s}'.format(source,
                                                                                                               dest_network,
                                                                                                               gateway,
                                                                                                               iface,
                                                                                                               zone,
                                                                                                               str(matchlen)))
                            if matchlen > bestmatch['len']:
                                bestmatch = {'len': matchlen, 'zone': zone, 'iface': iface, 'gateway': gateway}

                    else:
                        dest_network = '{}/{}'.format(config['sonicwall']['addresses'][dest]['addrObjIp1'],
                                                      netmask_to_cidr(
                                                          config['sonicwall']['addresses'][dest]['addrObjIp2']))
                        if IPNetwork(search_ip) in IPNetwork(dest_network) and source == 'Any':
                            matchlen = netmask_to_cidr(config['sonicwall']['addresses'][dest]['addrObjIp2'])
                        else:
                            matchlen = -1
                        log('{:20.20s} | {:20.20s} | {:20.20s} | {:20.20s} | {:20.20s} | {:20.20s}'.format(source,
                                                                                                           dest_network,
                                                                                                           gateway,
                                                                                                           iface, zone,
                                                                                                           str(matchlen)))
                        if matchlen > bestmatch['len']:
                            bestmatch = {'len': matchlen, 'zone': zone, 'iface': iface, 'gateway': gateway}
            else:
                if config['sonicwall']['routing'][route]['pbrObjDst'] in ['', '0.0.0.0']:
                    dest_network = '0.0.0.0/0'
                else:
                    dest_network = config['sonicwall']['routing'][route]['pbrObjDst']
                if IPNetwork(search_ip) in IPNetwork(dest_network) and source == 'Any':
                    matchlen = int(dest_network.split('/')[
                                       1])  # netmask_to_cidr(config['sonicwall']['addresses'][dest]['addrObjIp2'])
                else:
                    matchlen = -1
                log('{:20.20s} | {:20.20s} | {:20.20s} | {:20.20s} | {:20.20s} | {:20.20s}'.format(source, dest_network,
                                                                                                   gateway, iface, zone,
                                                                                                   str(matchlen)))
                if matchlen > bestmatch['len']:
                    bestmatch = {'len': matchlen, 'zone': zone, 'iface': iface, 'gateway': gateway}

        # log('-' * 135, level=0)
        log(bestmatch, level=0)
    log('-' * 135, level=0)
    options.logging = old_loglevel
# log('Sonicwall IP {} Zone for 10.0.0.1 : {}'.format(options.sonicwall_api_ip, get_zone('rr5sfwpgnet', '10.0.0.1')))
# log('Sonicwall IP {} Zone for 100.64.0.1 : {}'.format(options.sonicwall_api_ip, get_zone('rr5sfwpgnet', '100.64.0.1')))
# log('Sonicwall IP {} Zone for 10.0.18.82 : {}'.format(options.sonicwall_api_ip, get_zone('rr5sfwpgnet', '10.0.18.82')))


# target='10.215.16.61'
# options.username='admin'
# options.password='admin'

import sonicwall as sw
import base64

# for target in options.grouptargets:

#    print('{}: Set timeout: {}'.format(target, sw_set_webtimeout(target, options.username, options.password, 15)))

'''
    
    ## Fix splunk
    ## 
    fw_name=None
    for context in contexts:
        if config[context]['config']['fw_type'] in ['sonicwall', 'sw_65']:
            fw_name=config[context]['config']['name']
            break
    if fw_name != None:
        print('{}: Enable API: {}'.format(target, sw_enable_api(target, options.username, options.password)))
        session = requests.Session()
        session.mount('https://' + target, sw.DESAdapter())
        urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
        url='https://{}/api/sonicos/auth'.format(target)
        session.headers=OrderedDict([('User-Agent', 'python-requests/2.18.4'), ('Accept', '*/*'), ('Accept-Encoding', 'gzip, deflate'), ('Connection', 'keep-alive')])
        post_data=None
        response_code=None
        login_tries=0
        while response_code != 200 and login_tries < 5:
            login_tries+=1
            response=session.post(url=url, headers={'authorization': "Basic " + base64.b64encode('{}:{}'.format(options.username, options.password).encode()).decode()}, verify=False)
            response_code=response.status_code
            if response_code != 200:
                time.sleep(10)

        if response_code == 200:
            url='https://{}/api/sonicos/direct/cli'.format(target)
            session.headers.update({'content-type': 'text/plain'})
            post_data = 'cli idle-timeout default 300\n'
            result=session.post(url=url, data=post_data, verify=False)
            #post_data = 'commit\n'
            #result=session.post(url=url, data=post_data, verify=False)
            post_data ='address-object ipv4 "Splunk_Austin" host 10.143.0.231\nlog syslog\nsyslog-server server name Splunk_Austin port 514 profile 0\nid {}\ncommit\n'.format(fw_name)
            post_data ='address-object ipv4 "Splunk_APAC" host 10.93.131.112\nlog syslog\nsyslog-server server name Splunk_APAC port 514 profile 0\nid {}\ncommit\n'.format(fw_name)
            #post_data ='address-object ipv4 "Splunk_EMEA" host 10.78.13.59\nlog syslog\nsyslog-server server name Splunk_EMEA port 514 profile 0\nid {}\ncommit\n'.format(fw_name)
            result=session.post(url=url, data=post_data, verify=False)
            #log(result)
            #log(result.text)
        print('{}: Disable API: {}'.format(target, sw_disable_api(target, options.username, options.password)))
'''

# for context in config:
#    if 'zones' in config[context]:
#        for zone in config[context]['zones']:
#            print(zone)

#    if config[context]['config']['fw_type'] in ['sw65', 'sonicwall']:
#        for zone in config[context]['zones']:
#        print(zone)
# log(config['rr5sfwpgnet']['zones'])
# log(get_zone('rr5sfwpgnet', '10.0.0.0'))
# log(get_zones('rr5sfwpgnet', 'PGNET-Dell'))

# if True:
#    for context in config:
#        if 'routing' in config[context]:
#            for route in config[context]['routing']:
#                if config[context]['routing'][route]['pbrObjSrc'] != '':
#                    log(config[context]['routing'][route])

if not True:
    options.devmap = ['Extranet_PC1,Extranet_Outside']
    options.devmap = ['Extranet_PC1,Pc1_DMZ_Firewalls']

    # for context in config:
    #    log(context)
    for devmap in options.devmap:
        for devgroup, template in [devmap.split(',')]:
            if devgroup in config and template in config:
                # log(config[devgroup]['routing'])
                if 'vrouters' in config[template]:
                    config[devgroup]['routing'] = {}
                    # log(config[context]['vrouters'])
                    for vrouter in config[template]['vrouters']:
                        log('VRouter Name: {}'.format(vrouter))
                        route_num_int = 0

                        for route in config[template]['vrouters'][vrouter]:
                            route_num = str(route_num_int)
                            # log(config[template]['vrouters'][vrouter][route])

                            config[devgroup]['routing'][route_num] = {}
                            config[devgroup]['routing'][route_num]['pbrObjId'] = 'Route {}'.format(route_num)
                            config[devgroup]['routing'][route_num]['pbrObjSrc'] = ''
                            config[devgroup]['routing'][route_num]['pbrObjDst'] = \
                            config[template]['vrouters'][vrouter][route]['destination']
                            config[devgroup]['routing'][route_num]['pbrObjGw'] = \
                            config[template]['vrouters'][vrouter][route]['nexthops'][0]
                            config[devgroup]['routing'][route_num]['pbrObjIface'] = ''
                            config[devgroup]['routing'][route_num]['pbrObjIfaceName'] = ''
                            config[devgroup]['routing'][route_num]['pbrObjMetric'] = ''
                            config[devgroup]['routing'][route_num]['pbrObjPriority'] = ''
                            config[devgroup]['routing'][route_num]['pbrObjProbe'] = ''
                            config[devgroup]['routing'][route_num]['pbrObjComment'] = ''
                            config[devgroup]['routing'][route_num]['pbrObjUUID'] = ''
                            config[devgroup]['routing'][route_num]['pbrObjSvc'] = ''
                            # log(config[devgroup]['routing'][route_num])

                            route_num_int += 1
                if 'interfaces' in config[template]:
                    interfce_num_int = 0
                    config[devgroup]['interfaces'] = {}
                    for interface in config[template]['interfaces']:
                        # interface_num=str(interface_num_int)
                        interface_name = config[template]['interfaces'][interface]['iface_name']
                        config[devgroup]['interfaces'][interface_name] = {}
                        config[devgroup]['interfaces'][interface_name]['iface_ifnum'] = \
                        config[template]['interfaces'][interface]['iface_ifnum']
                        config[devgroup]['interfaces'][interface_name]['iface_type'] = \
                        config[template]['interfaces'][interface]['iface_type']
                        config[devgroup]['interfaces'][interface_name]['iface_name'] = \
                        config[template]['interfaces'][interface]['iface_name']
                        config[devgroup]['interfaces'][interface_name][
                            'interface_Zone'] = ''  ## assign when reading zones
                        config[devgroup]['interfaces'][interface_name]['iface_comment'] = \
                        config[template]['interfaces'][interface]['iface_comment']
                        config[devgroup]['interfaces'][interface_name]['iface_static_ip'] = ''
                        config[devgroup]['interfaces'][interface_name]['iface_static_mask'] = ''
                        config[devgroup]['interfaces'][interface_name]['iface_static_gateway'] = ''
                        config[devgroup]['interfaces'][interface_name]['iface_lan_ip'] = \
                        config[template]['interfaces'][interface]['iface_static_ip']
                        config[devgroup]['interfaces'][interface_name]['iface_lan_mask'] = \
                        config[template]['interfaces'][interface]['iface_static_mask']
                        config[devgroup]['interfaces'][interface_name]['iface_lan_default_gw'] = \
                        config[template]['interfaces'][interface]['iface_static_gateway']
                        config[devgroup]['interfaces'][interface_name]['iface_mgmt_ip'] = ''
                        config[devgroup]['interfaces'][interface_name]['iface_mgmt_netmask'] = ''
                        config[devgroup]['interfaces'][interface_name]['iface_mgmt_default_gw'] = ''
                        config[devgroup]['interfaces'][interface_name]['iface_vlan_tag'] = ''
                        config[devgroup]['interfaces'][interface_name]['iface_http_mgmt'] = ''
                        # config[devgroup]['interfaces'][interface_num]['']=
                        log(config[devgroup]['interfaces'][interface_name])
                        log(config[template]['interfaces'][interface])

                        # interface_num_int += 1

                if 'zones' in config[template]:
                    zone_num_int = 0
                    for zone in config[template]['zones']:
                        zone_num = str(zone_num_int)
                        config[devgroup]['zones'][zone_num] = {}
                        config[devgroup]['zones'][zone_num]['zoneObjId'] = config[template]['zones'][zone]['zoneObjId']
                        config[devgroup]['zones'][zone_num]['zoneObjComment'] = 'Zone Comment'
                        config[devgroup]['zones'][zone_num]['zoneObjMembers'] = config[template]['zones'][zone][
                            'zoneObjMembers']

                        for zone_member in config[template]['zones'][zone]['zoneObjMembers']:
                            for interface in config[devgroup]['interfaces']:
                                if config[devgroup]['interfaces'][interface]['iface_name'] == zone_member:
                                    config[devgroup]['interfaces'][interface]['interface_Zone'] = \
                                    config[template]['zones'][zone]['zoneObjId']
                        log(config[devgroup]['interfaces'][interface]['iface_name'])
                        zone_num_int += 1
                for interface in config[devgroup]['interfaces']:
                    log(config[devgroup]['interfaces'][interface])
                    '''
                    # interface_props = ['iface_ifnum', 'iface_type', 'iface_name', 'interface_Zone', 'iface_comment', 'iface_static_ip', 'iface_static_mask', 'iface_static_gateway', 'iface_lan_ip', 'iface_lan_mask', 'iface_lan_default_gw', 'iface_mgmt_ip', 'iface_mgmt_netmask', 
                    # 'iface_mgmt_default_gw', 'iface_static_gateway', 'iface_vlan_tag', 'iface_comment', 'iface_http_mgmt', 
                    # zone_props = ['zoneObjId', 'zoneObjComment']
                    
                    # zone_name=zone.get('name')
                    return_zones[zone_name]=OrderedDict()
                    return_zones[zone_name]['zoneObjId']=zone_name
                    return_zones[zone_name]['zoneObjComment']='Zone Comment'
                    return_zones[zone_name]['zoneObjMembers']=[]
                    #print(zone.get('name'))
                    for interface in zone.findall('.//member'):
                        #print(interface.text)
                    return_zones[zone_name]['zoneObjMembers'].append(interface.text)
    

                    return_interface[interface_name]['iface_ifnum']=str(index)
                    return_interface[interface_name]['iface_type']=interface_type.tag
                    return_interface[interface_name]['iface_name']=interface_name
                    return_interface[interface_name]['interface_Zone']='' # this would get set when reading zones

                    comment=root.find(interface_base + '/' + interface_type.tag + '/entry[@name="' + interface_name + '"]/comment')
                    if comment!=None: return_interface[interface_name]['iface_comment' ]=comment.text
                    for interface in root.findall(interface_base + '/' + interface_type.tag + '/entry[@name="' + interface_name + '"]'):
                        for interface_attribs in interface:
                            if interface_type.tag in ['ethernet', 'aggregate-ethernet'] and interface_attribs.tag.lower()=='layer3':
                                ip=root.find(interface_base + '/' +  interface_type.tag + '/entry[@name="' + interface_name + '"]/' + interface_attribs.tag + '/ip/entry[@name]')                                
                                if ip!=None:
                                    if ip.get('name') in return_variables: 
                                        ipname=return_variables[ip.get('name')]
                                    else:
                                        ipname=ip.get('name')
                                    if re.findall('/', ipname):
                                        return_interface[interface_name]['iface_static_ip'], return_interface[interface_name]['iface_static_mask'] = ipname.split('/')
                                        return_interface[interface_name]['iface_static_mask']=cidr_to_netmask(return_interface[interface_name]['iface_static_mask'])
                                    else:
                                        return_interface[interface_name]['iface_static_ip'], return_interface[interface_name]['iface_static_mask'] = '0.0.0.0', '0'
                                if interface_type.tag=='aggregate-ethernet': # get ip addresses for sub-interfaces
                                    for sub_interfaces in root.findall(interface_base + '/' +  interface_type.tag + '/entry[@name="' + interface_name + '"]/layer3/units/entry[@name]'):
                                        sub_interface=sub_interfaces.get('name')
                                        return_interface[sub_interface]=OrderedDict()
                                        return_interface[sub_interface]['iface_ifnum']=str(index)
                                        return_interface[sub_interface]['iface_type']=interface_type.tag
                                        return_interface[sub_interface]['iface_name']=sub_interface
                                        return_interface[sub_interface]['interface_Zone']='' # this would get set when reading zones
                                        return_interface[sub_interface]['iface_comment' ]=''
                                        return_interface[sub_interface]['iface_static_ip']=''
                                        return_interface[sub_interface]['iface_static_mask']=''
                                        return_interface[sub_interface]['iface_static_gateway']=''
                                        return_interface[sub_interface]['iface_lan_ip']=''
                                        return_interface[sub_interface]['iface_lan_mask']=''
                                        return_interface[sub_interface]['iface_lan_default_gw']=''
                                        return_interface[sub_interface]['iface_mgmt_ip']=''
                                        return_interface[sub_interface]['iface_mgmt_netmask']=''
                                        return_interface[sub_interface]['iface_mgmt_default_gw']=''
                                        return_interface[sub_interface]['iface_vlan_tag']=''
                                        return_interface[sub_interface]['portShutdown']=''
                                        index += 1
                                        ip=root.find(interface_base + '/' + interface_type.tag + '/entry[@name="' + interface_name + '"]/' + interface_attribs.tag + '/units/entry[@name="' + sub_interface + '"]/ip/entry[@name]')
                                        tag=root.find(interface_base + '/' + interface_type.tag + '/entry[@name="' + interface_name + '"]/' + interface_attribs.tag + '/units/entry[@name="' + sub_interface + '"]/tag')
                                        comment=root.find(interface_base + '/' + interface_type.tag + '/entry[@name="' + interface_name + '"]/' + interface_attribs.tag + '/units/entry[@name="' + sub_interface + '"]/comment')
                                        if ip!=None: 
                                            if ip.get('name') in return_variables: 
                                                ipname=return_variables[ip.get('name')]
                                            else:
                                                ipname=ip.get('name')
                                            if re.findall('/', ipname):
                                                return_interface[sub_interface]['iface_static_ip'], return_interface[sub_interface]['iface_static_mask'] =ipname.split('/')
                                                return_interface[sub_interface]['iface_static_mask']=cidr_to_netmask(return_interface[sub_interface]['iface_static_mask'])
                                            else:
                                                return_interface[sub_interface]['iface_static_ip'], return_interface[sub_interface]['iface_static_mask'] = '0.0.0.0', '0'
                                        if tag!=None: return_interface[sub_interface]['iface_vlan_tag']=tag.text
                                        if comment!=None: return_interface[sub_interface]['iface_comment' ]=comment.text
                    '''

                    ''' 
                    OrderedDict([('destination', '128.222.0.0/19'), ('metric', '1'), ('bfd', None), ('nexthops', ['143.166.87.137'])])
                    sonicwall_config['routing'][route_num]['pbrObjId']=route['ipv4']['name']
                    sonicwall_config['routing'][route_num]['pbrObjProperties']=''

                    if 'name' in route['ipv4']['source']:
                        sonicwall_config['routing'][route_num]['pbrObjSrc']=route['ipv4']['source']['name']
                    else:
                        sonicwall_config['routing'][route_num]['pbrObjSrc']=''

                    if 'name' in route['ipv4']['destination']:
                        sonicwall_config['routing'][route_num]['pbrObjDst']=route['ipv4']['destination']['name']
                    elif 'group' in route['ipv4']['destination']:
                        sonicwall_config['routing'][route_num]['pbrObjDst']=route['ipv4']['destination']['group']
                    else:
                        sonicwall_config['routing'][route_num]['pbrObjDst']=''
                    if 'name' in route['ipv4']['gateway']:                    
                        sonicwall_config['routing'][route_num]['pbrObjGw']=route['ipv4']['gateway']['name']
                    else:
                        sonicwall_config['routing'][route_num]['pbrObjGw']=''
                    sonicwall_config['routing'][route_num]['pbrObjIface']=route['ipv4']['interface']
                    sonicwall_config['routing'][route_num]['pbrObjIfaceName']=route['ipv4']['interface']
                    sonicwall_config['routing'][route_num]['pbrObjMetric']=str(route['ipv4']['metric'])
                    sonicwall_config['routing'][route_num]['pbrObjPriority']=''
                    sonicwall_config['routing'][route_num]['pbrObjProbe']=route['ipv4']['probe']
                    sonicwall_config['routing'][route_num]['pbrObjComment']=route['ipv4']['comment']
                    sonicwall_config['routing'][route_num]['pbrObjUUID']=route['ipv4']['uuid']
                    sonicwall_config['routing'][route_num]['pbrObjSvc']=''
                    '''
                    pass
'''
for context in config:
    if 'routing' in config[context]:
        for route in config[context]['routing']:
            log (config[context]['routing'][route])

for context in config:
    if 'interfaces' in config[context]:
        for interface in config[context]['interfaces']:
            log (config[context]['interfaces'][interface])
'''
if options.addgroupmember and (options.sonicwallip or options.sonicwall_api_ip):
    retries = 3
    for context in config:
        if context in options.context:
            group_created = False
            api_type = 'api'
            fw_type = config[context]['config']['fw_type']

            if options.sonicwallip:
                target = options.sonicwallip
            else:
                target = options.sonicwall_api_ip
            orig_api_enabled = sw_get_api_status(target, options.username, options.password)
            log(orig_api_enabled)
            # if not orig_api_enabled:
            sw_enable_api(target, options.username, options.password)

            if fw_type == 'sw65':
                sw_objects = get_sw_objects(target, options.username, options.password, fw_type)
            # debug(fw_type)
            # debug(sw_objects)
            for mappings in options.addgroupmember:
                group, member = mappings.split(',')
                if member in config[context]['addresses']:
                    tries = 0
                    success = False
                    while tries < retries and not success:
                        tries += 1
                        try:
                            log('Removing temp_address_object from {}'.format(member))
                            result = exec_fw_command(target, fw_type, [('modify_address',
                                                                        {'action': 'delmembers', 'addressname': member,
                                                                         'members': ['temp_address_object'],
                                                                         'addresstype': '8', 'color': 'black',
                                                                         'context': context})], syntax=api_type,
                                                     delay=0, sw_objects=sw_objects)
                            # log(result)
                            if group in config[context]['addresses'] or group_created:
                                log('Adding member object {} to group {} in context {}'.format(member, group, context))
                                result = exec_fw_command(target, fw_type, [('modify_address', {'action': 'addmembers',
                                                                                               'addressname': group,
                                                                                               'members': [member],
                                                                                               'addresstype': '8',
                                                                                               'color': 'black',
                                                                                               'context': context})],
                                                         syntax=api_type, delay=0, sw_objects=sw_objects)
                                log(result)
                            else:
                                log('Adding member object {} to new group {} in context {}'.format(member, group,
                                                                                                   context))
                                result = exec_fw_command(target, fw_type, [('create_address', {'action': 'addmembers',
                                                                                               'addressname': group,
                                                                                               'members': [member],
                                                                                               'addresstype': '8',
                                                                                               'color': 'black',
                                                                                               'context': context})],
                                                         syntax=api_type, delay=0, sw_objects=sw_objects)
                                # log(result)
                                group_created = result == True
                            success = True
                        except Exception as e:
                            log('Exception occured attempting to add address object to group: {}'.format(e))
                else:
                    log('Skipping adding member object {} to group {} in context {} -- Member object not found'.format(
                        member, group, context))
            # if not orig_api_enabled:
            #    sw_disable_api(target, options.username, options.password)


def bulk_create_rules(target, config=None):
    try:

        if options.fwtype in ['sw', 'sonicwall']:  ## not really supported as I need to read in routing table
            config = get_sonicwall_exp(target)
        elif options.fwtype in ['sw65']:
            config = {}
            config['sonicwall'] = load_sonicwall_api(target, options.username, options.password)
            if not options.context:
                options.context = ['sonicwall']
            for context in options.context:
                contexts.append(context)
        elif options.fwtype in ['palo', 'panorama', 'pano']:
            palo_xml = get_palo_config_https(target, 'config.panorama.temp', options.username, options.password)
            if palo_xml:
                config = load_xml('', palo_xml)
                palo_xml = None
        elif options.fwtype in ['cp', 'checkpoint']:  ## config needs to be loaded and passed to routines
            pass
        # log(options.nexposerule)
        # log('-' *180)
        return_status = []
        for ruleitems in options.nexposerule:
            # log('processing ruleitem', ruleitems)
            # log(ruleitems.split(','))
            # log(len(ruleitems.split(',')))
            # log(options.context[0])
            if len(ruleitems.split(',')) >= 8:  # rule_name, src_zone, src_net, dst_zone, dst_net, action, comment
                # for context in config:
                #    log(context)
                #    for item in config[context]:
                #        log(item)
                rule_name, src_zones, src_address, dst_zones, dst_address, dst_service, action, *comment = ruleitems.split(
                    ',')
                comment = ','.join(comment)
                # log(src_zones)
                if src_zones == '':
                    if options.fwtype.lower() in ['sw', 'sw65', 'sonicwall']:
                        try:
                            src_zones = [config[options.context[0]]['addresses'][
                                             expand_address(config[options.context[0]]['addresses'], src_address,
                                                            config[options.context[0]]['addressmappings'])[0]][
                                             'addrObjZone']]
                        except:
                            src_zones = []
                    else:
                        src_zones = get_zones2(options.context[0], src_address, config)
                elif src_zones[0] == '%':
                    src_zones = [get_zone(options.context[0], src_zones[1:], config)]
                else:
                    src_zones = [src_zones]
                if dst_zones == '':
                    if options.fwtype.lower() in ['sw', 'sw65', 'sonicwall']:
                        # log(expand_address(config[options.context[0]]['addresses'], dst_address, config[options.context[0]]['addressmappings']))
                        try:
                            dst_zones = [config[options.context[0]]['addresses'][
                                             expand_address(config[options.context[0]]['addresses'], dst_address,
                                                            config[options.context[0]]['addressmappings'])[0]][
                                             'addrObjZone']]
                        except:
                            dst_zones = []
                    else:
                        dst_zones = get_zones2(options.context[0], dst_address, config)
                elif dst_zones[0] == '%':
                    # log(dst_zones[1:])
                    dst_zones = [get_zone(options.context[0], dst_zones[1:], config)]
                    # log('JEFF!!!!')
                    # log(dst_zones)
                else:
                    dst_zones = [dst_zones]
                # log(options.context[0], src_zones, dst_zones, dst_service)
                if src_zones != [] and dst_zones != []:
                    if (len(src_zones) == 1 and len(dst_zones) == 1):
                        for src_zone in src_zones:
                            if src_zone != '':
                                for dst_zone in dst_zones:
                                    if dst_zone != '':
                                        # log(src_zone, dst_zone)
                                        result = 'Read-Only'
                                        if not options.readonly:
                                            if src_zone != 'MGMT' and dst_zone != 'MGMT':
                                                result = exec_fw_command(target, options.fwtype, [('create_rule',
                                                                                                   {
                                                                                                       'rulename': rule_name,
                                                                                                       'polaction': '2',
                                                                                                       'enabled': '1',
                                                                                                       'srczones': [
                                                                                                           src_zone],
                                                                                                       'dstzones': [
                                                                                                           dst_zone],
                                                                                                       'sources': [
                                                                                                           src_address],
                                                                                                       'dests': [
                                                                                                           dst_address],
                                                                                                       'services': [
                                                                                                           dst_service],
                                                                                                       'comment': comment, })],
                                                                         syntax='api')
                                                # log('{},{},{},{},{},{},{},{},{},{}'.format(target, result, rule_name, action, src_zone, src_address, dst_zone, dst_address, dst_service, comment))
                                        return_status.append((target, result, rule_name, action, src_zone, src_address,
                                                              dst_zone, dst_address, dst_service, comment))
                    else:
                        return_status.append((target, (False, 'Src and/or Dst zones did not contain a single member'),
                                              rule_name, action, src_zones, src_address, dst_zones, dst_address,
                                              dst_service, comment))
                else:
                    return_status.append((target, (False, 'Missing Zone(s)'), rule_name, action, src_zones, src_address,
                                          dst_zones, dst_address, dst_service, comment))
            else:
                log('{},{},{}'.format(target, (False, 'Invalid Ruleitems Length'), ruleitems))
        # log('-' *180)
        return return_status
    except Exception as e:
        return [(target, 'Exception', e, '', '', '', '', '', '', '')]


if options.nexposerule:

    def run_parallel(targets, max_proc=48):

        from multiprocessing import Pool

        pool = Pool(processes=max_proc)
        results = pool.map(bulk_create_rules, targets)  # , chunksize=5)
        pool.close()
        return results


    if options.grouptargets:
        results = run_parallel(options.grouptargets)
        # log(results)
        for itemset in results:
            for target, result, rule_name, action, src_zone, src_address, dst_zone, dst_address, dst_service, comment in itemset:
                if result != 'Exception':
                    log('{},{},{},{},{},{},{},{},{},{}'.format(target, result, rule_name, action, src_zone, src_address,
                                                               dst_zone, dst_address, dst_service, comment))
                else:
                    log('{},{},{}'.format(target, 'Exception', rule_name))
    else:
        bulk_create_addresses(None)

'''

if options.nexposerule:
    #def add_rule(target):
    source_addr='{}_Nexpose_SNOW_Scanners'.format(options.nexposerule)
    #get_zones(source_addr)[0]
    #log(source_addr)
    source_zone=get_zones('sonicwall', source_addr)
    if len(source_zone)>0:
        source_zone=source_zone[0]
    log("source Zone '{}'".format(source_zone))
    if source_zone in ['', []]:
        source_zone=config['sonicwall']['addresses'][expand_address(config['sonicwall']['addresses'],source_addr,config['sonicwall']['addressmappings'])[0]]['addrObjZone']
        log("source Zone '{}'".format(source_zone))
    dest_addr='any'
    dest_zone='any'
    dest_svc='Nexpose_SNOW_Services'
    #log(source_addr, source_zone, dest_addr, dest_zone, dest_svc)

    #sw_enable_api(options.sonicwall_api_ip, options.username, options.password)
    result=False
    for rule in config['sonicwall']['policies']:
        #log(config['sonicwall']['policies'][rule]['policyName'])
        if config['sonicwall']['policies'][rule]['policyName'] =='Nexpose_SNOW':
            result='Exists'
    if result==False:
        result=exec_fw_command(options.sonicwall_api_ip, 'sw65', [('create_rule', {'rulename': 'Nexpose_SNOW', 'polaction': '2', 'enabled': '0', 'srczones': [source_zone], 'dstzones': [dest_zone], 'sources': [source_addr], 'dests': [dest_addr], 'services': [dest_svc], 'comment': 'RITM4832011 - TASK4688014 - Nexpose_SNOW', })], syntax='api')
    log('Rule Created: {},{},{},{},{}'.format(result, len(config['sonicwall']['addressmappings']['{}_Nexpose_SNOW_Scanners'.format(options.nexposerule)]),len(config['sonicwall']['addressmappings']['{}_Nexpose'.format(options.nexposerule)]),len(config['sonicwall']['addressmappings']['{}_Snow'.format(options.nexposerule)]),len(config['sonicwall']['servicemappings']['Nexpose_SNOW_Services']) ))
'''

if not True:
    for address in config['shared']['addresses']:
        log(address)

if not True:
    for context in config:
        if config[context]['config']['fw_type'].lower() == 'checkpoint':
            log('Showing routing table for {}'.format(context))
            for route in config[context]['routing']:
                log(config[context]['routing'][route])
if not True:
    for context in config:
        if config[context]['config']['fw_type'].lower() == 'checkpoint':
            log('Showing interfaces for {}'.format(context))
            for interface in config[context]['interfaces']:
                log(config[context]['interfaces'][interface])

if not True:
    log(get_zone_old('checkpoint', '{}'.format("143.166.93.175")))

if options.fixzones:
    log('')
    log(options.fixzones)
    # for context in config:
    #    log(context)
    if options.fixzones in config:
        # options.username='admin'
        # options.password='snowflake'
        # fwip='10.215.18.81'
        fw = 'pano'
        config[options.fixzones]['routing'], config[options.fixzones]['interfaces'], config[options.fixzones][
            'zones'] = load_checkpoint_routing(options.checkpointroute)
        for interface in config[options.fixzones]['interfaces']:
            if config[options.fixzones]['interfaces'][interface]['iface_name'] == 'eth1-01':
                config[options.fixzones]['interfaces'][interface]['interface_Zone'] = 'Extranet_DMZ'  ##PS3
                config[options.fixzones]['interfaces'][interface]['interface_Zone'] = 'Extranet_DMZ'  ##PC1
            if config[options.fixzones]['interfaces'][interface]['iface_name'] == 'eth2-01':
                config[options.fixzones]['interfaces'][interface]['interface_Zone'] = 'Dell_Corp'  ##PS3
                config[options.fixzones]['interfaces'][interface]['interface_Zone'] = 'Dell_Corp'  ##PC1
            if config[options.fixzones]['interfaces'][interface]['iface_name'] == 'eth1-02':
                config[options.fixzones]['interfaces'][interface]['interface_Zone'] = 'External_OSP'  ##PS3
                config[options.fixzones]['interfaces'][interface]['interface_Zone'] = 'External_OSP'  ##PC1
            if config[options.fixzones]['interfaces'][interface]['iface_name'] == 'bond1':
                config[options.fixzones]['interfaces'][interface]['interface_Zone'] = 'DTC_DMZ'  ##PS3
                config[options.fixzones]['interfaces'][interface]['interface_Zone'] = 'DTC_DMZ'  ##PC1
        # log(get_zone_old(options.fixzones, '163.244.108.0'))
        # exit(1)
        # log(config[options.fixzones]['zones'])
        src_counter = 0
        dst_counter = 0
        for policy in config[options.fixzones]['policies']:
            policy_name = config[options.fixzones]['policies'][policy]['policyName']
            # log(config[options.fixzones]['policies'][policy])
            policy_src_zones = []
            policy_dst_zones = []
            new_policy_src_zones = []
            new_policy_dst_zones = []

            for address in config[options.fixzones]['policies'][policy]['policySrcNet']:
                tmp_src_zones = get_zones(options.fixzones, address)
                for zone in tmp_src_zones:
                    if zone not in policy_src_zones:
                        policy_src_zones.append(zone)
            policy_src_zones.sort()
            config[options.fixzones]['policies'][policy]['policySrcZone'].sort()
            for zone in policy_src_zones:
                if zone not in config[options.fixzones]['policies'][policy]['policySrcZone'] and \
                        config[options.fixzones]['policies'][policy]['policySrcZone'] != ['any']:
                    if zone not in new_policy_src_zones:
                        new_policy_src_zones.append(zone)
                    src_counter += 1
            if new_policy_src_zones != []:
                result = 'Read-Only'
                result = exec_fw_command(options.panoramaip, fw, [('modify_rule',
                                                                   {'action': 'addmembers', 'policyname': policy_name,
                                                                    'srczones': new_policy_src_zones,
                                                                    'context': options.fixzones})], syntax='api')
                log('Policy {} Orig Src Zones: {} Added Zones: {} Result: {}'.format(policy, config[options.fixzones][
                    'policies'][policy]['policySrcZone'], new_policy_src_zones, result))

            # if (set(config[options.fixzones]['policies'][policy]['policySrcZone']) & set(policy_src_zones) != set(config[options.fixzones]['policies'][policy]['policySrcZone'])) and config[options.fixzones]['policies'][policy]['policySrcZone'] != ['any']:
            #   log('Policy {} Src Zones: {} Computed Zones: {}'.format(policy, config[options.fixzones]['policies'][policy]['policySrcZone'], policy_src_zones))

            for address in config[options.fixzones]['policies'][policy]['policyDstNet']:
                tmp_dst_zones = get_zones(options.fixzones, address)
                for zone in tmp_dst_zones:
                    if zone not in policy_dst_zones:
                        policy_dst_zones.append(zone)
            policy_dst_zones.sort()
            config[options.fixzones]['policies'][policy]['policyDstZone'].sort()
            # if config[options.fixzones]['policies'][policy]['policyDstZone'] != policy_dst_zones and config[options.fixzones]['policies'][policy]['policyDstZone'] != ['any']:
            for zone in policy_dst_zones:
                if zone not in config[options.fixzones]['policies'][policy]['policyDstZone'] and \
                        config[options.fixzones]['policies'][policy]['policyDstZone'] != ['any']:
                    if zone not in new_policy_dst_zones:
                        new_policy_dst_zones.append(zone)
                    dst_counter += 1
            if new_policy_dst_zones != []:
                result = 'Read-Only'
                result = exec_fw_command(options.panoramaip, fw, [('modify_rule',
                                                                   {'action': 'addmembers', 'policyname': policy_name,
                                                                    'dstzones': new_policy_dst_zones,
                                                                    'context': options.fixzones})], syntax='api')
                log('Policy {} Orig Dst Zones: {} Added Zones: {} Result: {}'.format(policy, config[options.fixzones][
                    'policies'][policy]['policyDstZone'], new_policy_dst_zones, result))
        log(src_counter, dst_counter)

        # for policy in config['']

if options.fixzones3:
    log('')
    if options.fixzones3 in config:
        fw = 'pano'

        src_counter = 0
        dst_counter = 0
        for policy in config[options.fixzones3]['policies']:
            policy_name = config[options.fixzones3]['policies'][policy]['policyName']
            # log(config[options.fixzones3]['policies'][policy])
            policy_src_zones = []
            policy_dst_zones = []
            new_policy_src_zones = []
            new_policy_dst_zones = []
            if config[options.fixzones3]['policies'][policy]['policySrcNet'] in [['EMC-exclude-dmz'],
                                                                                 ['EMC-exclude-dmz', 'VPN-Clients'],
                                                                                 ['VPN-Clients', 'EMC-exclude-dmz'],
                                                                                 ['EMC-xclude-DMZ'],
                                                                                 ['EMC-xclude-DMZ', 'VPN-Clients'],
                                                                                 ['VPN-Clients', 'EMC-xclude-DMZ']]:
                for srczone in config[options.fixzones3]['policies'][policy]['policySrcZone']:
                    if srczone != 'Dell_Corp':
                        new_policy_src_zones.append(srczone)
            if config[options.fixzones3]['policies'][policy]['policyDstNet'] in [['EMC-exclude-dmz'],
                                                                                 ['EMC-exclude-dmz', 'VPN-Clients'],
                                                                                 ['VPN-Clients', 'EMC-exclude-dmz'],
                                                                                 ['EMC-xclude-DMZ'],
                                                                                 ['EMC-xclude-DMZ', 'VPN-Clients'],
                                                                                 ['VPN-Clients', 'EMC-xclude-DMZ']]:
                for dstzone in config[options.fixzones3]['policies'][policy]['policyDstZone']:
                    if dstzone != 'Dell_Corp':
                        new_policy_dst_zones.append(dstzone)
            result = 'Read-Only'
            if new_policy_src_zones != [] and new_policy_src_zones != config[options.fixzones3]['policies'][policy][
                'policySrcNet']:
                if list(set(config[options.fixzones3]['policies'][policy]['policySrcZone']) ^ set(
                        new_policy_src_zones)) != []:
                    # result=exec_fw_command(options.panoramaip, fw, [('modify_rule', {'action': 'setmembers', 'policyname': policy_name,
                    # 'srczones': list(set(config[options.fixzones3]['policies'][policy]['policySrcZone']) ^ set(new_policy_src_zones)), 'context': options.fixzones3})], syntax='api')
                    log('"Src","{}","{}","{}","{}","{}","{}","{}"'.format(policy,
                                                                          config[options.fixzones3]['policies'][policy][
                                                                              'policyName'],
                                                                          config[options.fixzones3]['policies'][policy][
                                                                              'policySrcZone'], new_policy_src_zones,
                                                                          list(set(
                                                                              config[options.fixzones3]['policies'][
                                                                                  policy]['policySrcZone']) ^ set(
                                                                              new_policy_src_zones)),
                                                                          config[options.fixzones3]['policies'][policy][
                                                                              'policySrcNet'], result))
            if new_policy_dst_zones != [] and new_policy_dst_zones != config[options.fixzones3]['policies'][policy][
                'policyDstNet']:
                if list(set(config[options.fixzones3]['policies'][policy]['policyDstZone']) ^ set(
                        new_policy_dst_zones)) != []:
                    # result=exec_fw_command(options.panoramaip, fw, [('modify_rule', {'action': 'setmembers', 'policyname': policy_name,
                    # 'dstzones': list(set(config[options.fixzones3]['policies'][policy]['policyDstZone']) ^ set(new_policy_dst_zones)), 'context': options.fixzones3})], syntax='api')
                    log('"Src","{}","{}","{}","{}","{}","{}","{}"'.format(policy,
                                                                          config[options.fixzones3]['policies'][policy][
                                                                              'policyName'],
                                                                          config[options.fixzones3]['policies'][policy][
                                                                              'policyDstZone'], new_policy_dst_zones,
                                                                          list(set(
                                                                              config[options.fixzones3]['policies'][
                                                                                  policy]['policyDstZone']) ^ set(
                                                                              new_policy_dst_zones)),
                                                                          config[options.fixzones3]['policies'][policy][
                                                                              'policyDstNet'], result))

if options.fixzones2:
    log('')
    # log(options.fixzones2)
    # for context in config:
    #    log(context)
    if options.fixzones2 in config:
        # options.username='admin'
        # options.password='snowflake'
        # fwip='10.215.18.81'
        fw = 'pano'
        config[options.fixzones2]['routing'], config[options.fixzones2]['interfaces'], config[options.fixzones2][
            'zones'] = load_checkpoint_routing(options.checkpointroute)
        for zonemap in options.fixzonemaps:
            # log(zonemap)
            checkpoint_interface, oldzone, newzone = zonemap.split(',')
            for interface in config[options.fixzones2]['interfaces']:
                if config[options.fixzones2]['interfaces'][interface]['iface_name'] == checkpoint_interface:
                    config[options.fixzones2]['interfaces'][interface]['interface_Zone'] = newzone  ##PS3

        src_counter = 0
        dst_counter = 0
        for policy in config[options.fixzones2]['policies']:
            policy_name = config[options.fixzones2]['policies'][policy]['policyName']
            # log(config[options.fixzones2]['policies'][policy])
            policy_src_zones = []
            policy_dst_zones = []
            new_policy_src_zones = []
            new_policy_dst_zones = []

            for address in config[options.fixzones2]['policies'][policy]['policySrcNet']:
                if address in config[options.fixzones2]['addresses']:
                    tmp_src_zones = get_zones2(options.fixzones2, address)
                    for zone in tmp_src_zones:
                        if zone not in policy_src_zones:
                            policy_src_zones.append(zone)
            policy_src_zones.sort()
            config[options.fixzones2]['policies'][policy]['policySrcZone'].sort()
            for zone in policy_src_zones:
                if zone not in config[options.fixzones2]['policies'][policy]['policySrcZone'] and \
                        config[options.fixzones2]['policies'][policy]['policySrcZone'] != ['any']:
                    if zone not in new_policy_src_zones:
                        new_policy_src_zones.append(zone)
                    src_counter += 1
            if new_policy_src_zones != []:
                result = 'Read-Only'
                result = exec_fw_command(options.panoramaip, fw, [('modify_rule',
                                                                   {'action': 'addmembers', 'policyname': policy_name,
                                                                    'srczones': new_policy_src_zones,
                                                                    'context': options.fixzones2})], syntax='api')
                log('"Src","{}","{}","{}","{}"'.format(policy,
                                                       config[options.fixzones2]['policies'][policy]['policySrcZone'],
                                                       new_policy_src_zones, result))

            # if (set(config[options.fixzones2]['policies'][policy]['policySrcZone']) & set(policy_src_zones) != set(config[options.fixzones2]['policies'][policy]['policySrcZone'])) and config[options.fixzones2]['policies'][policy]['policySrcZone'] != ['any']:
            #   log('Policy {} Src Zones: {} Computed Zones: {}'.format(policy, config[options.fixzones2]['policies'][policy]['policySrcZone'], policy_src_zones))

            for address in config[options.fixzones2]['policies'][policy]['policyDstNet']:
                if address in config[options.fixzones2]['addresses']:
                    tmp_dst_zones = get_zones2(options.fixzones2, address)
                    for zone in tmp_dst_zones:
                        if zone not in policy_dst_zones:
                            policy_dst_zones.append(zone)
            policy_dst_zones.sort()
            config[options.fixzones2]['policies'][policy]['policyDstZone'].sort()
            # if config[options.fixzones2]['policies'][policy]['policyDstZone'] != policy_dst_zones and config[options.fixzones2]['policies'][policy]['policyDstZone'] != ['any']:
            for zone in policy_dst_zones:
                if zone not in config[options.fixzones2]['policies'][policy]['policyDstZone'] and \
                        config[options.fixzones2]['policies'][policy]['policyDstZone'] != ['any']:
                    if zone not in new_policy_dst_zones:
                        new_policy_dst_zones.append(zone)
                    dst_counter += 1
            if new_policy_dst_zones != []:
                result = 'Read-Only'
                result = exec_fw_command(options.panoramaip, fw, [('modify_rule',
                                                                   {'action': 'addmembers', 'policyname': policy_name,
                                                                    'dstzones': new_policy_dst_zones,
                                                                    'context': options.fixzones2})], syntax='api')
                log('"Dst","{}","{}","{}","{}"'.format(policy,
                                                       config[options.fixzones2]['policies'][policy]['policyDstZone'],
                                                       new_policy_dst_zones, result))
        log(src_counter, dst_counter)

        # for policy in config['']

if not True:
    service_list = []
    # for address in config['Extranet_PS3']['addresses']: # addrObjIdDisp
    #    if config['Extranet_PS3']['addresses'][address]['addrObjId'] not in address_list:
    #        address_list.append(config['Extranet_PS3']['addresses'][address]['addrObjId'])
    for policy in config['Extranet_PS3']['policies']:
        if config['Extranet_PS3']['policies'][policy]['policyDstSvc'] == []:
            log(config['Extranet_PS3']['policies'][policy])
        # for service in config['Extranet_PS3']['policies'][policy]['policyDstSvc']:
        #    if service not in config['Extranet_PS3']['services']:
        #        log(service)

if options.rename:
    renames = [('Splunk_AMER_Indexers', 'SplunkCS_AMER_Indexers'),
               ('Splunk_APAC_Indexers', 'SplunkCS_APAC_Indexers'),
               ('Splunk_EMEA_Indexers', 'SplunkCS_EMEA_Indexers'),
               ('Splunk_HeavyForwarders', 'SplunkCS_HeavyForwarders'),
               ('Splunk_SearchHeads', 'SplunkCS_SearchHeads'),
               ('Splunk_DeploymentServers', 'SplunkCS_DeploymentServers'),
               ('Splunk_AutomationServers', 'SplunkCS_AutomationServers')]
    renames = [('SplunkCS_JumpBoxes', 'SplunkCS_JumpboxServers')]

    for fwip in options.grouptargets:
        try:

            fw = 'sw65'

            # oldname,newname=options.rename.split(',')
            session = requests.Session()
            session.mount('https://' + fwip, sw.DESAdapter())
            response = sw.do_login(session, options.username, options.password, fwip, True)
            if response:
                sw.do_logout(session, fwip)
                for oldname, newname in renames:
                    result = exec_fw_command(fwip, fw, [
                        ('modify_address', {'action': 'rename', 'addressname': oldname, 'newaddressname': newname})],
                                             syntax='api')
                    log('{:20.20s} {:40.40s} {:40.40s} {:100.100s}'.format(fwip, oldname, newname, str(result)))
            else:
                log('{:20.20s} {:40.40s} {:40.40s} {:100.100s}'.format(fwip, '', '', 'Login Failed'))
        except Exception as e:
            log('{:20.20s} {:40.40s} {:40.40s} {:100.100s}'.format(fwip, '', '', 'Exception Occured'))
# log('jeff')
# for context in config:
#    for rule in config[context]['policies']:
#        log(config[context]['policies'][rule])

if options.fixcomments and len(config['sonicwall']['addresses']) > 1:
    # target=options.grouptargets[0]
    # comment='RITM5284122 - TASK5885697'
    # commands=[]
    # for address in options.fixcomments:

    #    commands.append(('modify_address', {'addressname': address, 'action': 'comment', 'comment': comment, 'addresstype': '1', 'context': 'shared'}))
    # for command in commands:
    #    log(command)
    # log(exec_fw_command(target, 'pano', commands, syntax='api'))
    #    #('modify_rule', { 'context': 'shared', 'policyname': cmd['policy_name'], 'action': 'comment', 'comment': cmd['comment'] + options.inversecomment })
    #
    target = options.sonicwall_api_ip

    if 'GLOBAL_SCCM' in config['sonicwall']['addresses']:
        log('GLOBAL_SCCM found in addresses -- adding SCCM_DTC')
        result = exec_fw_command(options.sonicwall_api_ip, 'sw65', [
            ('modify_address', {'action': 'addmembers', 'addressname': 'GLOBAL_SCCM', 'members': ['SCCM_DTC']})],
                                 syntax='api')
        log(result)
    else:
        log('GLOBAL_SCCM *NOT* found in addresses -- No changes needed')
    matches = 0

    session = requests.Session()
    session.mount('https://' + target, sw.DESAdapter())
    urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
    url = 'https://{}/api/sonicos/auth'.format(target)
    session.headers = OrderedDict(
        [('User-Agent', 'python-requests/2.18.4'), ('Accept', '*/*'), ('Accept-Encoding', 'gzip, deflate'),
         ('Connection', 'keep-alive')])
    post_data = None
    response_code = None
    login_tries = 0
    while response_code != 200 and login_tries < 5:
        login_tries += 1
        response = session.post(url=url, headers={'authorization': "Basic " + base64.b64encode(
            '{}:{}'.format(options.username, options.password).encode()).decode()}, verify=False)
        response_code = response.status_code
        if response_code != 200:
            debug('Login failed, retrying in 10 seconds')
            time.sleep(10)

    if response_code == 200:

        for rule in config['sonicwall']['policies']:
            if 'GLOBAL_SCCM' in config['sonicwall']['policies'][rule]['policySrcNet'] or 'GLOBAL_SCCM' in \
                    config['sonicwall']['policies'][rule]['policyDstNet']:
                matches += 1
                rule_to_modify = config['sonicwall']['policies'][rule]['policyUUID']
                new_comment = config['sonicwall']['policies'][rule]['policyComment'] + ' - TASK5885697 CHG0364799'
                log('GLOBAL_SCCM found in rule {} - updating comments to {}'.format(rule_to_modify, new_comment))
                url = 'https://{}/api/sonicos/direct/cli'.format(target)
                session.headers.update({'content-type': 'text/plain'})

                post_data = 'access-rule ipv4 uuid {}\ncomment "{}"\ncommit\n'.format(rule_to_modify, new_comment)
                result = session.post(url=url, data=post_data, verify=False)

                # result=exec_fw_command(target, 'sw65', [('modify_rule', {'action': 'comment', 'comment': new_comment, 'uuid': rule_to_modify})], syntax='api')
                log(result)
        log('GLOBAL_SCCM found in {} rules'.format(matches))
        url = 'https://{}/api/sonicos/auth'.format(target)
        session.delete(url=url, verify=False, timeout=options.timeout_sw_api)

if options.sccm:
    from netaddr import IPSet, IPNetwork

    for context in config:
        log(context)
        ## Add IPSet property to all non group objects
        config[context]['addresses'] = add_IPv4Network(config[context]['addresses'])

        ## Add IPSet property to all group objects
        for addr in config[context]['addresses']:
            if config[context]['addresses'][addr]['addrObjType'] == '8':
                config[context]['addresses'][addr]['IPSet'] = IPSet([])
                for groupmember in expand_address(config[context]['addresses'], addr,
                                                  config[context]['addressmappings']):
                    location = None
                    # debug(groupmember)
                    # debug(config[context]['addresses'][groupmember])
                    if groupmember in config[context]['addresses']:
                        location = context
                    elif groupmember in config['shared']['addresses']:
                        location = 'shared'
                    if location:
                        for network in config[location]['addresses'][groupmember]['IPv4Networks']:
                            config[context]['addresses'][addr]['IPSet'].add(str(network))

    for context in config:
        log(context)
        if context != 'shared':
            # add_IPv4Network(addresses)
            for address in config[context]['addresses']:
                if address in config['shared']['addresses']:
                    # log(config['shared']['addresses'][address])
                    if config['shared']['addresses'][address]['IPSet'] == config[context]['addresses'][address][
                        'IPSet']:
                        log('Address object {} matches in Device-Group {} and shared'.format(address, context))

            # original='SCCM Servers'
            # if original in config['shared']['addresses'] and original in config[context]['addresses']:
            #    log('Comparing')
            #    if config['shared']['addresses'][original]['IPSet']==config[context]['addresses'][original]['IPSet']:
            #        log('Address object {} matches in Device-Group {} and shared'.format(original, context))
            # for address in config['shared']['addresses']:

            # for address if config['shared']

if not True:
    config['Durham_Core_FINAL_Zonefix']['routing'], config['Durham_Core_FINAL_Zonefix']['interfaces'], \
    config['Durham_Core_FINAL_Zonefix']['zones'] = load_checkpoint_routing(options.checkpointroute)
    log(get_zones2('Durham_Core_FINAL_Zonefix', 'Durham-DMZ-10.105.0.0-16'))

if options.rulelist:
    for rule in options.rulelist:
        log(config['Durham_Core']['policies'][int(rule)]['policyName'])

if False:  # options.testing:
    from netaddr import IPSet, IPNetwork

    for context in config:
        for address in config[context]['addresses']:
            options.groupaddresses = []
            if 'include' in config[context]['addresses'][address]:
                address_name = config[context]['addresses'][address]['addrObjId']
                options.nexpose = address_name + '-PA'
                log('-' * 180)
                log(config[context]['addresses'][address]['include'])
                if config[context]['addresses'][address]['include'].lower() == 'any':
                    include = IPSet(IPNetwork('0.0.0.0/0'))
                else:
                    include = config[context]['addresses'][config[context]['addresses'][address]['include']]['IPSet']
                exclude = config[context]['addresses'][config[context]['addresses'][address]['exclude']]['IPSet']
                result = include - exclude
                log('INCLUDE', config[context]['addresses'][address]['include'], include)
                log('EXCLUDE', config[context]['addresses'][address]['exclude'], exclude)
                log('-' * 180)
                log('RESULT', len(result), result)
                log('-' * 180)
                for iprange in list(result.iter_ipranges()):
                    log('{}'.format(iprange))
                    options.groupaddresses.append('{},R-{}'.format(iprange, iprange))
            if options.groupaddresses != []:
                bulk_create_addresses(None, config)

if not True:
    for context in config:
        log(context)
        log(get_zones2(context, 'SplunkCS_HeavyForwarders', config))
        try:
            for route in config[context]['routing']:
                log(config[context]['routing'][route])
        except:
            pass

if False:  # options.testing:

    import sonicwall as sw
    import json
    import xmltodict

    # from bs4 import BeautifulSoup
    for target in options.grouptargets:
        session = requests.Session()
        session.mount('https://' + target, sw.DESAdapter())
        loginResult = sw.do_login(session, options.username, options.password, target, preempt=True)
        if loginResult:
            tmp = sw.get_url(session, 'https://' + target + '/getObjectList.json')  # ?type=129')
            allObjects = json.loads(tmp.text)
            for key in allObjects:
                pass
                # log(key)
            tmp = sw.get_url(session, 'https://' + target + '/getPolicies.json')
            allPolicies = json.loads(tmp.text)['ruleArray']
            # log(allPolicies.split('|')[0])
            for index, entry in enumerate(allPolicies.split('|')[1:]):
                name, action, enable, srcIface, dstIface, srcsvc, svc, src, dst, tod, tim, timUdp, frag, tcpUrg, netflow, geoip, perPolicyGeoIpBlock, perPolicyGeoIpBitmap, \
                policyGeoIpBlockUnknown, botnet, enable_sip, enable_h323, pktcap, whomInclType, whomInclStr, whomExclType, whomExclStr, whomInclStr2, whomExclStr2, cmt, \
                log, pri, priType, globalBwmParam, bwmDirStyle, bwmParam, prop, man, tableNum, fromZone, toZone, polConMax, noSSO, noSSOTrafficBlk, noRdrct, connLmtSrcEnable, \
                connLmtDstEnable, connLmtSrcThreshold, connLmtDstThreshold, qosMarkingDscpAction, qosMarkingDscpTagValue, qosMarkingDscpAllow8021pOverride, \
                qosMarking8021pAction, qosMarking8021pTagValue, defaultRule, ipver, bypassDpi, bypassDPISSLClient, bypassDPISSLServer, unusedZone, showEnabled, srcHandle, \
                dstHandle, fromZoneHandle, toZoneHandle, svcHandle, srcsvcHandle, bwUsage, whomInclGrpType, uuid, pdf, timeCreated, timeUpdated, timeCreatedSec, timeUpdatedSec, timeHitSec = entry.split(
                    ',')
                hits = sw.get_url(session,
                                  'https://' + target + '/getRulePolicyStats.xml?srcAddr={}&dstAddr={}&srcZone={}&dstZone={}&srcIface={}&dstIface={}&srcSvc={}&ipType={}&service={}'.format(
                                      srcHandle, dstHandle, fromZoneHandle, toZoneHandle, srcIface, dstIface,
                                      srcsvcHandle, '0', svcHandle))
                # print(hits.text)
                hits_dict = xmltodict.parse(hits.text)
                if not hits_dict['rule-policy-info']['uuid']:
                    print(
                        'Name: {} srcAddr={}&dstAddr={}&srcZone={}&dstZone={}&srcIface={}&dstIface={}&srcSvc={}&ipType={}&service={}'.format(
                            name, srcHandle, dstHandle, fromZoneHandle, toZoneHandle, srcIface, dstIface, srcsvcHandle,
                            '0', svcHandle))
                elif uuid != '"{}"'.format(hits_dict['rule-policy-info']['uuid']):
                    # print('UUID Mismatch', uuid, '"{}"'.format(hits_dict['rule-policy-info']['uuid']))
                    print('*{}'.format(uuid), hits_dict['rule-policy-info']['policyUsage'])
                    # print('Name: {} srcAddr={}&dstAddr={}&srcZone={}&dstZone={}&srcIface={}&dstIface={}&srcSvc={}&ipType={}&service={}'.format(name, 'srcHandle', dstHandle, fromZoneHandle, toZoneHandle, srcIface, dstIface, srcsvcHandle, '0', svcHandle))
                else:
                    # print(hits_dict['rule-policy-info'])
                    print(uuid, hits_dict['rule-policy-info']['policyUsage'])

            tmp = sw.get_url(session, 'https://' + target + '/getRouteList.json?reqType=1')
            allRoutes = json.loads(tmp.text)['pbrPolicies']
            for index, entry in enumerate(allRoutes.split('|')[1:]):
                name, properties, metric, distance, distanceAuto, priority, source, destination, service, applicationID, application, tos, tosMask, nexthopNum, \
                gateway, gatewayVer, iface, ifName, ifaceStatus, gateway2, gatewayVer2, iface2, ifName2, ifaceStatus2, gateway3, gatewayVer3, iface3, ifName3, ifaceStatus3, \
                gateway4, gatewayVer4, iface4, ifName4, ifaceStatus4, comment, probe, ipver, wxaGroup, uuid, rtype, psp, sdwanGroup, entryIndex = entry.split(
                    ',')
                # print(index)
            print(allRoutes)
        sw.do_logout(session, target)

if False:  # options.testing:
    try:

        for policy in config['sonicwall']['policies']:
            # log(config['sonicwall']['policies'][policy]['policyName'])
            if config['sonicwall']['policies'][policy]['policyName'] in ['SplunkCS_Heavy_Forwarders',
                                                                         'SplunkCS_Heavy_ForwarderVIPs',
                                                                         'SplunkCS_Server-to-Server',
                                                                         'SplunkCS_Automation_Servers']:
                # def exec_fw_command(target, fw_type, commands, syntax='cli', policylens=None, delay=None, use_session=True, use_apikey=False, dryrun=False, sw_objects=None):  # add sw_sesssion, enable_api and commit options -- what is policy lens for?
                # result=exec_fw_command(target, change[context]['fw_type'], [('modify_rule', { 'context': context, 'policyname': faddr['policy_name'], 'policynum': str(faddr['policy_num']), 'action': 'addmembers', 'sources': [ faddr['newaddress']] })] ,syntax=syntax)
                exec_fw_command(options.sonicwall_api_ip, 'sw65', [('modify_rule', {'action': 'enable', 'uuid':
                    config['sonicwall']['policies'][policy]['policyUUID']})], syntax='api')
                log(options.sonicwall_api_ip, config['sonicwall']['policies'][policy]['policyName'], 'Enabled')

    except Exception as e:
        log(options.sonicwall_api_ip, 'Exception trying to enable rules')

if False:  # options.testing:

    import json
    from urllib.parse import quote, unquote

    tconfig = {}
    tconfig['routing'] = {}
    target = '10.215.16.61'
    session = requests.Session()
    session.mount('https://' + target, sw.DESAdapter())
    loginResult = sw.do_login(session, options.username, options.password, target, preempt=True)
    result = sw.get_url(session, 'https://' + target + '/getRouteList.json')
    # log(tmp.text)
    sw.do_logout(session, target)
    ## # routing_props = ['pbrObjId', 'pbrObjProperties', 'pbrObjSrc', 'pbrObjDst', 'pbrObjSvc', 'pbrObjGw', 'pbrObjIface', 'pbrObjIfaceName', 'pbrObjMetric', 'pbrObjPriority', 'pbrObjProbe', 'pbrObjComment']
    pbrindex = 0
    for index, entry in enumerate(json.loads(result.text)['pbrPolicies'].split('|')[1:]):
        log(index, entry)
        name, properties, metric, distance, distanceAuto, priority, source, destination, service, applicationID, application, tos, tosMask, nexthopNum, \
        gateway, gatewayVer, iface, ifName, ifaceStatus, gateway2, gatewayVer2, iface2, ifName2, ifaceStatus2, gateway3, gatewayVer3, iface3, ifName3, ifaceStatus3, \
        gateway4, gatewayVer4, iface4, ifName4, ifaceStatus4, comment, probe, ipver, wxaGroup, uuid, rtype, psp, sdwanGroup, entryIndex = entry.split(
            ',')
        if ipver == '0':  ## 0 is IPv4 - do not read IPv6 routes at this time
            # log([x for x in config['sonicwall']['addresses']])
            destination = destination.strip('"')
            source = source.strip('"')
            service = service.strip('"')
            gateway = gateway.strip('"')
            # log('"{}"'.format(destination))
            if source in config['sonicwall']['addresses']:
                source = '{}/{}'.format(config['sonicwall']['addresses'][source]['addrObjIp1'],
                                        netmask_to_cidr(config['sonicwall']['addresses'][source]['addrObjIp2']))
            if gateway in config['sonicwall']['addresses']:
                gateway = '{}'.format(config['sonicwall']['addresses'][gateway]['addrObjIp1'])
            if destination in config['sonicwall']['addresses']:
                log('Destination in Address objects - expand it!')
                log(expand_address(config['sonicwall']['addresses'], destination,
                                   config['sonicwall']['addressmappings'], inc_group=False))
                for each_dest in expand_address(config['sonicwall']['addresses'], destination,
                                                config['sonicwall']['addressmappings'], inc_group=False):
                    log(each_dest, pbrindex)
                    tconfig['routing'][pbrindex] = OrderedDict()
                    tconfig['routing'][pbrindex]['pbrObjId'] = name
                    tconfig['routing'][pbrindex]['pbrObjProperties'] = properties
                    tconfig['routing'][pbrindex]['pbrObjSrc'] = source
                    tconfig['routing'][pbrindex]['pbrObjDst'] = '{}/{}'.format(
                        config['sonicwall']['addresses'][each_dest]['addrObjIp1'],
                        netmask_to_cidr(config['sonicwall']['addresses'][each_dest]['addrObjIp2']))
                    tconfig['routing'][pbrindex]['pbrObjSvc'] = service
                    tconfig['routing'][pbrindex]['pbrObjGw'] = gateway
                    tconfig['routing'][pbrindex]['pbrObjIface'] = iface
                    tconfig['routing'][pbrindex]['pbrObjIfaceName'] = ifName
                    tconfig['routing'][pbrindex]['pbrObjMetric'] = metric
                    tconfig['routing'][pbrindex]['pbrObjPriority'] = priority
                    tconfig['routing'][pbrindex]['pbrObjProbe'] = probe
                    tconfig['routing'][pbrindex]['pbrObjComment'] = comment
                    tconfig['routing'][pbrindex]['pbrObjUUID'] = uuid
                    # log(tconfig['routing'][index]['pbrObjDst'], ipver)
                    pbrindex += 1

            else:
                log('Destination not in Address objects - use as is!')
                log(destination, pbrindex)
                tconfig['routing'][pbrindex] = OrderedDict()
                tconfig['routing'][pbrindex]['pbrObjId'] = name
                tconfig['routing'][pbrindex]['pbrObjProperties'] = properties
                tconfig['routing'][pbrindex]['pbrObjSrc'] = source
                tconfig['routing'][pbrindex]['pbrObjDst'] = destination
                tconfig['routing'][pbrindex]['pbrObjSvc'] = service
                tconfig['routing'][pbrindex]['pbrObjGw'] = gateway
                tconfig['routing'][pbrindex]['pbrObjIface'] = iface
                tconfig['routing'][pbrindex]['pbrObjIfaceName'] = ifName
                tconfig['routing'][pbrindex]['pbrObjMetric'] = metric
                tconfig['routing'][pbrindex]['pbrObjPriority'] = priority
                tconfig['routing'][pbrindex]['pbrObjProbe'] = probe
                tconfig['routing'][pbrindex]['pbrObjComment'] = comment
                tconfig['routing'][pbrindex]['pbrObjUUID'] = uuid
                pbrindex += 1
            # log(config['sonicwall'])
            # log(tconfig['routing'][index]['pbrObjDst'], ipver)
    for route in tconfig['routing']:
        log(tconfig['routing'][route])

    for route in config['sonicwall']['routing']:
        log(config['sonicwall']['routing'][route])

    # for address in config['sonicwall']['addresses']:
    # log(address)

    # https://10.215.16.61/getRouteList.json?reqType=1
'''

for route in config['sonicwall']['routing']:
    #log(config['sonicwall']['routing'][route]['pbrObjDst'])
    #log(config['sonicwall']['routing'][route]['pbrObjGw'])
    for interface in config['sonicwall']['interfaces']:
        if config['sonicwall']['interfaces'][interface]['iface_name']==config['sonicwall']['routing'][route]['pbrObjIfaceName']:
            log(config['sonicwall']['routing'][route]['pbrObjDst'], config['sonicwall']['routing'][route]['pbrObjGw'], config['sonicwall']['interfaces'][interface]['interface_Zone'])
            break

dest_ip='192.16.1.0'
log('zone for {}: {}'.format(dest_ip, get_zone('sonicwall', dest_ip, config)))

'''

if options.testing:
    syntax = 'api'
    fw = 'sw65'
    fwip = '10.215.16.61'
    result = exec_fw_command(fwip, fw, [('create_address',
                                         {'addressname': 'test_fqdn', 'domain': 'www.deleteme.com', 'ttl': '120',
                                          'addresstype': 'fqdn', 'zone': 'LAN', 'color': 'black'})], syntax=syntax)
    log(result)

